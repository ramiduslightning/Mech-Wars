<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MECH WARS</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; touch-action: none; }
        body { background: #0a0a0a; overflow: hidden; font-family: 'Share Tech Mono', monospace; }
        #gameContainer { position: relative; width: 100vw; height: 100vh; background: #000; }
        /* Default cursor before the game starts (helps clicking DEPLOY reliably) */
        #gameCanvas { display: block; width: 100%; height: 100%; cursor: default; }

        /* Small neon green crosshair cursor during gameplay */
        body.inGame #gameCanvas { cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24'%3E%3Cline x1='12' y1='4' x2='12' y2='10' stroke='%2300ffcc' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='12' y1='14' x2='12' y2='20' stroke='%2300ffcc' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='4' y1='12' x2='10' y2='12' stroke='%2300ffcc' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='14' y1='12' x2='20' y2='12' stroke='%2300ffcc' stroke-width='1.5' stroke-linecap='round'/%3E%3Ccircle cx='12' cy='12' r='1.5' fill='%2300ffcc'/%3E%3C/svg%3E") 12 12, crosshair; }
        
        /* Bullseye removed - gun rotation shows aiming */
        #bullseye { display: none; }
        
        #hud {
 position: absolute; top: 0; left: 0; right: 0; padding: 15px 20px; padding-right: 340px; display: flex; justify-content: flex-start; gap: 12px; align-items: flex-start; pointer-events: none; z-index: 10; }
        
        /* Reposition the status/fuel panel so it doesn't cover background art (e.g., the blue planet) */
        #statusPanel{
            position: absolute;
            top: 15px;
            right: 20px;
            max-width: 300px;
        }
.hud-panel { background: rgba(0, 10, 20, 0.85); border: 2px solid #00ffcc; padding: 12px 18px; box-shadow: 0 0 25px rgba(0, 255, 204, 0.4), inset 0 0 40px rgba(0, 255, 204, 0.1); clip-path: polygon(0 0, calc(100% - 12px) 0, 100% 12px, 100% 100%, 12px 100%, 0 calc(100% - 12px)); }
        .hud-label { font-family: 'Orbitron', sans-serif; font-size: 10px; color: #00ffcc; letter-spacing: 3px; margin-bottom: 5px; text-shadow: 0 0 10px #00ffcc; }
        .hud-value { font-family: 'Orbitron', sans-serif; font-size: 28px; font-weight: 900; color: #fff; text-shadow: 0 0 15px #00ffcc, 0 0 30px #00ffcc; }
        #healthBar { width: 180px; height: 14px; background: linear-gradient(180deg, #1a1a1a, #0a0a0a); border: 2px solid #00ffcc; margin-top: 5px; overflow: hidden; }
        #healthFill { height: 100%; background: linear-gradient(90deg, #ff0000, #ff6600, #00ffcc); transition: width 0.3s; }
        #flyMeter { width: 120px; height: 10px; background: #1a1a1a; border: 2px solid #ffcc00; margin-top: 8px; overflow: hidden; }
        #flyFill { height: 100%; width: 0%; background: linear-gradient(90deg, #ffcc00, #ff6600, #ff3300); transition: width 0.2s; }
        #mobileControls { display: block; position: relative; pointer-events: none; }
        #mobileControls > * { pointer-events: auto; }
        .mobile-btn { width: 90px; height: 90px; border-radius: 50%; border: 4px solid; font-family: 'Orbitron', sans-serif; font-weight: 700; font-size: 11px; display: flex; align-items: center; justify-content: center; text-align: center; cursor: pointer; }
/* removed */         #moveBtn { background: rgba(0, 255, 204, 0.25); border-color: #00ffcc; color: #00ffcc; }
/* removed */         #fireBtn { background: rgba(255, 51, 51, 0.25); border-color: #ff3333; color: #ff3333; }
        #flyBtn { position: fixed; bottom: 85px; right: 10px; width: 52px; height: 52px; font-size: 9px; background: rgba(255, 204, 0, 0.25); border-color: #ffcc00; color: #ffcc00; z-index: 20; border-width: 3px; }
        #shieldBtn { position: fixed; bottom: 145px; right: 10px; width: 52px; height: 52px; font-size: 9px; background: rgba(120, 180, 255, 0.22); border-color: #66aaff; color: #66aaff; z-index: 20; border-width: 3px; }
        .mobile-btn:active, .mobile-btn.active { transform: scale(0.92); filter: brightness(1.6); }
        #soundToggle { display: none !important; }
        #startScreen, #gameOverScreen { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(ellipse at center, rgba(10,20,40,0.95) 0%, rgba(0,0,0,0.98) 100%); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; }
        #gameOverScreen { display: none; }
        .title { font-family: 'Orbitron', sans-serif; font-size: clamp(40px, 12vw, 90px); font-weight: 900; color: #00ffcc; text-shadow: 0 0 40px #00ffcc, 0 0 80px #00aaff, 0 0 120px #0066ff; letter-spacing: 12px; margin-bottom: 5px; animation: titlePulse 2s infinite; }
        .title span { color: #ff4444; text-shadow: 0 0 40px #ff4444, 0 0 80px #ff0000; }
        @keyframes titlePulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.85; } }
        .subtitle { font-family: 'Share Tech Mono', monospace; font-size: clamp(12px, 2.5vw, 18px); color: #888; letter-spacing: 4px; margin-bottom: 14px; }
        .byline { font-family: 'Share Tech Mono', monospace; font-size: 12px; color: #6fc; letter-spacing: 2px; opacity: 0.85; margin-bottom: 26px; text-shadow: 0 0 10px rgba(0,255,204,0.35); }
        .instructions { font-family: 'Share Tech Mono', monospace; font-size: 14px; color: #aaa; text-align: center; line-height: 2.2; margin-bottom: 40px; }
        .instructions span { color: #00ffcc; text-shadow: 0 0 10px #00ffcc; }
        .instructions .warn { color: #ff6600; }
        .start-btn { font-family: 'Orbitron', sans-serif; font-size: 20px; font-weight: 700; padding: 18px 60px; background: transparent; border: 3px solid #00ffcc; color: #00ffcc; cursor: pointer; letter-spacing: 5px; transition: all 0.3s; }
        .start-btn:hover { background: #00ffcc; color: #0a0a0a; box-shadow: 0 0 40px #00ffcc; }
        #finalScore { font-family: 'Orbitron', sans-serif; font-size: 56px; color: #ffcc00; margin: 20px 0; text-shadow: 0 0 30px #ffcc00; }
        #easterEggHint { position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); font-family: 'Orbitron', sans-serif; font-size: 14px; color: #ffcc00; opacity: 0; transition: opacity 0.5s; text-shadow: 0 0 20px #ffcc00; z-index: 25; }
        #easterEggHint.show { opacity: 1; animation: hintBlink 0.8s infinite; }
        @keyframes hintBlink { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        #soundToggle { position: absolute; top: 20px; right: 20px; font-family: 'Orbitron', sans-serif; font-size: 12px; padding: 8px 15px; background: rgba(0,0,0,0.5); border: 2px solid #00ffcc; color: #00ffcc; cursor: pointer; z-index: 50; }
        #waveAnnounce { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: 'Orbitron', sans-serif; font-size: clamp(18px, 4.6vw, 40px); color: #ff6600; text-shadow: 0 0 18px #ff6600, 0 0 36px #ff3300; opacity: 0; pointer-events: none; z-index: 30; letter-spacing: 2px; white-space: normal; text-align: center; width: min(92vw, 920px); line-height: 1.15; }
        @media (max-width: 600px) { 
            .hud-value { font-size: 18px; } 
            #healthBar { width: 110px; height: 12px; }
            /* Hide unnecessary UI on mobile */
            #hud {
 display: none !important; }
            
            /* D-pad stays fixed positioned */
            .dpad { 
                bottom: 10px !important; 
                left: 10px !important;
            }
            
            /* Ability buttons sized for this breakpoint */
            #flyBtn, #shieldBtn { width: 52px; height: 52px; }
        }
        
        /* Mobile-specific adjustments */
        @media (max-width: 480px) {
            .dpad { width: 105px; height: 105px; grid-template-columns: 32px 32px 32px; grid-template-rows: 32px 32px 32px; padding: 2px; bottom: 8px !important; left: 8px !important; }
            .dpad-btn { font-size: 8px; border-radius: 7px; }
            .dpad-btn.fire { font-size: 8px; }
            .hud-abilities { bottom: 120px !important; right: 10px !important; }
            .mobile-fuel-bar { width: 44px; }
            #flyBtn, #shieldBtn { width: 48px; height: 48px; font-size: 8px; }
            #pauseBtn { bottom: 10px; right: 10px; width: 45px; height: 45px; font-size: 8px; }
            #easterEggHint { font-size: 10px; bottom: 70px; }
        }
        
        /* Very small screens */
        @media (max-width: 380px) {
            .dpad { width: 95px; height: 95px; grid-template-columns: 29px 29px 29px; grid-template-rows: 29px 29px 29px; padding: 2px; bottom: 8px !important; left: 8px !important; }
            .dpad-btn { font-size: 7px; border-radius: 6px; }
            .dpad-btn.fire { font-size: 7px; }
            .hud-abilities { bottom: 105px !important; right: 8px !important; }
            .mobile-fuel-bar { width: 40px; }
            #flyBtn, #shieldBtn { width: 44px; height: 44px; font-size: 7px; }
            #pauseBtn { width: 40px; height: 40px; font-size: 7px; }
        }
        
        /* Landscape phone */
        @media (max-height: 500px) and (orientation: landscape) {
            .dpad { width: 100px; height: 100px; grid-template-columns: 31px 31px 31px; grid-template-rows: 31px 31px 31px; padding: 2px; bottom: 6px !important; left: 6px !important; }
            .dpad-btn { font-size: 8px; border-radius: 6px; }
            .hud-abilities { bottom: 90px !important; right: 8px !important; gap: 6px !important; }
            #flyBtn, #shieldBtn { width: 40px; height: 40px; font-size: 7px; }
            #pauseBtn { bottom: 6px; right: 6px; width: 40px; height: 40px; font-size: 7px; }
            #easterEggHint { bottom: 50px; font-size: 9px; }
            
            /* COMPACT START SCREEN FOR LANDSCAPE */
            .title { font-size: clamp(32px, 7vw, 50px) !important; margin-bottom: 3px !important; letter-spacing: 4px !important; }
            .subtitle { font-size: clamp(9px, 1.8vw, 12px) !important; margin-bottom: 8px !important; letter-spacing: 2px !important; }
            .instructions { font-size: 10px !important; line-height: 1.3 !important; margin-bottom: 12px !important; padding: 0 10px; }
            .start-btn { font-size: 15px !important; padding: 8px 25px !important; letter-spacing: 3px !important; }
            #startScreen, #gameOverScreen { padding: 8px 10px; justify-content: center; gap: 0; }
            #finalScore { font-size: 32px !important; margin: 8px 0 !important; }
        }
        
        /* Portrait mode message for phones */
        #orientationMsg {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 200;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            color: #00ffcc;
            text-align: center;
            padding: 20px;
        }
        #orientationMsg .rotate-icon {
            font-size: 60px;
            margin-bottom: 15px;
        }
        #orientationMsg h2 {
            font-size: 20px;
            margin-bottom: 8px;
            text-shadow: 0 0 20px #00ffcc;
        }
        #orientationMsg p {
            font-size: 13px;
            color: #888;
            margin-top: 8px;
        }
        @media (max-width: 768px) and (max-height: 600px) and (orientation: portrait) {
            #orientationMsg {
                display: flex !important;
            }
        }
    
/* ===== D-Pad Controls (desktop + mobile) - NEON BLUE ===== */
.dpad{
  position: fixed;
  bottom: 10px;
  left: 10px;
  width: 120px; height: 120px; border-radius: 16px;
  background: linear-gradient(135deg, rgba(100,180,255,.12), rgba(80,160,255,.04));
  border: 1px solid rgba(100,180,255,.3);
  box-shadow: 0 0 25px rgba(100,180,255,.4), 0 8px 32px rgba(0,0,0,.4), inset 0 1px 0 rgba(120,200,255,.2);
  backdrop-filter: blur(12px);
  display: grid;
  grid-template-columns: 37px 37px 37px;
  grid-template-rows: 37px 37px 37px;
  padding: 3px;
  user-select: none; -webkit-user-select: none;
  touch-action: none;
  cursor: move;
  z-index: 20;
}

/* Make D-pad smaller on phones only */
@media (max-width: 600px) {
  .dpad {
    width: 100px; 
    height: 100px; 
    border-radius: 14px;
    grid-template-columns: 31px 31px 31px;
    grid-template-rows: 31px 31px 31px;
    padding: 2px;
  }
}
.dpad-btn{
  display:flex; align-items:center; justify-content:center;
  border-radius:8px;
  border:1px solid rgba(100,180,255,.25);
  background: linear-gradient(135deg, rgba(100,180,255,.18), rgba(80,160,255,.06));
  color: rgba(180,220,255,.95);
  font-weight: 600;
  font-size: 9px;
  letter-spacing:.2px;
  box-shadow: inset 0 1px 0 rgba(120,200,255,.12), 0 2px 8px rgba(0,0,0,.15);
  cursor: pointer;
  text-shadow: 0 0 6px rgba(100,180,255,.8);
  transition: all 0.1s ease;
}
.dpad-btn:active{ 
  transform: translateY(1px) scale(0.98); 
  background: linear-gradient(135deg, rgba(100,180,255,.25), rgba(80,160,255,.12));
  box-shadow: 0 0 15px rgba(100,180,255,.5), inset 0 1px 3px rgba(0,0,0,.2);
}
.dpad-btn.on{ 
  background: linear-gradient(135deg, rgba(100,180,255,.35), rgba(80,160,255,.18));
  box-shadow: 0 0 20px rgba(100,180,255,.6), inset 0 0 10px rgba(120,200,255,.25);
  color: rgba(200,230,255,1);
  border-color: rgba(120,200,255,.5);
  text-shadow: 0 0 10px rgba(100,180,255,1);
}
.dpad-btn.up{ grid-column:2; grid-row:1; }
.dpad-btn.left{ grid-column:1; grid-row:2; }
.dpad-btn.fire{ grid-column:2; grid-row:2; font-size: 9px; font-weight: 700; }
.dpad-btn.right{ grid-column:3; grid-row:2; }
.dpad-btn.down{ grid-column:2; grid-row:3; }
.abilityStack{ display:flex; flex-direction:column; gap:6px; align-items:stretch; }
.mobile-btn.ability.hidden{ display:none !important; }

/* Pause button styling - Faded white, glows blue when paused */
#pauseBtn { 
    position: fixed; 
    bottom: 20px; 
    right: 20px; 
    width: 55px;
    height: 55px;
    font-size: 10px;
    background: rgba(255, 255, 255, 0.08); 
    border: 3px solid rgba(255, 255, 255, 0.2);
    color: rgba(255, 255, 255, 0.5); 
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3); 
    box-shadow: 0 0 8px rgba(0, 0, 0, 0.3), inset 0 0 8px rgba(255, 255, 255, 0.05); 
    z-index: 60;
    transition: all 0.3s ease;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    font-family: 'Orbitron', sans-serif;
    font-weight: 700;
    cursor: pointer;
}

/* Glow blue when paused */
#pauseBtn.paused { 
    background: rgba(100, 180, 255, 0.2); 
    border-color: #64b4ff; 
    color: #64b4ff; 
    text-shadow: 0 0 12px #64b4ff; 
    box-shadow: 0 0 25px rgba(100, 180, 255, 0.6), inset 0 0 15px rgba(100, 180, 255, 0.2); 
}

#pauseBtn:hover {
    transform: scale(1.05);
}

#pauseBtn:active {
    transform: scale(0.95);
}


        .hud-abilities{
            position: absolute;
            top: 135px;
            right: 20px;
            display: flex;
            gap: 10px;
            pointer-events: auto;
            z-index: 25;
        }
        
        /* Mobile fuel bar shown near ability buttons */
        .mobile-fuel-bar {
            display: none;
            width: 48px;
            height: 6px;
            background: #1a1a1a;
            border: 1px solid #ffcc00;
            border-radius: 3px;
            overflow: hidden;
        }
        .mobile-fuel-bar .fuel-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ffcc00, #ff6600);
            transition: width 0.2s;
        }
        .mobile-fuel-label {
            display: none;
            font-family: 'Orbitron', sans-serif;
            font-size: 6px;
            color: #ffcc00;
            text-align: center;
            letter-spacing: 1px;
            text-shadow: 0 0 6px #ffcc00;
        }
        
        /* On mobile, stack ability buttons vertically on right side well ABOVE pause button */
        @media (max-width: 768px) {
            .hud-abilities {
                position: fixed;
                top: auto;
                bottom: 145px;
                right: 12px;
                flex-direction: column-reverse;
                gap: 10px;
                padding: 0;
                margin: 0;
                align-items: center;
            }
            
            #flyBtn, #shieldBtn {
                position: relative !important;
                bottom: auto !important;
                right: auto !important;
                margin: 0 !important;
            }
            
            .mobile-fuel-bar, .mobile-fuel-label { display: block; }
            #mobileFuelWrap { display: block !important; }
        }
        
        /* keep abilities visually tied to HUD */

        /* Hide touch-only HUD buttons on desktop (mouse/keyboard aiming uses cursor) */
        body.notouch .touch-only { display: none !important; }
</style>
</head>
<body>
    <!-- Orientation recommendation for portrait mode -->
    <div id="orientationMsg">
        <div class="rotate-icon">üì± ‚Üí üîÑ</div>
        <h2>ROTATE YOUR DEVICE</h2>
        <p>For the best experience, please play in landscape mode</p>
    </div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <!-- Red bullseye cursor - just circle, no plus sign -->
        <div id="bullseye"></div>
        <button id="soundToggle">üîä SOUND ON</button>
        <div id="hud">
            <div class="hud-panel"><div class="hud-label">SCORE</div><div class="hud-value" id="scoreDisplay">0</div></div>
            <div class="hud-panel"><div class="hud-label">KILLS</div><div class="hud-value" id="killsDisplay">0</div></div>
            <div class="hud-panel" id="statusPanel"><div class="hud-label">SUIT INTEGRITY</div><div id="healthBar"><div id="healthFill" style="width: 100%"></div></div><div class="hud-label" style="margin-top: 10px">‚óÜ SPECIALTY FUEL ‚óÜ</div><div id="flyMeter"><div id="flyFill"></div></div></div>
        
</div>
            <div class="hud-abilities">
                <div id="flyBtn" class="mobile-btn ability touch-only">‚úà<br>FLY</div>
                <div id="mobileFuelWrap" class="touch-only" style="display:none; text-align:center;">
                    <div class="mobile-fuel-label">‚óÜ FUEL ‚óÜ</div>
                    <div class="mobile-fuel-bar"><div class="fuel-fill" id="mobileFuelFill"></div></div>
                </div>
                <div id="shieldBtn" class="mobile-btn ability touch-only">üõ°<br>SHIELD</div>
            </div>
        <div id="mobileControls">

  <div id="dpad" class="dpad">
    <div class="dpad-btn up" id="btnUp">‚ñ≤</div>
    <div class="dpad-btn left" id="btnLeft">‚óÄ</div>
    <div class="dpad-btn fire" id="btnFire">FIRE</div>
    <div class="dpad-btn right" id="btnRight">‚ñ∂</div>
    <div class="dpad-btn down" id="btnDown">‚ñº</div>
  </div>
</div>
</div>
<div id="pauseBtn" class="mobile-btn">‚è∏<br>PAUSE</div>
        <div id="easterEggHint">‚ö° CHARGE READY ‚Äî SPACE: FLY ‚Ä¢ SHIFT: SHIELD ‚ö°</div>
        <div id="waveAnnounce"></div>
        <div id="startScreen">
            <div class="title">MECH <span>WARS</span></div>
            <div class="subtitle">DISTANT MOON ‚Ä¢ ROBOT UPRISING</div>
            <div class="byline">Ramidus, Inc ‚Ä¢ A Casey T. Duncan Enterprise</div>
            <div class="instructions" id="desktopInstructions">
                <span>[MOUSE]</span> ‚Äî Aim gun<br>
                <span>[LEFT MOUSE BUTTON / F]</span> ‚Äî Shoot<br>
                <span>[WASD / ARROWS]</span> ‚Äî Move<br>
                <span>[‚Üê‚Üë ¬∑ ‚Üë‚Üë ¬∑ ‚Üë‚Üí]</span> ‚Äî Jump &nbsp; <span>[SPACE]</span> ‚Äî Jetpack &nbsp; <span>[SHIFT]</span> ‚Äî Shield<br>
                <span>[ESC / P]</span> ‚Äî Pause
            </div>
            <div class="instructions" id="mobileInstructions" style="display:none;">
                <span>[TAP SCREEN]</span> ‚Äî Aim gun<br>
                <span>[D-PAD]</span> ‚Äî Move &amp; Fire<br>
                <span>[‚Üê‚Üë ¬∑ ‚Üë‚Üë ¬∑ ‚Üë‚Üí]</span> ‚Äî Jump combo<br>
                <span>[FLY / SHIELD]</span> ‚Äî Abilities (when charged)
            </div>
            <button class="start-btn" id="startBtn" onclick="try{startGame();}catch(e){console.error(e);alert('Start error: ' + (e && e.message ? e.message : e));}">‚ñ∂ START</button>
        </div>
        <div id="gameOverScreen">
            <div class="title" style="font-size: clamp(30px, 8vw, 60px);">SUIT <span>DESTROYED</span></div>
            <div class="subtitle">‚óÜ MISSION FAILED ‚óÜ</div>
            <div id="finalScore">0</div>
            <div class="instructions">TARGETS ELIMINATED</div>
            <button class="start-btn" id="restartBtn" onclick="try{startGame();}catch(e){console.error(e);alert("Start error: "+e.message);}">‚Üª REDEPLOY</button>
        </div>
    </div>
    
    <div id="pauseOverlay" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.65); z-index:50; align-items:center; justify-content:center; flex-direction:column; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial; color:#d7fff1; text-align:center;">
        <div style="font-size:40px; font-weight:800; letter-spacing:2px;">PAUSED</div>
        <div style="margin-top:10px; font-size:14px; opacity:0.85;">Press <b>P</b>/<b>Esc</b> or tap <b>‚ñ∂ PLAY</b> to resume</div>
    </div>
<script>
const AudioSystem = {
    ctx: null, enabled: true,
    init() { try { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {} },
    resume() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); },
    
    playRocketLaunch() {
        if (!this.enabled || !this.ctx) return;
        // Firework spinning whistle sound
        const t = this.ctx.currentTime;
        
        // Main spinning whistle
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const lfo = this.ctx.createOscillator();
        const lfoGain = this.ctx.createGain();
        
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(800, t);
        osc.frequency.exponentialRampToValueAtTime(2000, t + 0.15);
        osc.frequency.exponentialRampToValueAtTime(400, t + 0.4);
        
        lfo.type = 'sine';
        lfo.frequency.setValueAtTime(30, t);
        lfo.frequency.linearRampToValueAtTime(80, t + 0.3);
        lfoGain.gain.setValueAtTime(200, t);
        lfoGain.gain.linearRampToValueAtTime(400, t + 0.2);
        
        gain.gain.setValueAtTime(0.2, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
        
        osc.start(t);
        lfo.start(t);
        osc.stop(t + 0.4);
        lfo.stop(t + 0.4);
        
        // Crackle/spark layer
        const bufferSize = this.ctx.sampleRate * 0.3;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 1.5) * (Math.random() > 0.7 ? 1 : 0.2);
        }
        const noise = this.ctx.createBufferSource();
        const noiseGain = this.ctx.createGain();
        const noiseFilter = this.ctx.createBiquadFilter();
        noise.buffer = buffer;
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(this.ctx.destination);
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.setValueAtTime(2000, t);
        noiseGain.gain.setValueAtTime(0.15, t);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
        noise.start(t);
    },
    
    playSpiderLaser() {
        if (!this.enabled || !this.ctx) return;
        const t = this.ctx.currentTime;
        
        // Deep ominous charge-up sound
        const bass = this.ctx.createOscillator();
        const bassGain = this.ctx.createGain();
        bass.connect(bassGain);
        bassGain.connect(this.ctx.destination);
        
        bass.type = 'sine';
        bass.frequency.setValueAtTime(40, t);
        bass.frequency.exponentialRampToValueAtTime(120, t + 0.3);
        bassGain.gain.setValueAtTime(0.3, t);
        bassGain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
        bass.start(t);
        bass.stop(t + 0.4);
        
        // Scary metallic screech
        const screech = this.ctx.createOscillator();
        const screechGain = this.ctx.createGain();
        screech.connect(screechGain);
        screechGain.connect(this.ctx.destination);
        
        screech.type = 'sawtooth';
        screech.frequency.setValueAtTime(800, t + 0.15);
        screech.frequency.exponentialRampToValueAtTime(2000, t + 0.25);
        screech.frequency.exponentialRampToValueAtTime(400, t + 0.4);
        screechGain.gain.setValueAtTime(0, t + 0.15);
        screechGain.gain.linearRampToValueAtTime(0.2, t + 0.2);
        screechGain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
        screech.start(t + 0.15);
        screech.stop(t + 0.4);
        
        // High-pitched energy whine
        const whine = this.ctx.createOscillator();
        const whineGain = this.ctx.createGain();
        whine.connect(whineGain);
        whineGain.connect(this.ctx.destination);
        
        whine.type = 'triangle';
        whine.frequency.setValueAtTime(1500, t);
        whine.frequency.linearRampToValueAtTime(3000, t + 0.3);
        whineGain.gain.setValueAtTime(0.15, t);
        whineGain.gain.exponentialRampToValueAtTime(0.01, t + 0.35);
        whine.start(t);
        whine.stop(t + 0.35);
    },

    playCrabCharge() {
        // Short "power-up" cue for the crab bot before it fires electricity
        if (!this.enabled || !this.ctx) return;
        const t = this.ctx.currentTime;

        // Rising buzz
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.ctx.destination);

        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(220, t);
        osc.frequency.exponentialRampToValueAtTime(1100, t + 0.45);

        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(600, t);
        filter.frequency.linearRampToValueAtTime(1200, t + 0.45);
        filter.Q.setValueAtTime(8, t);

        gain.gain.setValueAtTime(0.0, t);
        gain.gain.linearRampToValueAtTime(0.18, t + 0.08);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.55);

        osc.start(t);
        osc.stop(t + 0.6);

        // Tiny spark click at the front
        const clickOsc = this.ctx.createOscillator();
        const clickGain = this.ctx.createGain();
        clickOsc.connect(clickGain);
        clickGain.connect(this.ctx.destination);
        clickOsc.type = 'triangle';
        clickOsc.frequency.setValueAtTime(1800, t);
        clickGain.gain.setValueAtTime(0.10, t);
        clickGain.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
        clickOsc.start(t);
        clickOsc.stop(t + 0.06);
    },

    playSharkFire() {
        // Muffled underwater torpedo shot ‚Äî thud + bubble trail
        if (!this.enabled || !this.ctx) return;
        const t = this.ctx.currentTime;

        // Low thud
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.ctx.destination);
        osc.type = 'sine';
        osc.frequency.setValueAtTime(180, t);
        osc.frequency.exponentialRampToValueAtTime(60, t + 0.2);
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(400, t);
        filter.Q.setValueAtTime(2, t);
        gain.gain.setValueAtTime(0.25, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.25);
        osc.start(t);
        osc.stop(t + 0.3);

        // Bubble whistle overlay
        const bub = this.ctx.createOscillator();
        const bubGain = this.ctx.createGain();
        bub.connect(bubGain);
        bubGain.connect(this.ctx.destination);
        bub.type = 'triangle';
        bub.frequency.setValueAtTime(600, t + 0.02);
        bub.frequency.exponentialRampToValueAtTime(200, t + 0.18);
        bubGain.gain.setValueAtTime(0.08, t + 0.02);
        bubGain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
        bub.start(t + 0.02);
        bub.stop(t + 0.22);
    },

    playCrabFire() {
        // Electric zap/crack when lightning bolt releases
        if (!this.enabled || !this.ctx) return;
        const t = this.ctx.currentTime;

        // Sharp electric crack
        const bufSize = this.ctx.sampleRate * 0.15;
        const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < bufSize; i++) {
            const env = Math.pow(1 - i / bufSize, 3);
            data[i] = (Math.random() * 2 - 1) * env;
        }
        const noise = this.ctx.createBufferSource();
        const noiseGain = this.ctx.createGain();
        const hpf = this.ctx.createBiquadFilter();
        noise.buffer = buf;
        noise.connect(hpf);
        hpf.connect(noiseGain);
        noiseGain.connect(this.ctx.destination);
        hpf.type = 'highpass';
        hpf.frequency.setValueAtTime(2000, t);
        noiseGain.gain.setValueAtTime(0.3, t);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
        noise.start(t);

        // Bass thump underneath
        const bass = this.ctx.createOscillator();
        const bassGain = this.ctx.createGain();
        bass.connect(bassGain);
        bassGain.connect(this.ctx.destination);
        bass.type = 'sine';
        bass.frequency.setValueAtTime(120, t);
        bass.frequency.exponentialRampToValueAtTime(40, t + 0.12);
        bassGain.gain.setValueAtTime(0.22, t);
        bassGain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
        bass.start(t);
        bass.stop(t + 0.18);

        // Electric sizzle tail
        const sizzle = this.ctx.createOscillator();
        const sizGain = this.ctx.createGain();
        sizzle.connect(sizGain);
        sizGain.connect(this.ctx.destination);
        sizzle.type = 'sawtooth';
        sizzle.frequency.setValueAtTime(3000, t);
        sizzle.frequency.exponentialRampToValueAtTime(800, t + 0.2);
        sizGain.gain.setValueAtTime(0.06, t + 0.05);
        sizGain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
        sizzle.start(t + 0.05);
        sizzle.stop(t + 0.28);
    },

    playBarrelPickup() {
        // Satisfying power-up chime
        if (!this.enabled || !this.ctx) return;
        const t = this.ctx.currentTime;
        const notes = [523, 659, 784, 1047]; // C5 E5 G5 C6
        notes.forEach((freq, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(freq, t + i * 0.08);
            gain.gain.setValueAtTime(0.15, t + i * 0.08);
            gain.gain.exponentialRampToValueAtTime(0.01, t + i * 0.08 + 0.3);
            osc.start(t + i * 0.08);
            osc.stop(t + i * 0.08 + 0.35);
        });
    },

    playJump() {
        // Quick springy jump sound
        if (!this.enabled || !this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(200, t);
        osc.frequency.exponentialRampToValueAtTime(600, t + 0.12);
        osc.frequency.exponentialRampToValueAtTime(350, t + 0.2);
        gain.gain.setValueAtTime(0.15, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.22);
        osc.start(t);
        osc.stop(t + 0.25);
    },

    playExplosion(big = false) {
        if (!this.enabled || !this.ctx) return;
        const t = this.ctx.currentTime;
        const duration = big ? 0.8 : 0.4, volume = big ? 0.5 : 0.3;
        const bufferSize = this.ctx.sampleRate * duration, buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate), data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
        const noise = this.ctx.createBufferSource(), noiseGain = this.ctx.createGain(), filter = this.ctx.createBiquadFilter();
        noise.buffer = buffer; noise.connect(filter); filter.connect(noiseGain); noiseGain.connect(this.ctx.destination);
        filter.type = 'lowpass'; filter.frequency.setValueAtTime(big ? 800 : 1200, t); filter.frequency.exponentialRampToValueAtTime(100, t + duration);
        noiseGain.gain.setValueAtTime(volume, t); noiseGain.gain.exponentialRampToValueAtTime(0.01, t + duration);
        noise.start(t);
        const osc = this.ctx.createOscillator(), oscGain = this.ctx.createGain();
        osc.connect(oscGain); oscGain.connect(this.ctx.destination);
        osc.type = 'sine'; osc.frequency.setValueAtTime(big ? 60 : 100, t); osc.frequency.exponentialRampToValueAtTime(20, t + duration * 0.5);
        oscGain.gain.setValueAtTime(volume * 0.8, t); oscGain.gain.exponentialRampToValueAtTime(0.01, t + duration * 0.5);
        osc.start(t); osc.stop(t + duration * 0.5);
    },
    
    playRoar() {
        if (!this.enabled || !this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator(), osc2 = this.ctx.createOscillator(), gain = this.ctx.createGain(), filter = this.ctx.createBiquadFilter();
        osc.connect(filter); osc2.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
        osc.type = 'sawtooth'; osc2.type = 'triangle';
        osc.frequency.setValueAtTime(120, t); osc.frequency.exponentialRampToValueAtTime(60, t + 0.6);
        osc2.frequency.setValueAtTime(90, t); osc2.frequency.exponentialRampToValueAtTime(40, t + 0.6);
        filter.type = 'lowpass'; filter.frequency.setValueAtTime(400, t); filter.frequency.exponentialRampToValueAtTime(150, t + 0.5);
        gain.gain.setValueAtTime(0.4, t); gain.gain.linearRampToValueAtTime(0.5, t + 0.1); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.7);
        osc.start(t); osc2.start(t); osc.stop(t + 0.7); osc2.stop(t + 0.7);
    },
    
    playTRexRoar() {
        if (!this.enabled || !this.ctx) return;
        const t = this.ctx.currentTime;
        // Deeper, more menacing roar for T-Rex
        const osc = this.ctx.createOscillator(), osc2 = this.ctx.createOscillator(), osc3 = this.ctx.createOscillator();
        const gain = this.ctx.createGain(), filter = this.ctx.createBiquadFilter();
        osc.connect(filter); osc2.connect(filter); osc3.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
        osc.type = 'sawtooth'; osc2.type = 'triangle'; osc3.type = 'square';
        osc.frequency.setValueAtTime(80, t); osc.frequency.exponentialRampToValueAtTime(35, t + 0.9);
        osc2.frequency.setValueAtTime(60, t); osc2.frequency.exponentialRampToValueAtTime(25, t + 0.9);
        osc3.frequency.setValueAtTime(45, t); osc3.frequency.exponentialRampToValueAtTime(20, t + 0.8);
        filter.type = 'lowpass'; filter.frequency.setValueAtTime(300, t); filter.frequency.exponentialRampToValueAtTime(80, t + 0.7);
        gain.gain.setValueAtTime(0.5, t); gain.gain.linearRampToValueAtTime(0.6, t + 0.15); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.9);
        osc.start(t); osc2.start(t); osc3.start(t); osc.stop(t + 0.9); osc2.stop(t + 0.9); osc3.stop(t + 0.9);
    },
    
    playHit() {
        if (!this.enabled || !this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator(), gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.type = 'square'; osc.frequency.setValueAtTime(300, t); osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
        gain.gain.setValueAtTime(0.2, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        osc.start(t); osc.stop(t + 0.1);
    },
    
    playJetpack() {
        if (!this.enabled || !this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator(), osc2 = this.ctx.createOscillator(), gain = this.ctx.createGain();
        osc.connect(gain); osc2.connect(gain); gain.connect(this.ctx.destination);
        osc.type = 'sawtooth'; osc2.type = 'square';
        osc.frequency.setValueAtTime(80, t); osc.frequency.linearRampToValueAtTime(250, t + 0.4);
        osc2.frequency.setValueAtTime(120, t); osc2.frequency.linearRampToValueAtTime(350, t + 0.4);
        gain.gain.setValueAtTime(0.15, t); gain.gain.linearRampToValueAtTime(0.25, t + 0.2); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.8);
        osc.start(t); osc2.start(t); osc.stop(t + 0.8); osc2.stop(t + 0.8);
    },
    
    playDamage() {
        if (!this.enabled || !this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator(), gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, t); osc.frequency.exponentialRampToValueAtTime(50, t + 0.2);
        gain.gain.setValueAtTime(0.3, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
        osc.start(t); osc.stop(t + 0.2);
    }
};

const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');

// Fatal error overlay (prevents silent blank screen if a runtime error occurs)
let fatalError = null;


// Side-scroller camera
let camX = 0;
let autoScroll = 0; // (disabled) camera is player-follow for exploration // world px per ms (tweak)
// === CHARACTER SYSTEM ===
const CHARACTERS = [
    {
        id: 'ramidus', name: 'RAMIDUS 394', role: 'Assault Frame',
        trim: '#7CFF4A', trimRGB: '124,255,74', glowRGB: '0,255,204', glow2RGB: '0,170,255',
        helmet: 'standard'
    },
    {
        id: 'phantom', name: 'PHANTOM', role: 'Stealth Infiltrator',
        trim: '#4A9FFF', trimRGB: '74,159,255', glowRGB: '74,159,255', glow2RGB: '30,100,220',
        helmet: 'angular'
    },
    {
        id: 'spector', name: 'SPECTOR 9', role: 'Heavy Vanguard',
        trim: '#FF4A4A', trimRGB: '255,74,74', glowRGB: '255,80,60', glow2RGB: '200,40,30',
        helmet: 'heavy'
    },
    {
        id: 'terminus', name: 'TERMINUS', role: 'Tactical Operative',
        trim: '#FF69B4', trimRGB: '255,105,180', glowRGB: '255,130,200', glow2RGB: '200,60,140',
        helmet: 'sleek'
    }
];
let selectedCharIndex = 0;
function getChar() { return CHARACTERS[selectedCharIndex]; }

let gameRunning = false, score = 0, kills = 0, flyCharge = 0, wave = 1;
// Encounter-based spawning: enemies appear as you explore forward (no camping spawns)
let nextEncounterX = 650; // world x threshold to trigger the next group
let techPlatforms = [];   // floating platforms to jump on
let healthPickups = [];   // collectible health crates
let nextPlatformX = 1600;  // world x for next platform spawn
let jumpHintShown = false;

// === UNDERWATER ZONE SYSTEM ===

// Helper Y positions for the chemical pool (kept in one place so visuals + logic stay in sync)
function getWaterSurfaceY() { return canvas.height - 90; }  // visual surface line (keep original look)
function getPoolFloorY()   { return canvas.height - 60; }    // bottom of pool (corroded floor)
// Underwater "depth ceiling" (where the liquid visually begins while submerged).
// Outside (surface) view uses getWaterSurfaceY() and stays shallow-looking.
// When the player is underwater, we treat the chemical pool as much deeper so enemies can swim high.
function getUnderwaterTopY(){ return Math.max(80, canvas.height - 560); }
let isUnderwater = false;
let waterZoneUsed = false; // single special water occurrence
let underwaterZone = null; // { startX, endX } - world coords of current water zone
let nextWaterEdgeX = 5500; // chemical pool appears well into the run ‚Äî feels like a special event
let waterEnemies = []; // torpedo drones + crab walkers
let waterEncounterSpawned = false; // first wave has spawned
let waterEncounterCleared = false; // ALL waves done and all enemies dead
let waterWaveIndex = 0;           // which wave we're on (0-based)
let waterTotalSpawned = 0;        // total enemies spawned across all waves
let waterTotalKills = 0;          // total enemies killed in pool
const WATER_TOTAL_ENEMIES = 10;   // total enemies across the whole pool
// Waves spawn as player progresses ‚Äî small groups at a time
const WATER_WAVES = [
    { at: 0.05, torpedo: 1, crab: 1 },   // near entrance after grace period
    { at: 0.25, torpedo: 1, crab: 1 },   // quarter way in
    { at: 0.45, torpedo: 2, crab: 0 },   // middle
    { at: 0.60, torpedo: 1, crab: 1 },   // past middle  
    { at: 0.75, torpedo: 1, crab: 1 },   // approaching ramp
];
let waterEntryTime = 0; // timestamp when player first enters water
let waterBarrel = null; // { x, y, collected } ‚Äî power-up barrel in the pool
// WATER_ENCOUNTER_COUNTS removed ‚Äî waves defined in WATER_WAVES
let waterBubbles = []; // ambient bubbles
let waterTransitionAlpha = 0; // fade transition (0 = surface, 1 = underwater)
let waterZonePassed = false; // keep ONE water zone persistent; no repeats
const WATER_ZONE_LENGTH_MIN = 1500;
const WATER_ZONE_LENGTH_MAX = 2300;
const WATER_FUEL_RECHARGE = 8; // fuel per second while underwater

const FLY_CHARGE_MAX = 100, FLY_DURATION = 15000;
const SHIELD_DURATION = 15000, SHIELD_HITS = 4;
const LASER_TELEGRAPH_MS = 250; // Reduced for faster, more obvious attacks
const IFRAME_MS = 800;

const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
if (document.body) document.body.classList.add(isTouchDevice ? "touch" : "notouch");

// Set appropriate hint text based on device type
const hintEl = document.getElementById('easterEggHint');
if (hintEl) {
    if (isTouchDevice) {
        hintEl.textContent = '‚ö° CHARGE READY ‚Äî TAP BUTTONS TO USE ‚ö°';
    } else {
        hintEl.textContent = '‚ö° CHARGE READY ‚Äî SPACE: FLY ‚Ä¢ SHIFT: SHIELD ‚ö°';
    }
}

function resize() {
    const isSmallTouch = isTouchDevice && (window.innerWidth <= 820 || window.innerHeight <= 520);
    const r = isSmallTouch ? 1.35 : 1;
    canvas.width = Math.floor(window.innerWidth * r);
    canvas.height = Math.floor(window.innerHeight * r);
}
resize(); 
window.addEventListener('blur', () => { isMoving = false; isFiring = false; mobileMoveHeld = false; lastFireTime = -1e9; dpadState.up = false; dpadState.down = false; dpadState.left = false; dpadState.right = false; syncDpadVisuals && syncDpadVisuals(); });
document.addEventListener('visibilitychange', () => { if (document.hidden) { isMoving = false; isFiring = false; mobileMoveHeld = false; lastFireTime = -1e9; dpadState.up = false; dpadState.down = false; dpadState.left = false; dpadState.right = false; } });
window.addEventListener('resize', resize);

const player = { x: 0, y: 0, targetX: 0, targetY: 0, width: 50, height: 80, health: 100, maxHealth: 100, speed: 5.5, isFlying: false, flyEndTime: 0, legAngle: 0, legDir: 1, isMoving: false, facingRight: true, screenShake: 0, armAngle: 0, invulnUntil: 0, shieldUntil: 0, shieldHits: 0, isJumping: false, jumpVY: 0, jumpVX: 0 };
let rockets = [], enemies = [], enemyLasers = [], particles = [], sparks = [], smokeTrails = [], debris = [], spawnTimer = 0, spawnInterval = 2500, difficulty = 1;
// Pointer position (for reference) + separate aim reticle position (click-to-place)
let mouseX = 400, mouseY = 400;
let aimX = 400, aimY = 400;
let isMoving = false, isFiring = false, lastFireTime = -1e9;
let paused = false;
let mobileMoveHeld = false;
let lmbDownTime = 0, lmbDownX = 0, lmbDownY = 0;
const fireRate = 320;

// Detect mobile/touch device and show appropriate instructions

// Mobile phone plays better when the world is slightly zoomed out (more space on screen).
// Desktop stays exactly the same.
function getWorldScale() {
    if (isTouchDevice && (canvas.width <= 820 || canvas.height <= 520)) return 0.82;
    return 1;
}
function getWorldOffsetY(scale) {
    if (scale === 1) return 0;
    // Keep the ground/bottom aligned after scaling
    return canvas.height * (1/scale - 1);
}
function clientToCanvasX(x){ return x * (canvas.width / window.innerWidth); }
function clientToCanvasY(y){ return y * (canvas.height / window.innerHeight); }
function screenToWorld(x, y) {
    const s = getWorldScale();
    const oy = getWorldOffsetY(s);
    return { x: camX + x / s, y: (y / s) - oy };
}

if (isTouchDevice) {
    const desktopInst = document.getElementById('desktopInstructions');
    const mobileInst = document.getElementById('mobileInstructions');
    if (desktopInst) desktopInst.style.display = 'none';
    if (mobileInst) mobileInst.style.display = 'block';

    // Show ability buttons on touch devices (they stay dim until charged via updateAbilityButtons)
    const fb = document.getElementById('flyBtn');
    const sb = document.getElementById('shieldBtn');
    if (fb) fb.classList.remove('hidden');
    if (sb) sb.classList.remove('hidden');
}

// Unified fire helper (keyboard F + D-pad FIRE). Fires immediately when forced,
// otherwise respects fireRate in the main update loop.
function fireOneRocket(force=false) {
    if (!gameRunning || paused) return;
    const now = Date.now();
    if (!force && (now - lastFireTime) <= fireRate) return;

    // Fire from actual gun barrel with rotation
    const torsoW = player.width * 0.62;
    const torsoY = -player.height * 0.34;
    const shoulderX = torsoW/2 - 10;
    const shoulderY = torsoY + 18;
    const muzzleX = 132;  // Extended barrel tip
    const muzzleY = 0;   // Single barrel center
    
    // Use arm angle directly - sprite flip handles left/right orientation
    const clampedArmAngle = Math.max(-1.57, Math.min(1.57, player.armAngle));
    
    const rotatedMuzzleX = muzzleX * Math.cos(clampedArmAngle) - muzzleY * Math.sin(clampedArmAngle);
    const rotatedMuzzleY = muzzleX * Math.sin(clampedArmAngle) + muzzleY * Math.cos(clampedArmAngle);
    
    const gunLocalX = shoulderX + rotatedMuzzleX;
    const gunLocalY = shoulderY + rotatedMuzzleY;
    
    // Position accounting for facing direction
    const gunX = player.x + (player.facingRight ? gunLocalX : -gunLocalX);
    const gunY = player.y + gunLocalY;

    // Fire in the EXACT direction the gun is visually pointing
    // Use the gun's actual angle instead of aim position
    const fireDistance = 2000;
    let targetX, targetY;

    // Robust: keep projectile direction aligned with the visually flipped gun.
    // When facing left, the sprite is mirrored, so we flip the angle across PI.
    const angle = player.facingRight ? clampedArmAngle : (Math.PI - clampedArmAngle);
    targetX = gunX + Math.cos(angle) * fireDistance;
    targetY = gunY + Math.sin(angle) * fireDistance;

    fireRocket(gunX, gunY, targetX, targetY);
    lastFireTime = now;
}


function initPlayer() { 
    // Spawn player further right on mobile so D-pad doesn't block view
    const spawnOffset = canvas.width < 600 ? 0.38 : 0.25;
    player.x = camX + canvas.width * spawnOffset; 
    player.y = canvas.height - 180;  // Raised to match ground at -120
    player.targetX = player.x; 
    player.targetY = player.y; 
    player.health = player.maxHealth; 
    player.isFlying = false; 
    player.screenShake = 0;
    player.isJumping = false;
    player.jumpVY = 0;
    player.jumpVX = 0;
    player._onPlatform = null;
    nextEncounterX = player.x + 650;
    
    // Initialize position tracking for jump prevention
    window.lastValidPlayerX = player.x;
    
    // Initialize aim reticle in front of player
    mouseX = canvas.width * 0.65;
    mouseY = canvas.height - 180;
    aimX = mouseX;
    aimY = mouseY;
    // Update bullseye element position
    const bullseyeEl = document.getElementById('bullseye');
    if (bullseyeEl) {
        bullseyeEl.style.left = aimX + 'px';
        bullseyeEl.style.top = aimY + 'px';
    }
}


function drawLaserScope(x, y) {
    // Neon green laser scope reticle (matches player glow)
    const c = '#7CFF4A';
    ctx.save();
    ctx.strokeStyle = c;
    ctx.lineWidth = 2;
    ctx.shadowColor = c;
    ctx.shadowBlur = 18;

    const r = 16;
    const gap = 6;

    // outer ring
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.stroke();

    // inner dot
    ctx.fillStyle = c;
    ctx.globalAlpha = 0.85;
    ctx.beginPath();
    ctx.arc(x, y, 2.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // ticks
    ctx.beginPath();
    ctx.moveTo(x - r - 8, y); ctx.lineTo(x - gap, y);
    ctx.moveTo(x + gap, y); ctx.lineTo(x + r + 8, y);
    ctx.moveTo(x, y - r - 8); ctx.lineTo(x, y - gap);
    ctx.moveTo(x, y + gap); ctx.lineTo(x, y + r + 8);
    ctx.stroke();

    // subtle scan shimmer
    ctx.globalAlpha = 0.22;
    ctx.beginPath();
    ctx.arc(x, y, r + 7, 0, Math.PI * 2);
    ctx.stroke();

    ctx.restore();
}



function drawMoveArrowHint() {
    // Screen-space guidance arrow (after clearing the local area)
    const t = Date.now() * 0.006;
    const pulse = 0.55 + Math.sin(t) * 0.25;
    const x = canvas.width - 90 + Math.sin(t) * 8;
    const y = canvas.height * 0.52;

    ctx.save();
    ctx.globalAlpha = pulse;
    ctx.shadowColor = 'rgba(0, 255, 204, 0.98)';
    ctx.shadowBlur = 18;

    // Arrow body
    ctx.strokeStyle = 'rgba(0,255,204,0.92)';
    ctx.lineWidth = 6;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(x - 40, y);
    ctx.lineTo(x + 26, y);
    ctx.stroke();

    // Arrow head
    ctx.beginPath();
    ctx.moveTo(x + 26, y);
    ctx.lineTo(x + 6, y - 16);
    ctx.moveTo(x + 26, y);
    ctx.lineTo(x + 6, y + 16);
    ctx.stroke();

    // Text
    ctx.shadowBlur = 0;
    ctx.globalAlpha = Math.min(1, pulse + 0.15);
    ctx.fillStyle = 'rgba(0,255,204,0.95)';
    ctx.font = 'bold 16px Orbitron, sans-serif';
    ctx.fillText('MOVE ‚Üí', x - 60, y - 26);

    ctx.restore();
}


function drawAimLine() {
    // Removed - bullseye is the only aiming indicator
    // Gun rotation shows where player is aiming
}


// Power Armor Soldier

// Heavy Combat Mech (inspired by chunky 80s/90s practical sci‚Äëfi, without copying any one design)
function drawPlayer(x, y, width, height, legAngle, isFlying, facingRight, armAngle) {
    ctx.save();
    ctx.translate(x, y);
    if (!facingRight) ctx.scale(-1, 1);

    // Player silhouette: more humanoid (armored suit), less bulky mech
    const s = 0.98;
    ctx.scale(s, s);

    const ch = getChar();
    const steelDark = '#0b111a';
    const steelMid  = '#223246';
    const steelLite = '#4e6a86';
    const trim      = ch.trim;
    // Bold center glow to match character's color
    ctx.shadowColor = `rgba(${ch.trimRGB}, 0.95)`;
    ctx.shadowBlur = 28;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    const visorGold = '#ffcc40';
    const warn      = '#ffcc00';
    const isFemFrame = (ch.id === 'terminus');

    // Hover shadow
    if (!isFlying) {
        ctx.fillStyle = 'rgba(0,0,0,0.45)';
        ctx.beginPath();
        ctx.ellipse(0, height * 0.55, width * 0.65, 12, 0, 0, Math.PI * 2);
        ctx.fill();
    } else {
        // Jet wash glow
        ctx.save();
        ctx.globalAlpha = 0.35;
        const g = ctx.createRadialGradient(0, height*0.55, 0, 0, height*0.55, 110);
        g.addColorStop(0, `rgba(${ch.glowRGB},0.18)`);
        g.addColorStop(0.4, `rgba(${ch.glow2RGB},0.12)`);
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(0, height*0.55, 110, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    }

    // Steel gradient helper function
    function steelGrad(x0,x1) {
        const g = ctx.createLinearGradient(x0,0,x1,0);
        g.addColorStop(0, steelDark);
        g.addColorStop(0.35, steelMid);
        g.addColorStop(0.7, steelLite);
        g.addColorStop(1, steelDark);
        return g;
    }

    // ===== Legs (hydraulic, chunky) - Only visible when not flying =====
    if (!isFlying) {
        const hipY = height * 0.05;
        const legSpan = width * 0.19;
        const upperH = height * 0.33;
        const lowerH = height * 0.35;
        const legW = isFemFrame ? 18 : 28;     // much slimmer legs
        const legR = isFemFrame ? -9 : -14;     // offset for slim
        const shinW = isFemFrame ? 16 : 24;
        const shinR = isFemFrame ? -8 : -12;
        const footW = isFemFrame ? 26 : 36;
        const footR = isFemFrame ? -13 : -18;

        for (let side = -1; side <= 1; side += 2) {
            ctx.save();
            ctx.translate(side * legSpan, hipY);
            ctx.rotate(legAngle * side * 0.35);

            // Upper leg block
            ctx.fillStyle = steelGrad(-18, 18);
            ctx.beginPath();
            ctx.roundRect(legR, -6, legW, upperH, 6);
            ctx.fill();

            // Pistons
            ctx.strokeStyle = 'rgba(200,220,255,0.22)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-10, 8);
            ctx.lineTo(-16, upperH - 10);
            ctx.moveTo(10, 8);
            ctx.lineTo(16, upperH - 10);
            ctx.stroke();

            // Knee joint
            ctx.fillStyle = steelLite;
            ctx.beginPath();
            ctx.arc(0, upperH + 2, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.save();
            ctx.shadowColor = trim; ctx.shadowBlur = 14;
            ctx.fillStyle = `rgba(${ch.glowRGB},0.75)`;
            ctx.beginPath();
            ctx.arc(0, upperH + 2, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Lower leg
            ctx.fillStyle = steelGrad(-16, 16);
            ctx.beginPath();
            ctx.roundRect(shinR, upperH, shinW, lowerH, 6);
            ctx.fill();

            // Shin plate
            ctx.fillStyle = 'rgba(255,255,255,0.06)';
            ctx.beginPath();
            ctx.roundRect(shinR + 2, upperH + 10, shinW - 4, lowerH - 18, 6);
            ctx.fill();

        // Foot
        ctx.fillStyle = steelDark;
        ctx.beginPath();
        ctx.roundRect(footR, upperH + lowerH - 2, footW, 12, 6);
        ctx.fill();
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        ctx.beginPath();
        ctx.roundRect(footR - 2, upperH + lowerH + 2, footW + 4, 8, 6);
        ctx.fill();

        ctx.restore();
        }
    } // End of if (!isFlying) for legs

    // ===== Torso (chunky mech chest + reactor) =====
    const torsoW = isFemFrame ? width * 0.56 : width * 0.62;
    const torsoH = height * 0.40;
    const torsoY = -height * 0.34;

    // Backpack / thruster stack
    const bpW = isFemFrame ? 38 : 44;
    ctx.fillStyle = steelGrad(-22, 22);
    ctx.beginPath();
    ctx.roundRect(-bpW/2, torsoY + 10, bpW, torsoH + 28, 10);
    ctx.fill();
    ctx.fillStyle = steelDark;
    ctx.beginPath();
    ctx.roundRect(-18, torsoY + torsoH + 22, 14, 14, 5);
    ctx.roundRect(4, torsoY + torsoH + 22, 14, 14, 5);
    ctx.fill();

    if (isFlying) {
        for (let i=0;i<2;i++){
            const fx = (i===0?-11:11);
            const flameH = 38 + Math.random()*22;
            const grad = ctx.createLinearGradient(fx, torsoY + torsoH + 36, fx, torsoY + torsoH + 36 + flameH);
            grad.addColorStop(0, 'rgba(255,255,255,0.95)');      // White hot core
            grad.addColorStop(0.2, 'rgba(255,220,100,0.85)');     // Bright gold
            grad.addColorStop(0.5, 'rgba(255,180,60,0.6)');       // Deep gold
            grad.addColorStop(0.8, 'rgba(255,140,30,0.3)');       // Orange-gold
            grad.addColorStop(1, 'rgba(0,0,0,0)');                // Fade to transparent
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(fx - 10, torsoY + torsoH + 36);
            ctx.quadraticCurveTo(fx - 6, torsoY + torsoH + 36 + flameH*0.6, fx, torsoY + torsoH + 36 + flameH);
            ctx.quadraticCurveTo(fx + 6, torsoY + torsoH + 36 + flameH*0.6, fx + 10, torsoY + torsoH + 36);
            ctx.closePath();
            ctx.fill();
        }
    }

    // Main chest block
    const chestGrad = ctx.createLinearGradient(-torsoW/2, torsoY, torsoW/2, torsoY);
    chestGrad.addColorStop(0, steelDark);
    chestGrad.addColorStop(0.35, steelMid);
    chestGrad.addColorStop(0.7, steelLite);
    chestGrad.addColorStop(1, steelDark);
    ctx.fillStyle = chestGrad;

    if (isFemFrame) {
        // Dramatic feminine silhouette ‚Äî very visible hourglass even at small scale
        const sw = torsoW * 0.56;   // shoulder half-width
        const ww = torsoW * 0.22;   // waist half-width (VERY narrow)
        const hw = torsoW * 0.58;   // hip half-width (wider than shoulders)
        const tTop = torsoY;
        const tMid = torsoY + torsoH * 0.52;  // waist line
        const tBot = torsoY + torsoH;

        // Draw as one continuous hourglass path
        ctx.beginPath();
        // Top edge (shoulders)
        ctx.moveTo(-sw + 4, tTop);
        ctx.lineTo(sw - 4, tTop);
        ctx.quadraticCurveTo(sw + 2, tTop, sw + 2, tTop + 6);
        // Right side: shoulder ‚Üí waist pinch ‚Üí hip flare
        ctx.lineTo(sw, tTop + torsoH * 0.25);
        ctx.quadraticCurveTo(ww + 6, tMid - 3, ww, tMid);       // pinch inward to waist
        ctx.quadraticCurveTo(ww + 6, tMid + 6, hw + 2, tBot - 6); // flare out to hip
        ctx.quadraticCurveTo(hw + 2, tBot, hw - 2, tBot);
        // Bottom edge
        ctx.lineTo(-hw + 2, tBot);
        // Left side: hip ‚Üí waist ‚Üí shoulder
        ctx.quadraticCurveTo(-hw - 2, tBot, -hw - 2, tBot - 6);
        ctx.quadraticCurveTo(-ww - 6, tMid + 6, -ww, tMid);     // hip to waist
        ctx.quadraticCurveTo(-ww - 6, tMid - 3, -sw, tTop + torsoH * 0.25); // waist to shoulder
        ctx.lineTo(-sw - 2, tTop + 6);
        ctx.quadraticCurveTo(-sw - 2, tTop, -sw + 4, tTop);
        ctx.closePath();
        ctx.fill();

        // Waist belt/accent (bright, visible even small)
        ctx.strokeStyle = `rgba(${ch.trimRGB}, 0.5)`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-ww - 3, tMid);
        ctx.quadraticCurveTo(0, tMid + 2, ww + 3, tMid);
        ctx.stroke();

        // Upper chest contour shading (subtle shape)
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        ctx.beginPath();
        ctx.ellipse(-torsoW * 0.16, tTop + torsoH * 0.26, torsoW * 0.16, torsoH * 0.12, -0.15, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(torsoW * 0.16, tTop + torsoH * 0.26, torsoW * 0.16, torsoH * 0.12, 0.15, 0, Math.PI * 2);
        ctx.fill();

        // Under-chest shadow line
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-sw * 0.6, tTop + torsoH * 0.38);
        ctx.quadraticCurveTo(0, tTop + torsoH * 0.42, sw * 0.6, tTop + torsoH * 0.38);
        ctx.stroke();
    } else {
        // Standard boxy mech torso
        ctx.beginPath();
        ctx.roundRect(-torsoW/2, torsoY, torsoW, torsoH, 14);
        ctx.fill();
    }

    // Chest plating panels
    ctx.fillStyle = 'rgba(255,255,255,0.05)';
    if (!isFemFrame) {
        ctx.beginPath();
        ctx.roundRect(-torsoW*0.42, torsoY + 10, torsoW*0.36, torsoH*0.70, 12);
        ctx.roundRect(torsoW*0.06, torsoY + 10, torsoW*0.36, torsoH*0.70, 12);
        ctx.fill();
    }

    // Reactor core
    ctx.save();
    ctx.shadowColor = trim; ctx.shadowBlur = 26;
    const core = ctx.createRadialGradient(0, torsoY + torsoH*0.55, 0, 0, torsoY + torsoH*0.55, 36);
    core.addColorStop(0, `rgba(${ch.glowRGB},0.85)`);
    core.addColorStop(0.4, `rgba(${ch.glow2RGB},0.35)`);
    core.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = core;
    ctx.beginPath();
    ctx.arc(0, torsoY + torsoH*0.55, 36, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = 'rgba(10,16,24,0.9)';
    ctx.beginPath();
    ctx.arc(0, torsoY + torsoH*0.55, 16, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = `rgba(${ch.glowRGB},0.75)`;
    ctx.beginPath();
    ctx.arc(0, torsoY + torsoH*0.55, 6, 0, Math.PI*2);
    ctx.fill();

    // ===== Head / Helmet (character-specific) =====
    const headY = torsoY - 18;

    if (ch.helmet === 'angular') {
        // PHANTOM ‚Äî angular stealth helmet with swept-back fins
        ctx.fillStyle = steelGrad(-18,18);
        ctx.beginPath();
        ctx.moveTo(-16, headY + 26); ctx.lineTo(-20, headY + 8);
        ctx.lineTo(-16, headY - 2); ctx.lineTo(0, headY - 6);
        ctx.lineTo(16, headY - 2); ctx.lineTo(20, headY + 8);
        ctx.lineTo(16, headY + 26);
        ctx.closePath(); ctx.fill();
        // Swept-back fins
        ctx.fillStyle = steelDark;
        ctx.beginPath();
        ctx.moveTo(-16, headY); ctx.lineTo(-26, headY - 10);
        ctx.lineTo(-18, headY + 6); ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(16, headY); ctx.lineTo(26, headY - 10);
        ctx.lineTo(18, headY + 6); ctx.closePath(); ctx.fill();
        // Edge highlight
        ctx.strokeStyle = `rgba(${ch.trimRGB}, 0.25)`;
        ctx.lineWidth = 0.8;
        ctx.beginPath(); ctx.moveTo(-16, headY - 2); ctx.lineTo(0, headY - 6); ctx.lineTo(16, headY - 2); ctx.stroke();
    } else if (ch.helmet === 'heavy') {
        // SPECTOR 9 ‚Äî heavy armored helmet with jaw guard
        ctx.fillStyle = steelGrad(-20,20);
        ctx.beginPath();
        ctx.roundRect(-20, headY - 2, 40, 28, 6);
        ctx.fill();
        // Brow ridge (heavy overhang)
        ctx.fillStyle = steelDark;
        ctx.beginPath();
        ctx.roundRect(-22, headY - 2, 44, 10, [6,6,0,0]);
        ctx.fill();
        // Jaw guard plates
        ctx.fillStyle = steelMid;
        ctx.beginPath();
        ctx.moveTo(-20, headY + 18); ctx.lineTo(-24, headY + 28);
        ctx.lineTo(-14, headY + 26); ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(20, headY + 18); ctx.lineTo(24, headY + 28);
        ctx.lineTo(14, headY + 26); ctx.closePath(); ctx.fill();
        // Chin vent slits
        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
        ctx.lineWidth = 1;
        for (let i = -1; i <= 1; i++) {
            ctx.beginPath(); ctx.moveTo(i * 5 - 2, headY + 22); ctx.lineTo(i * 5 + 2, headY + 25); ctx.stroke();
        }
    } else if (ch.helmet === 'sleek') {
        // TERMINUS ‚Äî sleek contoured helmet
        ctx.fillStyle = steelGrad(-18,18);
        ctx.beginPath();
        ctx.moveTo(-14, headY + 26); ctx.lineTo(-18, headY + 12);
        ctx.lineTo(-16, headY); ctx.lineTo(-8, headY - 4);
        ctx.lineTo(8, headY - 4); ctx.lineTo(16, headY);
        ctx.lineTo(18, headY + 12); ctx.lineTo(14, headY + 26);
        ctx.closePath(); ctx.fill();
        // Cheek contour lines
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 0.8;
        ctx.beginPath(); ctx.moveTo(-14, headY + 8); ctx.lineTo(-8, headY + 20); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(14, headY + 8); ctx.lineTo(8, headY + 20); ctx.stroke();

        // Ponytail (hair flowing from back of helmet)
        if (ch.hair) {
            ctx.save();
            const hairBase = headY + 4;
            const t = Date.now() * 0.003;
            const sway = Math.sin(t) * 3 + (isFlying ? Math.sin(t * 2.5) * 5 : 0);
            // Hair tie point at back of helmet
            ctx.fillStyle = '#1a1020';
            ctx.beginPath(); ctx.arc(-1, hairBase, 4, 0, Math.PI * 2); ctx.fill();
            // Flowing ponytail strands
            ctx.strokeStyle = '#2a1828';
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-1, hairBase + 2);
            ctx.quadraticCurveTo(-2 + sway * 0.5, hairBase + 22, -3 + sway, hairBase + 42);
            ctx.stroke();
            ctx.strokeStyle = '#3a2038';
            ctx.lineWidth = 3.5;
            ctx.beginPath();
            ctx.moveTo(0, hairBase + 2);
            ctx.quadraticCurveTo(-1 + sway * 0.6, hairBase + 20, -2 + sway * 1.1, hairBase + 40);
            ctx.stroke();
            // Highlight strand
            ctx.strokeStyle = `rgba(${ch.trimRGB}, 0.12)`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(1, hairBase + 3);
            ctx.quadraticCurveTo(0 + sway * 0.4, hairBase + 18, -1 + sway * 0.9, hairBase + 36);
            ctx.stroke();
            ctx.restore();
        }
    } else {
        // RAMIDUS 394 ‚Äî standard helmet (original)
        ctx.fillStyle = steelGrad(-18,18);
        ctx.beginPath();
        ctx.roundRect(-18, headY, 36, 26, 8);
        ctx.fill();
    }

    // Visor slit ‚Äî drawn after arms below to prevent cannon overlap


    // ===== Arms / Weapons =====
    // Right arm: cannon shroud that tracks the cursor (armAngle)
    const shoulderY = torsoY + 18;
    const shoulderX = torsoW/2 - 10;

    // Shoulder joint
    ctx.fillStyle = steelLite;
    ctx.beginPath();
    ctx.arc(shoulderX, shoulderY, 10, 0, Math.PI*2);
    ctx.fill();

    // Cannon arm
    ctx.save();
    ctx.translate(shoulderX, shoulderY);
    const aim = Math.max(-1.57, Math.min(1.57, armAngle));
    ctx.rotate(aim);

    // Upper arm
    ctx.fillStyle = steelGrad(-10, 18);
    ctx.beginPath();
    ctx.roundRect(0, -7, 28, 14, 7);
    ctx.fill();

    // Forearm shroud - extended for longer barrel
    ctx.fillStyle = steelGrad(0, 56);
    ctx.beginPath();
    ctx.roundRect(18, -10, 60, 20, 8);  // Extended from 48 to 60
    ctx.fill();

    // Single cannon barrel - centered
    ctx.fillStyle = '#0a0f18';
    ctx.beginPath();
    ctx.roundRect(70, -5, 62, 10, 4);
    ctx.fill();
    
    // Barrel accent rings for style
    ctx.fillStyle = steelMid;
    ctx.fillRect(85, -5, 2, 10);
    ctx.fillRect(110, -5, 2, 10);

    // Ammo cable
    ctx.strokeStyle = 'rgba(140,170,255,0.22)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(18, 7);
    ctx.quadraticCurveTo(10, 18, -12, 22);
    ctx.stroke();

    ctx.restore();

    // Left shoulder: missile pod (visual only ‚Äî rockets still fire from armX/armY logic)
    const podX = -torsoW/2 + 12;
    const podY = torsoY + 10;
    ctx.fillStyle = steelGrad(podX-10, podX+40);
    ctx.beginPath();
    ctx.roundRect(podX, podY, 48, 26, 10);
    ctx.fill();
    ctx.fillStyle = '#0a0f18';
    for (let i=0;i<3;i++){
        ctx.beginPath();
        ctx.arc(podX + 12 + i*12, podY + 13, 5.4, 0, Math.PI*2);
        ctx.fill();
    }
    ctx.save();
    ctx.shadowColor = warn; ctx.shadowBlur = 12;
    ctx.fillStyle = 'rgba(255,204,0,0.55)';
    ctx.beginPath();
    ctx.arc(podX + 44, podY + 6, 2.4, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Outline pass for crispness
    ctx.strokeStyle = 'rgba(220,235,255,0.10)';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(-torsoW/2, torsoY, torsoW, torsoH);

    // Visor slit ‚Äî drawn AFTER arms so cannon barrel never covers it
    // Full visor glow with directional light cone following gun aim
    ctx.save();
    
    // Main visor slit ‚Äî bright gold bar (always horizontal on face)
    ctx.shadowColor = isUnderwater ? 'rgba(255, 210, 80, 1)' : 'rgba(255, 204, 64, 0.95)';
    ctx.shadowBlur = isUnderwater ? 40 : 25;
    ctx.fillStyle = isUnderwater ? 'rgba(255, 210, 80, 0.95)' : 'rgba(255, 204, 64, 0.85)';
    ctx.beginPath();
    ctx.roundRect(-12, headY + 8, 24, 6, 2);
    ctx.fill();
    
    // Bright center highlight
    ctx.shadowBlur = isUnderwater ? 50 : 35;
    ctx.fillStyle = 'rgba(255, 240, 180, 0.6)';
    ctx.beginPath();
    ctx.roundRect(-8, headY + 9, 16, 4, 2);
    ctx.fill();
    ctx.restore();
    
    // Directional light cone ‚Äî follows arm/gun angle, projects from visor center
    {
        const visorCY = headY + 11;
        const aim = Math.max(-1.2, Math.min(1.2, armAngle));
        // Beam direction: right side of face when facingRight (but we're in flipped coords if !facingRight)
        // Since ctx is already flipped for !facingRight, beam always goes +X direction with aim rotation
        const beamLen = isUnderwater ? 420 : 200;
        const beamSpread = isUnderwater ? 75 : 40;
        const outerAlpha = isUnderwater ? 0.45 : 0.15;
        const innerAlpha = isUnderwater ? 0.50 : 0.12;
        
        ctx.save();
        if (isUnderwater) ctx.globalCompositeOperation = 'screen';
        ctx.translate(0, visorCY);
        ctx.rotate(aim); // follow gun aim directly
        
        // Outer cone
        const g1 = ctx.createLinearGradient(0, 0, beamLen, 0);
        g1.addColorStop(0, `rgba(255, 210, 95, ${outerAlpha})`);
        g1.addColorStop(0.15, `rgba(255, 200, 80, ${outerAlpha * 0.55})`);
        g1.addColorStop(0.5, `rgba(255, 180, 60, ${outerAlpha * 0.15})`);
        g1.addColorStop(1, 'rgba(200, 150, 40, 0)');
        ctx.fillStyle = g1;
        ctx.beginPath();
        ctx.moveTo(0, -3);
        ctx.lineTo(0, 3);
        ctx.lineTo(beamLen, beamSpread);
        ctx.lineTo(beamLen, -beamSpread);
        ctx.closePath();
        ctx.fill();
        
        // Inner hotspot
        const g2 = ctx.createLinearGradient(0, 0, beamLen * 0.55, 0);
        g2.addColorStop(0, `rgba(255, 235, 150, ${innerAlpha})`);
        g2.addColorStop(0.12, `rgba(255, 225, 130, ${innerAlpha * 0.45})`);
        g2.addColorStop(0.5, `rgba(255, 210, 100, ${innerAlpha * 0.1})`);
        g2.addColorStop(1, 'rgba(255, 200, 80, 0)');
        ctx.fillStyle = g2;
        ctx.beginPath();
        ctx.moveTo(0, -1.5);
        ctx.lineTo(0, 1.5);
        ctx.lineTo(beamLen * 0.55, beamSpread * 0.3);
        ctx.lineTo(beamLen * 0.55, -beamSpread * 0.3);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
        if (isUnderwater) ctx.globalCompositeOperation = 'source-over';
    }

    // === ELECTRICITY EFFECT (more frequent arcs around the suit) ===
    // Use time-based randomness
    const elecTime = Date.now();
    const elecChance = Math.sin(elecTime * 0.002) * Math.cos(elecTime * 0.001);
    
    if (elecChance > 0.3 && Math.random() < 0.25) { // More frequent
        ctx.save();
        ctx.strokeStyle = '#00ffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 20;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.8 + Math.random() * 0.2;
        
        // Draw 1-2 electric arcs
        const numArcs = 1 + Math.floor(Math.random() * 2);
        for (let a = 0; a < numArcs; a++) {
            // Random start point on body
            const startX = (Math.random() - 0.5) * width * 1.2;
            const startY = torsoY + Math.random() * torsoH;
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            
            // Jagged lightning path
            let px = startX, py = startY;
            const segments = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < segments; i++) {
                const nx = px + (Math.random() - 0.5) * 20;
                const ny = py + (Math.random() - 0.5) * 25;
                ctx.lineTo(nx, ny);
                px = nx; py = ny;
            }
            ctx.stroke();
            
            // Small spark at end
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(px, py, 2 + Math.random() * 2, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
    
    // Occasional big discharge (more frequent)
    if (elecChance > 0.6 && Math.random() < 0.12) {
        ctx.save();
        ctx.strokeStyle = '#ffff00';
        ctx.shadowColor = '#ffff00';
        ctx.shadowBlur = 25;
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.9;
        
        // Big arc from one side to another
        ctx.beginPath();
        ctx.moveTo(-width * 0.6, torsoY + torsoH * 0.3);
        let px = -width * 0.6, py = torsoY + torsoH * 0.3;
        for (let i = 0; i < 8; i++) {
            px += width * 0.15;
            py += (Math.random() - 0.5) * 20;
            ctx.lineTo(px, py);
        }
        ctx.stroke();
        ctx.restore();
    }

    
    // Underwater visor bloom handled by unified beam above

ctx.restore();
}


function drawTRex(x, y, width, height, legAngle, facingRight, health, maxHealth, isCharging) {
    ctx.save();
    ctx.translate(x, y);
    if (!facingRight) ctx.scale(-1, 1);

    const scale = 1.06;
    ctx.scale(scale, scale);

    // === Mech-Rex palette (back to the previous look) ===
    const steel = '#667489';
    const steelDark = '#222b36';
    const steelMid = '#3e4c5e';
    const edge = 'rgba(220,240,255,0.16)';
    const bolt = '#0d121b';
    const glow = isCharging ? 'rgba(255,55,55,0.95)' : 'rgba(255,190,0,0.85)';

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.42)';
    ctx.beginPath();
    ctx.ellipse(0, height * 0.35, width * 0.62, 12, 0, 0, Math.PI * 2);
    ctx.fill();

    const steelGrad = (x0, x1) => {
        const g = ctx.createLinearGradient(x0, 0, x1, 0);
        g.addColorStop(0, steelDark);
        g.addColorStop(0.45, steel);
        g.addColorStop(1, steelMid);
        return g;
    };

    // === Segmented tail (kept) ===
    const wag = Math.sin(legAngle * 2) * 0.18;
    const tailBaseX = -width * 0.22, tailBaseY = -height * 0.02;
    const segCount = 7;
    for (let i = 0; i < segCount; i++) {
        const t = i / (segCount - 1);
        const segW = width * (0.22 - t * 0.14);
        const segH = height * (0.11 - t * 0.065);
        const bend = wag * (0.55 + t * 1.2);
        const px = tailBaseX - width * (0.18 + i * 0.18) + Math.cos(t * 2.2) * 4;
        const py = tailBaseY + Math.sin(t * 2.4 + wag) * (6 + i * 2);

        ctx.save();
        ctx.translate(px, py);
        ctx.rotate(-0.12 - t * 0.28 + bend);

        ctx.shadowColor = glow;
        ctx.shadowBlur = 10;

        ctx.fillStyle = steelGrad(-segW, segW);
        ctx.beginPath();
        ctx.roundRect(-segW * 0.5, -segH * 0.5, segW, segH, Math.max(3, segH * 0.4));
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.strokeStyle = edge;
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(-segW * 0.42, -segH * 0.10);
        ctx.lineTo(segW * 0.42, -segH * 0.10);
        ctx.stroke();

        ctx.fillStyle = steelDark;
        ctx.beginPath();
        ctx.arc(-segW * 0.52, 0, Math.max(3, segH * 0.34), 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = bolt;
        for (let b = 0; b < 2; b++) {
            ctx.beginPath();
            ctx.arc(segW * (0.15 + b * 0.22), -segH * 0.12, 1.7, 0, Math.PI * 2);
            ctx.arc(segW * (0.15 + b * 0.22),  segH * 0.12, 1.7, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }

    // Tail tip spike
    ctx.save();
    ctx.translate(tailBaseX - width * 1.42, tailBaseY + Math.sin(wag) * 10);
    ctx.rotate(-0.55 + wag * 0.6);
    ctx.fillStyle = steelDark;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-18, 5);
    ctx.lineTo(-16, -5);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // === Body that reads as a T-Rex (less "squished") ===
    // Under-body haunch silhouette to give the classic rex shape
    const haunchW = width * 0.70;
    const haunchH = height * 0.48;
    ctx.shadowColor = glow;
    ctx.shadowBlur = 16;
    ctx.fillStyle = 'rgba(10,12,16,0.28)';
    ctx.beginPath();
    ctx.ellipse(-width*0.06, -height*0.04, haunchW*0.55, haunchH*0.52, 0.06, 0, Math.PI*2);
    ctx.fill();

    // Main torso plate (wider + taller so it doesn't look compressed)
    const torsoW = width * 0.72;
    const torsoH = height * 0.48;
    const torsoY = -height * 0.16;

    ctx.fillStyle = steelGrad(-torsoW/2, torsoW/2);
    ctx.beginPath();
    ctx.roundRect(-torsoW/2, torsoY, torsoW, torsoH, 22);
    ctx.fill();

    // Belly plate
    ctx.shadowBlur = 0;
    ctx.fillStyle = steelDark;
    ctx.beginPath();
    ctx.roundRect(-torsoW*0.20, torsoY + torsoH*0.18, torsoW*0.56, torsoH*0.66, 16);
    ctx.fill();

    // Rib/vent slats
    ctx.strokeStyle = 'rgba(180,210,255,0.14)';
    ctx.lineWidth = 2;
    for (let i=0;i<4;i++){
        const yy = torsoY + torsoH*(0.30 + i*0.14);
        ctx.beginPath();
        ctx.moveTo(-torsoW*0.10, yy);
        ctx.lineTo(torsoW*0.30, yy);
        ctx.stroke();
    }

    // Spine fins / heat sinks
    ctx.fillStyle = steelMid;
    for (let i=0;i<4;i++){
        const sx = -torsoW*0.22 + i*torsoW*0.19;
        ctx.beginPath();
        ctx.roundRect(sx, torsoY - 14, 18, 18, 4);
        ctx.fill();
    }

    // === Neck + head (kept mech) ===
    const neckX = torsoW*0.40;
    const neckY = torsoY + torsoH*0.22;

    ctx.save();
    ctx.translate(neckX, neckY);
    ctx.rotate(-0.10);
    ctx.fillStyle = steelGrad(-20, 22);
    ctx.beginPath();
    ctx.roundRect(-10, -14, 46, 24, 10);
    ctx.fill();
    ctx.restore();

    // Head
    ctx.save();
    ctx.translate(neckX + 34, neckY - 18);
    ctx.rotate(-0.10);

    // Skull block
    ctx.shadowColor = glow;
    ctx.shadowBlur = 14;
    ctx.fillStyle = steelGrad(-40, 44);
    ctx.beginPath();
    ctx.roundRect(-18, -18, 70, 40, 14);
    ctx.fill();

    // Eye
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#0a0d12';
    ctx.beginPath();
    ctx.ellipse(24, -2, 9, 6, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = isCharging ? '#ff3333' : '#ffd24a';
    ctx.beginPath();
    ctx.ellipse(26, -2, 4, 3, 0, 0, Math.PI*2);
    ctx.fill();

    // Jaw
    ctx.fillStyle = steelDark;
    ctx.beginPath();
    ctx.roundRect(-6, 12, 62, 16, 10);
    ctx.fill();

    // Teeth
    ctx.fillStyle = 'rgba(235,245,255,0.75)';
    for (let i=0;i<6;i++){
        const tx = 6 + i*8;
        ctx.beginPath();
        ctx.moveTo(tx, 14);
        ctx.lineTo(tx+3, 22);
        ctx.lineTo(tx-2, 22);
        ctx.closePath();
        ctx.fill();
    }

    // Snout bolts
    ctx.fillStyle = bolt;
    for (let i=0;i<3;i++){
        ctx.beginPath();
        ctx.arc(48, -8 + i*10, 2.0, 0, Math.PI*2);
        ctx.fill();
    }

    ctx.restore();

    // === Legs (make them longer / less stubby) ===
    const legBaseY = height * 0.14;
    const legX = [-width*0.06, width*0.14];
    const step = Math.sin(legAngle) * 10;

    for (let i=0;i<2;i++){
        ctx.save();
        ctx.translate(legX[i], legBaseY);
        ctx.rotate((i===0? -1:1) * legAngle*0.22);

        // Thigh (longer)
        ctx.fillStyle = steelGrad(-16, 18);
        ctx.beginPath();
        ctx.roundRect(-12, -4, 26, height*0.28, 10);
        ctx.fill();

        // Knee joint
        ctx.fillStyle = steelDark;
        ctx.beginPath();
        ctx.arc(0, height*0.28, 6, 0, Math.PI*2);
        ctx.fill();

        // Calf piston (longer)
        ctx.save();
        ctx.translate(0, height*0.28);
        ctx.rotate((i===0?1:-1)*legAngle*0.18);
        ctx.fillStyle = steelMid;
        ctx.beginPath();
        ctx.roundRect(-9, 0, 20, height*0.28, 10);
        ctx.fill();

        // Foot (lower)
        ctx.fillStyle = steelDark;
        ctx.beginPath();
        ctx.roundRect(-18, height*0.25 + step*0.02, 44, 14, 6);
        ctx.fill();

        // Claw spikes
        ctx.fillStyle = '#0c0f14';
        for (let c=0;c<3;c++){
            const cx = 6 + c*11;
            ctx.beginPath();
            ctx.moveTo(cx, height*0.28 + step*0.02);
            ctx.lineTo(cx+6, height*0.28 + step*0.02 + 6);
            ctx.lineTo(cx-2, height*0.28 + step*0.02 + 6);
            ctx.closePath();
            ctx.fill();
        }

        ctx.restore();
        ctx.restore();
    }

    // Subtle outline
    ctx.strokeStyle = 'rgba(220,235,255,0.10)';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(-torsoW/2, torsoY, torsoW, torsoH);

    // Health bar
    const barW = width * 0.6;
    const barY = -height * 0.65;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(-barW/2, barY, barW, 6);
    ctx.fillStyle = '#ff3333';
    ctx.fillRect(-barW/2, barY, barW * Math.max(0, health / maxHealth), 6);

    ctx.restore();
}


function drawHumanoidBot(x, y, width, height, legAngle, facingRight, health, maxHealth) {
    ctx.save();
    ctx.translate(x, y);
    if (!facingRight) ctx.scale(-1, 1);

    // Ground shadow
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.beginPath();
    ctx.ellipse(0, height*0.52, width*0.52, 12, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Metallic palette - darker for spider look
    const steel1 = '#404040';  // Dark gray
    const steel2 = '#2a2a2a';  // Darker gray
    const steel3 = '#0f0f0f';  // Almost black
    const redGlow = '#ff4444'; // Red accent

    const s = width / 72; // Scale factor
    const legMove = Math.sin(legAngle) * 8 * s;
    const legMove2 = Math.sin(legAngle + Math.PI) * 8 * s;

    // === SPIDER LEGS (4 legs total) ===
    // Back legs (drawn first, behind body)
    for (const side of [-1, 1]) {
        ctx.save();
        ctx.strokeStyle = steel2;
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        
        const hipX = side * width * 0.25;
        const hipY = -height * 0.15;
        const kneeX = side * width * 0.5 + (side * legMove2);
        const kneeY = height * 0.1;
        const footX = side * width * 0.4 + (side * legMove2 * 0.7);
        const footY = height * 0.52;
        
        // Upper leg
        ctx.beginPath();
        ctx.moveTo(hipX, hipY);
        ctx.lineTo(kneeX, kneeY);
        ctx.stroke();
        
        // Lower leg
        ctx.strokeStyle = steel3;
        ctx.beginPath();
        ctx.moveTo(kneeX, kneeY);
        ctx.lineTo(footX, footY);
        ctx.stroke();
        
        // Joint
        ctx.fillStyle = steel1;
        ctx.beginPath();
        ctx.arc(kneeX, kneeY, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Foot claw (3 prongs)
        ctx.fillStyle = steel3;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(footX, footY);
        ctx.lineTo(footX - side * 8, footY + 10);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(footX, footY);
        ctx.lineTo(footX, footY + 12);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(footX, footY);
        ctx.lineTo(footX + side * 8, footY + 10);
        ctx.stroke();
        
        ctx.restore();
    }

    // === TANK BODY (angular, compact) ===
    const bodyW = width * 0.6;
    const bodyH = height * 0.35;
    const bodyY = -height * 0.25;
    
    // Main body gradient
    const bodyGrad = ctx.createLinearGradient(-bodyW/2, bodyY, bodyW/2, bodyY + bodyH);
    bodyGrad.addColorStop(0, steel1);
    bodyGrad.addColorStop(0.5, steel2);
    bodyGrad.addColorStop(1, steel3);
    ctx.fillStyle = bodyGrad;
    ctx.beginPath();
    ctx.moveTo(-bodyW/2, bodyY);
    ctx.lineTo(bodyW/2, bodyY);
    ctx.lineTo(bodyW/2 - 8, bodyY + bodyH);
    ctx.lineTo(-bodyW/2 + 8, bodyY + bodyH);
    ctx.closePath();
    ctx.fill();
    
    // Armor plates
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Top turret/sensor dome
    const domeW = bodyW * 0.4;
    const domeH = height * 0.25;
    const domeY = bodyY - domeH + 5;
    ctx.fillStyle = steel2;
    ctx.beginPath();
    ctx.ellipse(0, domeY + domeH/2, domeW/2, domeH/2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = steel1;
    ctx.lineWidth = 1;
    ctx.stroke();

    // Front legs (drawn on top)
    for (const side of [-1, 1]) {
        ctx.save();
        ctx.strokeStyle = steel1;
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        
        const hipX = side * width * 0.15;
        const hipY = -height * 0.05;
        const kneeX = side * width * 0.45 + (side * legMove);
        const kneeY = height * 0.15;
        const footX = side * width * 0.35 + (side * legMove * 0.7);
        const footY = height * 0.52;
        
        // Upper leg
        ctx.beginPath();
        ctx.moveTo(hipX, hipY);
        ctx.lineTo(kneeX, kneeY);
        ctx.stroke();
        
        // Lower leg  
        ctx.strokeStyle = steel2;
        ctx.beginPath();
        ctx.moveTo(kneeX, kneeY);
        ctx.lineTo(footX, footY);
        ctx.stroke();
        
        // Joint
        ctx.fillStyle = steel1;
        ctx.beginPath();
        ctx.arc(kneeX, kneeY, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Foot claw (3 prongs)
        ctx.fillStyle = steel3;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(footX, footY);
        ctx.lineTo(footX - side * 8, footY + 10);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(footX, footY);
        ctx.lineTo(footX, footY + 12);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(footX, footY);
        ctx.lineTo(footX + side * 8, footY + 10);
        ctx.stroke();
        
        ctx.restore();
    }

    // Red sensor eyes / targeting system
    ctx.save();
    ctx.shadowColor = redGlow;
    ctx.shadowBlur = 15;
    ctx.fillStyle = redGlow;
    ctx.globalAlpha = 0.9;
    for (const side of [-1, 1]) {
        ctx.beginPath();
        ctx.arc(side * domeW * 0.25, domeY + domeH * 0.5, 4, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.restore();
    
    // Panel details on body
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-bodyW * 0.3, bodyY + 5);
    ctx.lineTo(-bodyW * 0.3, bodyY + bodyH - 5);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(bodyW * 0.3, bodyY + 5);
    ctx.lineTo(bodyW * 0.3, bodyY + bodyH - 5);
    ctx.stroke();

    // Health bar
    const hbY = -height * 0.62;
    const hbWidth = 60, hbHeight = 6;
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(-hbWidth/2, hbY, hbWidth, hbHeight);
    ctx.fillStyle = '#ff3b4a';
    ctx.fillRect(-hbWidth/2, hbY, hbWidth * (health / maxHealth), hbHeight);

    ctx.restore();
}



// SPIDER TANK - Large robotic enemy with 4 legs and RED NEON GLOW
function drawMetallicTRex(x, y, width, height, legAngle, facingRight, health, maxHealth, isCharging, telegraphUntil, targetX, targetY) {
    ctx.save();
    ctx.translate(x, y);
    if (!facingRight) ctx.scale(-1, 1);

    const now = Date.now();
    const s = width / 100;
    
    // Colors - VERY DARK BLACK METAL
    const metalDark = '#020202';   // Nearly pure black
    const metalMid = '#060606';    // Slightly lighter black
    const metalLight = '#0c0c0c';  // Dark charcoal
    const glowRed = '#ff0000';
    
    // === RED NEON GLOW - like player's green glow ===
    // This creates a persistent glow around all drawn elements
    const glowPulse = 0.85 + Math.sin(now * 0.004) * 0.15;
    ctx.shadowColor = `rgba(255, 50, 50, ${glowPulse})`;
    ctx.shadowBlur = 25;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    
    // Leg animation
    const legMove = Math.sin(legAngle) * 10 * s;
    const legMove2 = Math.sin(legAngle + Math.PI) * 10 * s;

    // === BACK LEGS (behind body) ===
    // Back-left leg
    ctx.save();
    ctx.fillStyle = metalDark;
    ctx.strokeStyle = metalMid;
    ctx.lineWidth = 2;
    
    // Upper leg segment
    ctx.beginPath();
    ctx.moveTo(-30*s, -35*s);
    ctx.lineTo(-70*s, -20*s + legMove2);
    ctx.lineTo(-75*s, -15*s + legMove2);
    ctx.lineTo(-35*s, -30*s);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Lower leg segment
    ctx.beginPath();
    ctx.moveTo(-70*s, -18*s + legMove2);
    ctx.lineTo(-90*s, 40*s + legMove2 * 0.5);
    ctx.lineTo(-85*s, 45*s + legMove2 * 0.5);
    ctx.lineTo(-65*s, -12*s + legMove2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Spider claw foot - pointed tips
    ctx.fillStyle = metalMid;
    ctx.beginPath();
    // Main point
    ctx.moveTo(-87*s, 40*s + legMove2 * 0.5);
    ctx.lineTo(-90*s, 62*s + legMove2 * 0.3);
    ctx.lineTo(-85*s, 55*s + legMove2 * 0.3);
    ctx.closePath();
    ctx.fill();
    // Side prong left
    ctx.beginPath();
    ctx.moveTo(-92*s, 42*s + legMove2 * 0.5);
    ctx.lineTo(-100*s, 58*s + legMove2 * 0.3);
    ctx.lineTo(-94*s, 52*s + legMove2 * 0.3);
    ctx.closePath();
    ctx.fill();
    // Side prong right
    ctx.beginPath();
    ctx.moveTo(-82*s, 42*s + legMove2 * 0.5);
    ctx.lineTo(-78*s, 58*s + legMove2 * 0.3);
    ctx.lineTo(-80*s, 52*s + legMove2 * 0.3);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Back-right leg
    ctx.save();
    ctx.fillStyle = metalDark;
    ctx.strokeStyle = metalMid;
    ctx.lineWidth = 2;
    
    ctx.beginPath();
    ctx.moveTo(30*s, -35*s);
    ctx.lineTo(70*s, -20*s + legMove);
    ctx.lineTo(75*s, -15*s + legMove);
    ctx.lineTo(35*s, -30*s);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(70*s, -18*s + legMove);
    ctx.lineTo(90*s, 40*s + legMove * 0.5);
    ctx.lineTo(85*s, 45*s + legMove * 0.5);
    ctx.lineTo(65*s, -12*s + legMove);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Spider claw foot - pointed tips
    ctx.fillStyle = metalMid;
    ctx.beginPath();
    ctx.moveTo(87*s, 40*s + legMove * 0.5);
    ctx.lineTo(90*s, 62*s + legMove * 0.3);
    ctx.lineTo(85*s, 55*s + legMove * 0.3);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(82*s, 42*s + legMove * 0.5);
    ctx.lineTo(78*s, 58*s + legMove * 0.3);
    ctx.lineTo(80*s, 52*s + legMove * 0.3);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(92*s, 42*s + legMove * 0.5);
    ctx.lineTo(100*s, 58*s + legMove * 0.3);
    ctx.lineTo(94*s, 52*s + legMove * 0.3);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // === MAIN BODY ===
    ctx.save();
    
    // Body - angular armored shape
    const bodyGrad = ctx.createLinearGradient(0, -80*s, 0, 0);
    bodyGrad.addColorStop(0, metalLight);
    bodyGrad.addColorStop(0.5, metalMid);
    bodyGrad.addColorStop(1, metalDark);
    ctx.fillStyle = bodyGrad;
    
    ctx.beginPath();
    ctx.moveTo(-50*s, -30*s);
    ctx.lineTo(-45*s, -70*s);
    ctx.lineTo(-20*s, -85*s);
    ctx.lineTo(40*s, -85*s);
    ctx.lineTo(70*s, -65*s);
    ctx.lineTo(80*s, -40*s);
    ctx.lineTo(75*s, -20*s);
    ctx.lineTo(50*s, -10*s);
    ctx.lineTo(-30*s, -10*s);
    ctx.lineTo(-55*s, -20*s);
    ctx.closePath();
    ctx.fill();
    
    // THICK RED FOG - volumetric fog effect, not particles
    ctx.save();
    // Clip to body shape
    ctx.beginPath();
    ctx.moveTo(-50*s, -30*s);
    ctx.lineTo(-45*s, -70*s);
    ctx.lineTo(-20*s, -85*s);
    ctx.lineTo(40*s, -85*s);
    ctx.lineTo(70*s, -65*s);
    ctx.lineTo(80*s, -40*s);
    ctx.lineTo(75*s, -20*s);
    ctx.lineTo(50*s, -10*s);
    ctx.lineTo(-30*s, -10*s);
    ctx.lineTo(-55*s, -20*s);
    ctx.closePath();
    ctx.clip();
    
    const gasTime = now * 0.001; // Slower for fog
    
    // BASE FOG LAYER - fill entire body with red fog (reduced another 10%)
    ctx.globalAlpha = 0.2025;  // Was 0.225
    const baseFog = ctx.createLinearGradient(-60*s, -85*s, 80*s, -10*s);
    baseFog.addColorStop(0, 'rgba(180, 20, 20, 0.567)');  // Was 0.63
    baseFog.addColorStop(0.5, 'rgba(220, 30, 30, 0.486)');  // Was 0.54
    baseFog.addColorStop(1, 'rgba(160, 15, 15, 0.405)');  // Was 0.45
    ctx.fillStyle = baseFog;
    ctx.fillRect(-70*s, -95*s, 160*s, 90*s);
    
    // LAYER 1: Massive fog clouds (reduced another 10%)
    ctx.globalAlpha = 0.162;  // Was 0.18
    for (let i = 0; i < 4; i++) {
        const fx = -70*s + i * 45*s + Math.sin(gasTime * 0.3 + i * 0.8) * 25*s;
        const fy = -65*s + Math.cos(gasTime * 0.25 + i * 0.6) * 20*s;
        const fogGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, 60*s);
        fogGrad.addColorStop(0, 'rgba(255, 50, 50, 0.648)');  // Was 0.72
        fogGrad.addColorStop(0.3, 'rgba(220, 30, 30, 0.486)');  // Was 0.54
        fogGrad.addColorStop(0.6, 'rgba(180, 20, 20, 0.324)');  // Was 0.36
        fogGrad.addColorStop(1, 'rgba(140, 10, 10, 0)');
        ctx.fillStyle = fogGrad;
        ctx.beginPath();
        ctx.arc(fx, fy, 60*s, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // LAYER 2: Large fog banks (reduced another 10%)
    ctx.globalAlpha = 0.2025;  // Was 0.225
    for (let i = 0; i < 8; i++) {
        const bx = -60*s + i * 18*s + Math.sin(gasTime * 0.5 + i * 0.5) * 18*s;
        const by = -75*s + Math.cos(gasTime * 0.4 + i * 0.7) * 25*s;
        const bankGrad = ctx.createRadialGradient(bx, by, 0, bx, by, 40*s);
        bankGrad.addColorStop(0, 'rgba(255, 60, 60, 0.6075)');  // Was 0.675
        bankGrad.addColorStop(0.4, 'rgba(210, 35, 35, 0.4455)');  // Was 0.495
        bankGrad.addColorStop(0.7, 'rgba(170, 20, 20, 0.243)');  // Was 0.27
        bankGrad.addColorStop(1, 'rgba(130, 10, 10, 0)');
        ctx.fillStyle = bankGrad;
        ctx.beginPath();
        ctx.arc(bx, by, 40*s, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // LAYER 3: Medium fog wisps (reduced another 10%)
    ctx.globalAlpha = 0.243;  // Was 0.27
    for (let i = 0; i < 15; i++) {
        const wx = -55*s + i * 10*s + Math.sin(gasTime * 0.7 + i * 0.6) * 14*s;
        const wy = -70*s + Math.cos(gasTime * 0.6 + i * 0.8) * 22*s;
        const wispGrad = ctx.createRadialGradient(wx, wy, 0, wx, wy, 28*s);
        wispGrad.addColorStop(0, 'rgba(255, 70, 70, 0.648)');  // Was 0.72
        wispGrad.addColorStop(0.5, 'rgba(200, 40, 40, 0.486)');  // Was 0.54
        wispGrad.addColorStop(1, 'rgba(150, 20, 20, 0)');
        ctx.fillStyle = wispGrad;
        ctx.beginPath();
        ctx.arc(wx, wy, 28*s, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // LAYER 4: Small fog details (reduced another 10%)
    ctx.globalAlpha = 0.2835;  // Was 0.315
    for (let i = 0; i < 20; i++) {
        const dx = -50*s + i * 7*s + Math.sin(gasTime * 0.9 + i * 0.4) * 12*s;
        const dy = -68*s + Math.cos(gasTime * 0.8 + i * 0.9) * 18*s;
        const detailGrad = ctx.createRadialGradient(dx, dy, 0, dx, dy, 18*s);
        detailGrad.addColorStop(0, 'rgba(255, 80, 80, 0.729)');  // Was 0.81
        detailGrad.addColorStop(0.6, 'rgba(180, 35, 35, 0.405)');  // Was 0.45
        detailGrad.addColorStop(1, 'rgba(140, 15, 15, 0)');
        ctx.fillStyle = detailGrad;
        ctx.beginPath();
        ctx.arc(dx, dy, 18*s, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // LAYER 5: Bright dense pockets (reduced another 10%)
    ctx.globalAlpha = 0.324;  // Was 0.36
    for (let i = 0; i < 7; i++) {
        const px = -40*s + i * 15*s + Math.sin(gasTime * 1.1 + i * 0.9) * 10*s;
        const py = -55*s + Math.cos(gasTime * 0.95 + i * 1.1) * 15*s;
        const pocketGrad = ctx.createRadialGradient(px, py, 0, px, py, 20*s);
        pocketGrad.addColorStop(0, 'rgba(255, 100, 100, 0.7695)');  // Was 0.855
        pocketGrad.addColorStop(0.5, 'rgba(220, 50, 50, 0.567)');  // Was 0.63
        pocketGrad.addColorStop(1, 'rgba(160, 25, 25, 0)');
        ctx.fillStyle = pocketGrad;
        ctx.beginPath();
        ctx.arc(px, py, 20*s, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // LAYER 6: Top atmospheric haze (reduced another 10%)
    ctx.globalAlpha = 0.162;  // Was 0.18
    const hazeGrad = ctx.createLinearGradient(0, -95*s, 0, -20*s);
    hazeGrad.addColorStop(0, 'rgba(255, 40, 40, 0.405)');  // Was 0.45
    hazeGrad.addColorStop(0.4, 'rgba(200, 30, 30, 0.486)');  // Was 0.54
    hazeGrad.addColorStop(0.7, 'rgba(180, 25, 25, 0.324)');  // Was 0.36
    hazeGrad.addColorStop(1, 'rgba(150, 15, 15, 0.162)');  // Was 0.18
    ctx.fillStyle = hazeGrad;
    ctx.fillRect(-70*s, -95*s, 160*s, 80*s);
    
    ctx.globalAlpha = 1;
    ctx.restore();
    
    // Armor panel lines - REMOVED (no vertical lines)
    
    // Top armor ridge
    ctx.fillStyle = metalLight;
    ctx.beginPath();
    ctx.moveTo(-15*s, -85*s);
    ctx.lineTo(35*s, -85*s);
    ctx.lineTo(30*s, -95*s);
    ctx.lineTo(-10*s, -95*s);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = metalMid;
    ctx.stroke();
    
    ctx.restore();

    // === FRONT LEGS ===
    // Front-left leg
    ctx.save();
    ctx.fillStyle = metalMid;
    ctx.strokeStyle = metalLight;
    ctx.lineWidth = 2;
    
    ctx.beginPath();
    ctx.moveTo(-40*s, -25*s);
    ctx.lineTo(-80*s, -5*s + legMove);
    ctx.lineTo(-85*s, 0 + legMove);
    ctx.lineTo(-45*s, -20*s);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(-80*s, -3*s + legMove);
    ctx.lineTo(-100*s, 50*s + legMove * 0.5);
    ctx.lineTo(-95*s, 55*s + legMove * 0.5);
    ctx.lineTo(-75*s, 2*s + legMove);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Spider claw foot - pointed tips
    ctx.fillStyle = metalLight;
    ctx.beginPath();
    ctx.moveTo(-97*s, 50*s + legMove * 0.5);
    ctx.lineTo(-100*s, 72*s + legMove * 0.3);
    ctx.lineTo(-95*s, 65*s + legMove * 0.3);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(-102*s, 52*s + legMove * 0.5);
    ctx.lineTo(-110*s, 68*s + legMove * 0.3);
    ctx.lineTo(-104*s, 62*s + legMove * 0.3);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(-92*s, 52*s + legMove * 0.5);
    ctx.lineTo(-88*s, 68*s + legMove * 0.3);
    ctx.lineTo(-90*s, 62*s + legMove * 0.3);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Front-right leg
    ctx.save();
    ctx.fillStyle = metalMid;
    ctx.strokeStyle = metalLight;
    ctx.lineWidth = 2;
    
    ctx.beginPath();
    ctx.moveTo(50*s, -25*s);
    ctx.lineTo(90*s, -5*s + legMove2);
    ctx.lineTo(95*s, 0 + legMove2);
    ctx.lineTo(55*s, -20*s);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(90*s, -3*s + legMove2);
    ctx.lineTo(110*s, 50*s + legMove2 * 0.5);
    ctx.lineTo(105*s, 55*s + legMove2 * 0.5);
    ctx.lineTo(85*s, 2*s + legMove2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Spider claw foot - pointed tips
    ctx.fillStyle = metalLight;
    ctx.beginPath();
    ctx.moveTo(107*s, 50*s + legMove2 * 0.5);
    ctx.lineTo(110*s, 72*s + legMove2 * 0.3);
    ctx.lineTo(105*s, 65*s + legMove2 * 0.3);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(102*s, 52*s + legMove2 * 0.5);
    ctx.lineTo(98*s, 68*s + legMove2 * 0.3);
    ctx.lineTo(100*s, 62*s + legMove2 * 0.3);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(112*s, 52*s + legMove2 * 0.5);
    ctx.lineTo(120*s, 68*s + legMove2 * 0.3);
    ctx.lineTo(114*s, 62*s + legMove2 * 0.3);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // === WEAPON TURRET (AIMS AT TARGET) ===
    ctx.save();
    ctx.translate(60*s, -55*s);
    
    // Calculate aim angle toward target
    let turretAngle = 0;
    if (targetX !== undefined && targetY !== undefined) {
        // Turret world position
        const turretWorldX = facingRight ? x + 60*s : x - 60*s;
        const turretWorldY = y - 55*s;
        const aimDx = targetX - turretWorldX;
        const aimDy = targetY - turretWorldY;
        // In local space, x is flipped if !facingRight
        const localDx = facingRight ? aimDx : -aimDx;
        const localDy = aimDy;
        turretAngle = Math.atan2(localDy, localDx);
        // Clamp: can aim up a lot but not too far down or behind
        turretAngle = Math.max(-Math.PI * 0.45, Math.min(Math.PI * 0.25, turretAngle));
    }
    
    // Turret base (doesn't rotate)
    ctx.fillStyle = metalDark;
    ctx.beginPath();
    ctx.ellipse(0, 0, 20*s, 12*s, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Rotate barrel to aim at target
    ctx.rotate(turretAngle);
    
    // Gun barrel - EXTENDED AND LARGER
    ctx.fillStyle = metalMid;
    ctx.fillRect(10*s, -7*s, 70*s, 14*s);  // Extended from 45 to 70, wider from 10 to 14
    ctx.fillStyle = metalDark;
    ctx.fillRect(75*s, -6*s, 12*s, 12*s);  // Extended muzzle
    
    // Barrel accent rings
    ctx.fillStyle = metalLight;
    ctx.fillRect(30*s, -7*s, 3*s, 14*s);
    ctx.fillRect(55*s, -7*s, 3*s, 14*s);
    
    // Barrel glow when charging
    if (isCharging) {
        ctx.fillStyle = glowRed;
        ctx.shadowColor = glowRed;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(87*s, 0, 5*s, 0, Math.PI * 2);  // Extended position
        ctx.fill();
        ctx.shadowBlur = 0;
    }
    ctx.restore();

    // === MAIN SENSOR / EYE === REMOVED (no red windows)
    // Sensor removed for darker, more menacing look


    // === HEALTH BAR ===
    // Turn off neon glow for clean health bar
    ctx.shadowBlur = 0;
    if (maxHealth) {
        const hp = Math.max(0, Math.min(1, health / maxHealth));
        const barW = 100*s;
        const barH = 8*s;
        const barX = x - barW/2;
        const barY = y - 140*s;
        
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(barX - 2, barY - 2, barW + 4, barH + 4);
        ctx.fillStyle = '#1a0a0a';
        ctx.fillRect(barX, barY, barW, barH);
        
        // Red health bar
        const hpGrad = ctx.createLinearGradient(barX, barY, barX + barW * hp, barY);
        hpGrad.addColorStop(0, '#cc0000');
        hpGrad.addColorStop(0.5, '#ff2200');
        hpGrad.addColorStop(1, '#ff4400');
        ctx.fillStyle = hpGrad;
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 5;
        ctx.fillRect(barX, barY, barW * hp, barH);
        ctx.shadowBlur = 0;
        
        ctx.strokeStyle = 'rgba(255, 50, 50, 0.5)';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barW, barH);
    }
    
    // === ELECTRICITY ARCS (scary effect) - ALL AROUND BODY AND LEGS ===
    const elecTime = now * 0.003;
    
    // Draw 3-5 random electricity arcs around the body - MORE FREQUENT
    if (Math.sin(elecTime) > -0.3) {  // Appears more often (was > 0.2)
        ctx.save();
        ctx.strokeStyle = '#ff0000';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 25;  // Brighter glow
        ctx.lineWidth = 3;    // Thicker arcs
        ctx.globalAlpha = 0.7 + Math.sin(elecTime * 2) * 0.3;
        
        const numArcs = 3 + Math.floor(Math.random() * 3);  // 3-5 arcs
        for (let i = 0; i < numArcs; i++) {
            // Random start point anywhere on the spider tank (including legs)
            // Wider range to cover legs and entire body
            const startX = (Math.random() - 0.5) * width * 1.4;  // Wider for legs
            const startY = -height * (Math.random() * 0.9);  // From top to legs
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            
            // Jagged lightning path - MORE SEGMENTS, circulate around body
            let px = startX, py = startY;
            const segments = 4 + Math.floor(Math.random() * 4);  // 4-7 segments
            for (let j = 0; j < segments; j++) {
                // Make arcs wrap around the body/legs
                const nx = px + (Math.random() - 0.5) * 60;  // Wider spread
                const ny = py + (Math.random() - 0.5) * 50;
                ctx.lineTo(nx, ny);
                px = nx;
                py = ny;
            }
            ctx.stroke();
            
            // Bright spark at end - BIGGER
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(px, py, 5, 0, Math.PI * 2);  // Bigger spark
            ctx.fill();
        }
        ctx.restore();
    }

    ctx.restore();
}
function drawRocket(rocket) {
    ctx.save();
    ctx.translate(rocket.x, rocket.y);
    // Always face direction of travel (no spinning)
    const ang = Math.atan2(rocket.vy, rocket.vx);
    ctx.rotate(ang);

    // Thin smoke + tiny crackle behind missile (kept subtle)
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = 'rgba(210,220,235,0.35)';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(-18, 0);
    ctx.lineTo(-34, 0);
    ctx.stroke();

    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-18, -1);
    ctx.lineTo(-30, -1);
    ctx.stroke();
    ctx.restore();

    // Missile body (simple, readable)
    const bodyGrad = ctx.createLinearGradient(-18, -6, 18, 6);
    bodyGrad.addColorStop(0, '#0c111a');
    bodyGrad.addColorStop(0.35, '#d7e2f0');
    bodyGrad.addColorStop(0.7, '#6d7f97');
    bodyGrad.addColorStop(1, '#0a0f18');
    ctx.fillStyle = bodyGrad;

    // Main tube
    ctx.beginPath();
    ctx.roundRect(-16, -4, 26, 8, 3);
    ctx.fill();

    // Nose cone
    ctx.fillStyle = '#cfd9e8';
    ctx.beginPath();
    ctx.moveTo(10, -4);
    ctx.lineTo(18, 0);
    ctx.lineTo(10, 4);
    ctx.closePath();
    ctx.fill();

    // Small fins
    ctx.fillStyle = '#1a2432';
    ctx.beginPath();
    ctx.moveTo(-10, -4);
    ctx.lineTo(-14, -9);
    ctx.lineTo(-6, -4);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(-10, 4);
    ctx.lineTo(-14, 9);
    ctx.lineTo(-6, 4);
    ctx.closePath();
    ctx.fill();

    // Tip light (tiny)
    ctx.save();
    ctx.globalAlpha = 0.6;
    ctx.fillStyle = 'rgba(255,80,80,0.7)';
    ctx.beginPath();
    ctx.arc(17, 0, 1.8, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.restore();
}


function createExplosion(x, y, color, count = 25, big = false) {
    const baseSpeed = big ? 10 : 6;
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2, speed = baseSpeed * (0.3 + Math.random() * 0.7);
        particles.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - 2, life: 1, decay: 0.012 + Math.random() * 0.015, color: color, size: (big ? 3.5 : 2.4) + Math.random() * (big ? 4.5 : 3.2) });
    }
    // Extra sparks for explosion
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2, speed = baseSpeed * 1.5 * (0.5 + Math.random());
        sparks.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - 1, life: 0.8 + Math.random() * 0.4, size: 2 + Math.random() * 3, color: Math.random() > 0.3 ? '#ffffff' : '#ffff00' });
    }
    if (big) {
        for (let i = 0; i < 10; i++) {
            const angle = Math.random() * Math.PI * 2, speed = 4 + Math.random() * 6;
            debris.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - 5, rotation: Math.random() * Math.PI * 2, rotSpeed: (Math.random() - 0.5) * 0.4, life: 1, size: 6 + Math.random() * 12, color: color });
        }
    }
}

function showWaveAnnouncement(text, color) {
    // Never show announcements during intro cinematic
    if (typeof introRunning !== 'undefined' && introRunning) return;
    if (typeof charSelectRunning !== 'undefined' && charSelectRunning) return;
    const el = document.getElementById('waveAnnounce');
    el.textContent = text;
    if (color) {
        el.style.color = color;
        el.style.textShadow = `0 0 20px ${color}, 0 0 40px ${color}`;
    } else {
        el.style.color = '';
        el.style.textShadow = '';
    }
    el.style.opacity = 1;
    setTimeout(() => { el.style.transition = 'opacity 1s'; el.style.opacity = 0; }, 2000);
    setTimeout(() => { el.style.transition = ''; el.style.color = ''; el.style.textShadow = ''; }, 3000);
}

function spawnEnemy() {
    // Exploration spawn: spawn ahead of where the player is going (not on top of the player)
    // 15% chance to spawn a metallic T-Rex, 85% chance for regular bot
    const isTRex = Math.random() < 0.15;
    const kind = isTRex ? 'trex' : 'bot';

    const baseX = camX + canvas.width + 160 + Math.random()*260;

    // Prevent surface enemies from spawning over water zones (no "walking on water")
    const wzStart = (underwaterZone ? underwaterZone.startX : nextWaterEdgeX);
    const wzEnd   = (underwaterZone ? underwaterZone.endX   : (nextWaterEdgeX + WATER_ZONE_LENGTH_MAX));
    if (!isUnderwater && baseX > (wzStart - 120) && baseX < (wzEnd + 120)) {
        return;
    }
    const groundY = canvas.height - 120;  // Raised for mobile visibility

    const enemy = {
        kind,
        x: baseX,
        y: groundY,
        targetX: 0, targetY: 0,
        width: isTRex ? 160 : 72,
        height: isTRex ? 180 : 118,
        health: isTRex ? (180 + difficulty * 40) : (90 + difficulty * 25),
        maxHealth: isTRex ? (180 + difficulty * 40) : (90 + difficulty * 25),
        speed: isTRex ? (2.2 + difficulty * 0.18 + Math.random()*0.4) : (2.6 + difficulty * 0.22 + Math.random()*0.55),
        legAngle: 0, legDir: 1,
        facingRight: false,
        lastAttack: Date.now(),
        attackRate: isTRex ? (1800 - difficulty * 70) : (2200 - difficulty * 90),
        chargeTimer: 0,
        isCharging: false,
        // T-Rex always has laser eye attack, bots have 22% chance
        hasLaser: isTRex ? true : false, // Only T-Rex has lasers, not regular bots
        lastShot: Date.now() - Math.random()*900,
        shotRate: isTRex ? Math.max(650, 1200 - difficulty * 70 + (Math.random()*300-150)) : Math.max(780, 1500 - difficulty * 85 + (Math.random()*420-210)),
        telegraphUntil: 0,
        telegraphData: null
    };

    // Limit laser units on screen (fairness) - T-Rex doesn't count toward this limit
    if (!isTRex) {
        const allowedLaser = (kills < 10) ? 1 : (kills < 26 ? 2 : 3);
        const currentLaser = enemies.reduce((n,e)=> n + (e.hasLaser && e.kind !== 'trex' ? 1 : 0), 0);
        if (enemy.hasLaser && currentLaser >= allowedLaser) enemy.hasLaser = false;
    }

    enemy.targetX = player.x + (Math.random() * 420 + 240);
    enemy.targetY = groundY;

    enemies.push(enemy);
}

// Flying drones array
let drones = [];

// === TECH PLATFORMS, GROUND OBSTACLES & PICKUPS ===
function spawnPlatformsAndObstacles() {
    const groundY = canvas.height - 120;
    const worldX = nextPlatformX;
    
    // 25% elevator, 75% normal
    const platType = Math.random() < 0.25 ? 'elevator' : 'normal';
    
    const hasHealth = Math.random() < 0.15;
    const platY = groundY - (35 + Math.random() * 20);
    const platW = 70 + Math.random() * 40;
    
    const plat = {
        x: worldX, y: platY, baseY: platY, w: platW, h: 18,
        bobPhase: Math.random() * Math.PI * 2,
        type: platType,
        elevating: false, elevateT: 0, elevateDir: 0
    };
    techPlatforms.push(plat);
    
    if (hasHealth) {
        healthPickups.push({
            x: worldX + platW / 2, y: platY - 28,
            collected: false, bobPhase: Math.random() * Math.PI * 2
        });
    }
    
    nextPlatformX += 1400 + Math.random() * 1800;
}

function drawGroundObstacle(obs) {
    const sx = obs.x;
    if (sx < camX - 100 || sx > camX + canvas.width + 100) return;
    const baseY = obs.y;
    
    ctx.save();
    // Dark tech barrier body
    const g = ctx.createLinearGradient(sx, baseY - obs.h, sx, baseY);
    g.addColorStop(0, '#1a2030');
    g.addColorStop(0.5, '#0e1520');
    g.addColorStop(1, '#080c14');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.roundRect(sx - obs.w / 2, baseY - obs.h, obs.w, obs.h, 4);
    ctx.fill();
    
    // Metal edge highlight
    ctx.strokeStyle = 'rgba(100, 140, 180, 0.25)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(sx - obs.w / 2, baseY - obs.h, obs.w, obs.h, 4);
    ctx.stroke();
    
    // Hazard stripes (angled)
    ctx.save();
    ctx.beginPath();
    ctx.roundRect(sx - obs.w / 2, baseY - obs.h, obs.w, obs.h, 4);
    ctx.clip();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = '#ff6600';
    ctx.lineWidth = 3;
    for (let i = -obs.w; i < obs.w * 2; i += 12) {
        ctx.beginPath();
        ctx.moveTo(sx - obs.w / 2 + i, baseY);
        ctx.lineTo(sx - obs.w / 2 + i + obs.h, baseY - obs.h);
        ctx.stroke();
    }
    ctx.restore();
    
    // Glowing red top edge (danger indicator)
    ctx.shadowColor = 'rgba(255, 60, 30, 0.5)';
    ctx.shadowBlur = 6;
    ctx.strokeStyle = 'rgba(255, 60, 30, 0.5)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(sx - obs.w / 2 + 4, baseY - obs.h);
    ctx.lineTo(sx + obs.w / 2 - 4, baseY - obs.h);
    ctx.stroke();
    
    // Rivets
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#2a3040';
    const rivY1 = baseY - obs.h + 6;
    const rivY2 = baseY - 6;
    ctx.beginPath();
    ctx.arc(sx - obs.w / 2 + 6, rivY1, 2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath();
    ctx.arc(sx + obs.w / 2 - 6, rivY1, 2, 0, Math.PI * 2); ctx.fill();
    if (obs.h > 40) {
        ctx.beginPath();
        ctx.arc(sx - obs.w / 2 + 6, rivY2, 2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath();
        ctx.arc(sx + obs.w / 2 - 6, rivY2, 2, 0, Math.PI * 2); ctx.fill();
    }
    
    ctx.restore();
}

function drawTechPlatform(plat) {
    const sx = plat.x;
    if (sx < camX - 150 || sx > camX + canvas.width + 150) return;
    const now = Date.now();
    const bob = Math.sin(now * 0.002 + plat.bobPhase) * 3;
    const py = plat.y + bob;
    const occupied = (player._onPlatform === plat);
    
    // Default pulsing glow ‚Äî all platforms breathe silver
    const basePulse = 0.3 + Math.sin(now * 0.003 + plat.bobPhase) * 0.15;
    
    // Type-specific accent color
    let accentR = 200, accentG = 210, accentB = 225; // silver default
    if (plat.type === 'elevator') { accentR = 255; accentG = 200; accentB = 80; } // gold
    
    const glowAlpha = occupied ? 0.6 : basePulse;
    const glowBlur = occupied ? 22 : (8 + Math.sin(now * 0.003 + plat.bobPhase) * 4);
    
    ctx.save();
    
    // Platform shadow on ground
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = '#000';
    const shadowScale = 1 - (canvas.height - 120 - py) / 300;
    ctx.beginPath();
    ctx.ellipse(sx + plat.w / 2, canvas.height - 118, plat.w * 0.4 * Math.max(0.3, shadowScale), 4, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    // Glow underneath ‚Äî pulses by default, intensifies when occupied
    ctx.shadowColor = `rgba(${accentR}, ${accentG}, ${accentB}, ${glowAlpha})`;
    ctx.shadowBlur = glowBlur;
    
    // Main platform body
    const pg = ctx.createLinearGradient(sx, py - 4, sx, py + plat.h);
    if (occupied) {
        pg.addColorStop(0, '#2e3238');
        pg.addColorStop(0.3, '#22262c');
        pg.addColorStop(1, '#141618');
    } else {
        pg.addColorStop(0, '#22262c');
        pg.addColorStop(0.3, '#181c22');
        pg.addColorStop(1, '#0c0e12');
    }
    ctx.fillStyle = pg;
    ctx.beginPath();
    ctx.roundRect(sx, py, plat.w, plat.h, 3);
    ctx.fill();
    
    // Top surface highlight ‚Äî pulsing
    const topAlpha = occupied ? 0.22 : (0.06 + basePulse * 0.08);
    ctx.fillStyle = `rgba(${accentR}, ${accentG}, ${accentB}, ${topAlpha})`;
    ctx.fillRect(sx + 2, py, plat.w - 4, 3);
    
    // Side panel lines
    ctx.strokeStyle = `rgba(${accentR}, ${accentG}, ${accentB}, ${occupied ? 0.15 : 0.07})`;
    ctx.lineWidth = 1;
    const panelW = plat.w / 4;
    for (let i = 1; i < 4; i++) {
        ctx.beginPath();
        ctx.moveTo(sx + i * panelW, py + 2);
        ctx.lineTo(sx + i * panelW, py + plat.h - 2);
        ctx.stroke();
    }
    
    // Edge glow ‚Äî pulsing border
    ctx.shadowBlur = 0;
    const edgeAlpha = occupied ? 0.4 : (0.1 + basePulse * 0.1);
    ctx.strokeStyle = `rgba(${accentR}, ${accentG}, ${accentB}, ${edgeAlpha})`;
    ctx.lineWidth = occupied ? 1.5 : 1;
    ctx.beginPath();
    ctx.roundRect(sx, py, plat.w, plat.h, 3);
    ctx.stroke();
    
    // Type indicator icons
    const cx = sx + plat.w / 2;
    if (plat.type === 'elevator') {
        // Up/down arrows
        ctx.fillStyle = `rgba(${accentR}, ${accentG}, ${accentB}, ${occupied ? 0.5 : 0.2 + basePulse * 0.15})`;
        ctx.beginPath();
        ctx.moveTo(cx, py + 4); ctx.lineTo(cx - 4, py + 9); ctx.lineTo(cx + 4, py + 9);
        ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(cx, py + plat.h - 4); ctx.lineTo(cx - 4, py + plat.h - 9); ctx.lineTo(cx + 4, py + plat.h - 9);
        ctx.closePath(); ctx.fill();
    }
    
    // Hover emitters ‚Äî pulsing
    const emitAlpha = occupied 
        ? 0.5 + Math.sin(now * 0.006 + plat.bobPhase) * 0.2
        : basePulse * 0.7;
    ctx.fillStyle = `rgba(${accentR}, ${accentG}, ${accentB}, ${emitAlpha})`;
    ctx.shadowColor = `rgba(${accentR}, ${accentG}, ${accentB}, ${occupied ? 0.5 : 0.25})`;
    ctx.shadowBlur = occupied ? 8 : 4;
    const emitterCount = Math.floor(plat.w / 25);
    for (let i = 0; i < emitterCount; i++) {
        const ex = sx + (i + 0.5) * (plat.w / emitterCount);
        ctx.beginPath();
        ctx.arc(ex, py + plat.h + 2, occupied ? 2 : 1.5, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.shadowBlur = 0;
    
    ctx.restore();
}

function drawHealthPickup(hp) {
    if (hp.collected) return;
    const sx = hp.x;
    if (sx < camX - 50 || sx > camX + canvas.width + 50) return;
    const now = Date.now();
    const bob = Math.sin(now * 0.003 + hp.bobPhase) * 4;
    const pulse = 0.6 + Math.sin(now * 0.005) * 0.3;
    const py = hp.y + bob;
    
    ctx.save();
    ctx.translate(sx, py);
    
    // Glow
    ctx.shadowColor = `rgba(0, 255, 120, ${pulse * 0.7})`;
    ctx.shadowBlur = 14 + pulse * 8;
    
    // Crate body
    const cw = 20, ch = 20;
    const cg = ctx.createLinearGradient(-cw/2, -ch/2, cw/2, ch/2);
    cg.addColorStop(0, '#1a3a22');
    cg.addColorStop(0.5, '#0e2a16');
    cg.addColorStop(1, '#081a0e');
    ctx.fillStyle = cg;
    ctx.beginPath();
    ctx.roundRect(-cw/2, -ch/2, cw, ch, 3);
    ctx.fill();
    
    // Edge
    ctx.strokeStyle = `rgba(0, 255, 120, ${0.3 + pulse * 0.2})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(-cw/2, -ch/2, cw, ch, 3);
    ctx.stroke();
    
    // Health cross
    ctx.shadowBlur = 0;
    ctx.fillStyle = `rgba(0, 255, 120, ${0.6 + pulse * 0.3})`;
    ctx.fillRect(-2, -7, 4, 14);
    ctx.fillRect(-7, -2, 14, 4);
    
    ctx.restore();
}

function spawnDrone() {
    const baseX = camX + canvas.width + 100 + Math.random() * 200;
    // Keep drones in the sky - well above ground (canvas.height - 120)
    const minY = 40;
    const maxY = Math.min(canvas.height - 280, 300); // At least 280px above ground, never below 300
    const baseY = minY + Math.random() * Math.max(60, maxY - minY);
    
    drones.push({
        x: baseX,
        y: baseY,
        targetY: baseY,
        width: 60,
        height: 35,
        health: 50 + difficulty * 15,
        maxHealth: 50 + difficulty * 15,
        speed: 1.5 + Math.random() * 0.5, // Slower
        bobPhase: Math.random() * Math.PI * 2,
        lastShot: Date.now(),
        shotRate: 800 + Math.random() * 600 // Fire every 0.8-1.4 seconds
    });
}

function drawDrone(drone) {
    ctx.save();
    ctx.translate(drone.x, drone.y);
    
    const w = drone.width;
    const h = drone.height;
    
    // Shadow below on ground
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath();
    ctx.ellipse(0, 200, w * 0.5, 10, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Main body - VERY DARK BLACK TRIANGLE (no outline)
    ctx.fillStyle = '#010101';  // Nearly pure black
    
    ctx.beginPath();
    ctx.moveTo(0, -h * 0.6);        // Top point
    ctx.lineTo(-w * 0.5, h * 0.4);  // Bottom left
    ctx.lineTo(w * 0.5, h * 0.4);   // Bottom right
    ctx.closePath();
    ctx.fill();
    // NO STROKE - removes vertical lines
    
    // Edge lights - dimmer white
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';  // Reduced from 0.6
    ctx.shadowColor = '#ffffff';
    ctx.shadowBlur = 6;  // Reduced from 8
    
    // Top light
    ctx.beginPath();
    ctx.arc(0, -h * 0.45, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Bottom left light
    ctx.beginPath();
    ctx.arc(-w * 0.4, h * 0.3, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Bottom right light
    ctx.beginPath();
    ctx.arc(w * 0.4, h * 0.3, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // CENTER LIGHT - large bright RED glow
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 25;
    ctx.fillStyle = 'rgba(255, 50, 50, 0.8)';
    ctx.beginPath();
    ctx.arc(0, h * 0.1, 10, 0, Math.PI * 2);
    ctx.fill();
    
    // Inner bright core
    ctx.fillStyle = '#ff4444';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(0, h * 0.1, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Pulsing effect
    const pulse = 0.5 + Math.sin(Date.now() * 0.005 + drone.bobPhase) * 0.3;
    ctx.globalAlpha = pulse;
    ctx.fillStyle = 'rgba(255, 100, 100, 0.5)';
    ctx.beginPath();
    ctx.arc(0, h * 0.1, 15, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    ctx.shadowBlur = 0;
    
    // Health bar
    const hp = drone.health / drone.maxHealth;
    const barW = 40;
    const barH = 4;
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(-barW/2, -h * 0.8, barW, barH);
    ctx.fillStyle = '#ff3333';
    ctx.fillRect(-barW/2, -h * 0.8, barW * hp, barH);
    
    ctx.restore();
}

// === UNDERWATER ZONE SYSTEM ===

function createWaterZone(startX) {
    // Deterministic (seeded) length so the same water edge always maps to the same zone,
    // even if we call this each frame while flying over it.
    const seed = Math.floor(startX / 97.0) * 99991 + 1337;
    let r = Math.sin(seed) * 10000;
    r = r - Math.floor(r); // fract
    const length = WATER_ZONE_LENGTH_MIN + r * (WATER_ZONE_LENGTH_MAX - WATER_ZONE_LENGTH_MIN);
    return { startX, endX: startX + length, length };
}

function spawnWaterEnemy(kind) {
    const groundY = canvas.height - 120;
    const zone = underwaterZone;
    if (!zone) return;
    
    // Spawn enemies ahead of the player (200-600px forward), clamped to pool bounds
    const rampStartX = zone.endX - 300;
    const minX = Math.max(zone.startX + 100, player.x + 200);
    const maxX = Math.min(rampStartX - 50, player.x + 600);
    const baseX = (minX < maxX) ? minX + Math.random() * (maxX - minX) : (zone.startX + zone.endX) / 2;
    
    if (kind === 'torpedo') {
        // Spawn sharks high in the water column (near the underwater surface when submerged)
        const surfRef = isUnderwater ? getUnderwaterTopY() : getWaterSurfaceY();
        waterEnemies.push({
            kind: 'torpedo',
            x: baseX,
            // Very high band: keep them ~near the top when underwater.
            y: (() => { const surf = surfRef; const top = surf + 10; const bottom = surf + 60; return top + Math.random() * (bottom - top); })(),
            targetY: (() => { const surf = surfRef; const top = surf + 10; const bottom = surf + 60; return top + Math.random() * (bottom - top); })(),
            width: 130, height: 28,
            health: 60 + difficulty * 12,
            maxHealth: 60 + difficulty * 12,
            speed: 1.6 + Math.random() * 0.6,
            facingRight: false,
            bobPhase: Math.random() * Math.PI * 2,
            lastShot: 0,
            shotRate: 5200 + Math.random() * 2200,
            chargePhase: 0 // for charge attack
        });
    } else if (kind === 'crab') {
        const poolFloorY = getPoolFloorY();
        waterEnemies.push({
            kind: 'crab',
            x: baseX,
            y: poolFloorY - (8 + Math.random() * 18),
            width: 80, height: 55,
            health: 120 + difficulty * 20,
            maxHealth: 120 + difficulty * 20,
            speed: 1.2 + Math.random() * 0.6,
            facingRight: false,
            legAngle: 0, legDir: 1,
            lastShot: Date.now(),
            shotRate: 2800 + Math.random() * 800,
            lastAttack: Date.now(),
            attackRate: 1500,
            chargeProgress: 0, // 0-1, orb charges up then fires
            isCharging: false,
            chargeStartTime: 0
        });
    }
}

function drawTorpedoDrone(x, y, w, h, facingRight, health, maxHealth) {
    ctx.save();
    ctx.translate(x, y);
    if (!facingRight) ctx.scale(-1, 1);
    
    const now = Date.now();
    const pulse = 0.7 + Math.sin(now * 0.004) * 0.3;
    
    // Subtle mixed glow aura
    ctx.shadowColor = `rgba(120, 60, 200, ${pulse * 0.35})`;
    ctx.shadowBlur = 12;
    
    // Main shark body ‚Äî long sleek dark metal
    const bodyGrad = ctx.createLinearGradient(0, -h * 0.8, 0, h * 0.8);
    bodyGrad.addColorStop(0, '#181e2a');
    bodyGrad.addColorStop(0.35, '#0c1018');
    bodyGrad.addColorStop(0.65, '#0a0d14');
    bodyGrad.addColorStop(1, '#141a25');
    ctx.fillStyle = bodyGrad;
    
    // Elongated shark body path
    ctx.beginPath();
    ctx.moveTo(w * 0.48, 0);
    ctx.quadraticCurveTo(w * 0.38, -h * 0.38, w * 0.12, -h * 0.46);
    ctx.quadraticCurveTo(-w * 0.08, -h * 0.4, -w * 0.28, -h * 0.2);
    ctx.lineTo(-w * 0.46, -h * 0.05);
    ctx.lineTo(-w * 0.46, h * 0.05);
    ctx.lineTo(-w * 0.28, h * 0.2);
    ctx.quadraticCurveTo(-w * 0.08, h * 0.4, w * 0.12, h * 0.46);
    ctx.quadraticCurveTo(w * 0.38, h * 0.38, w * 0.48, 0);
    ctx.closePath();
    ctx.fill();
    
    // Dorsal fin
    ctx.fillStyle = '#121828';
    ctx.beginPath();
    ctx.moveTo(w * 0.02, -h * 0.46);
    ctx.lineTo(w * 0.1, -h * 1.2);
    ctx.lineTo(-w * 0.08, -h * 0.46);
    ctx.closePath();
    ctx.fill();
    
    // Tail fin ‚Äî forked
    ctx.fillStyle = '#101622';
    ctx.beginPath();
    ctx.moveTo(-w * 0.36, -h * 0.15);
    ctx.lineTo(-w * 0.50, -h * 0.65);
    ctx.lineTo(-w * 0.42, 0);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(-w * 0.36, h * 0.15);
    ctx.lineTo(-w * 0.50, h * 0.65);
    ctx.lineTo(-w * 0.42, 0);
    ctx.closePath();
    ctx.fill();
    
    // Pectoral fins
    ctx.fillStyle = '#131828';
    ctx.beginPath();
    ctx.moveTo(w * 0.0, h * 0.38);
    ctx.lineTo(-w * 0.04, h * 0.8);
    ctx.lineTo(-w * 0.12, h * 0.33);
    ctx.closePath();
    ctx.fill();
    
    // Second dorsal
    ctx.fillStyle = '#111625';
    ctx.beginPath();
    ctx.moveTo(-w * 0.18, -h * 0.33);
    ctx.lineTo(-w * 0.12, -h * 0.65);
    ctx.lineTo(-w * 0.24, -h * 0.3);
    ctx.closePath();
    ctx.fill();
    
    ctx.shadowBlur = 0;
    
    // === ROBOTIC PANEL LINES (horizontal) ===
    ctx.strokeStyle = 'rgba(50, 70, 110, 0.25)';
    ctx.lineWidth = 0.8;
    ctx.beginPath();
    ctx.moveTo(w * 0.4, -h * 0.06);
    ctx.lineTo(-w * 0.35, -h * 0.06);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(w * 0.35, h * 0.1);
    ctx.lineTo(-w * 0.3, h * 0.1);
    ctx.stroke();
    
    // === ROBOTIC VERTICAL SEAMS ===
    ctx.strokeStyle = 'rgba(50, 70, 110, 0.2)';
    ctx.lineWidth = 0.7;
    for (let seg = 0; seg < 5; seg++) {
        const sx = w * 0.3 - seg * w * 0.13;
        const segH = h * (0.3 + Math.abs(Math.sin(seg * 0.8)) * 0.15);
        ctx.beginPath();
        ctx.moveTo(sx, -segH);
        ctx.lineTo(sx, segH);
        ctx.stroke();
    }
    
    // === GLOWING HORIZONTAL LINES (red + blue robotic strips) ===
    ctx.globalAlpha = 0.35 * pulse;
    
    // Red glow strip ‚Äî center line
    ctx.strokeStyle = 'rgba(220, 60, 40, 0.7)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(w * 0.44, 0);
    ctx.lineTo(-w * 0.4, 0);
    ctx.stroke();
    
    // Blue glow strips ‚Äî above and below
    ctx.strokeStyle = 'rgba(60, 140, 240, 0.5)';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(w * 0.38, -h * 0.18);
    ctx.lineTo(-w * 0.28, -h * 0.12);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(w * 0.38, h * 0.18);
    ctx.lineTo(-w * 0.28, h * 0.12);
    ctx.stroke();
    
    // === GLOWING VERTICAL SEGMENTS (robotic tech) ===
    for (let seg = 0; seg < 3; seg++) {
        const sx = w * 0.2 - seg * w * 0.18;
        const segH = h * (0.2 + seg * 0.05);
        ctx.strokeStyle = `rgba(100, 180, 255, ${0.3 + seg * 0.1})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(sx, -segH);
        ctx.lineTo(sx, segH);
        ctx.stroke();
    }
    ctx.globalAlpha = 1;
    
    // Gill slits
    for (let g = 0; g < 3; g++) {
        const gx = w * 0.2 - g * w * 0.05;
        ctx.strokeStyle = 'rgba(40, 60, 100, 0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(gx, -h * 0.25);
        ctx.lineTo(gx - w*0.01, -h * 0.05);
        ctx.stroke();
    }
    
    // Red sensor eye
    ctx.shadowColor = `rgba(255, 50, 30, ${pulse})`;
    ctx.shadowBlur = 10;
    ctx.fillStyle = `rgba(255, 60, 30, ${0.7 + pulse * 0.3})`;
    ctx.beginPath();
    ctx.ellipse(w * 0.32, -h * 0.12, 4, 2.5, -0.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Health bar
    const hp = health / maxHealth;
    const barW = 70;
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(-barW/2, -h * 1.5, barW, 4);
    ctx.fillStyle = '#ff3333';
    ctx.fillRect(-barW/2, -h * 1.5, barW * hp, 4);
    
    ctx.restore();
}

function drawCrabWalker(x, y, w, h, facingRight, legAngle, health, maxHealth, chargeProgress) {
    // UNDERWATER GROUND STRIKER ‚Äî menacing biped with "head-cannon" (no head),
    // designed to match the game's cold steel + neon tech vibe.
    ctx.save();
    ctx.translate(x, y);
    if (!facingRight) ctx.scale(-1, 1);

    const now = Date.now();
    const s = w / 80;
    const charge = Math.max(0, Math.min(1, chargeProgress || 0));

    // Palette (matches other bots)
    const steelDark = '#0a0e16';
    const steelMid  = '#162131';
    const steelLite = '#2a3a52';
    const edge      = 'rgba(210,235,255,0.10)';

    // Subtle underwater bob + intimidation pulse
    const bob = Math.sin(now * 0.0026 + x * 0.01) * 1.3 * s;
    ctx.translate(0, -bob);

    // Ground shadow
    ctx.fillStyle = 'rgba(0,0,0,0.22)';
    ctx.beginPath();
    ctx.ellipse(0, 28*s, 26*s, 6*s, 0, 0, Math.PI*2);
    ctx.fill();

    // ==== LEGS (hydraulic, sharp stance) ====
    const step = (legAngle || 0) * 0.9;
    const hipY = 8*s;
    const legX = 14*s;
    for (let side = -1; side <= 1; side += 2) {
        ctx.save();
        ctx.translate(side * legX, hipY);
        ctx.rotate(step * side * 0.35);

        // Upper leg
        const lg = ctx.createLinearGradient(-8*s, 0, 10*s, 0);
        lg.addColorStop(0, steelDark);
        lg.addColorStop(0.5, steelMid);
        lg.addColorStop(1, steelLite);
        ctx.fillStyle = lg;
        ctx.beginPath();
        ctx.roundRect(-6*s, 0, 12*s, 18*s, 4*s);
        ctx.fill();

        // Knee joint
        ctx.fillStyle = steelLite;
        ctx.beginPath();
        ctx.arc(0, 19*s, 4.8*s, 0, Math.PI*2);
        ctx.fill();

        // Lower leg
        ctx.fillStyle = lg;
        ctx.beginPath();
        ctx.roundRect(-5.2*s, 19*s, 10.4*s, 18*s, 4*s);
        ctx.fill();

        // Foot (claw plate)
        ctx.fillStyle = steelDark;
        ctx.beginPath();
        ctx.roundRect(-10*s, 35*s, 20*s, 7.5*s, 4*s);
        ctx.fill();

        // Razor toe
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        ctx.beginPath();
        ctx.moveTo(6*s, 35*s);
        ctx.lineTo(12*s, 38*s);
        ctx.lineTo(6*s, 42.5*s);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    // ==== TORSO (armored wedge) ====
    const torsoW = 44*s;
    const torsoH = 28*s;
    const torsoY = -18*s;

    // Back plate / spine
    ctx.fillStyle = steelMid;
    ctx.beginPath();
    ctx.roundRect(-torsoW*0.55, torsoY-6*s, torsoW*1.1, 10*s, 6*s);
    ctx.fill();

    // Main torso
    const tg = ctx.createLinearGradient(-torsoW/2, torsoY, torsoW/2, torsoY);
    tg.addColorStop(0, steelDark);
    tg.addColorStop(0.5, steelMid);
    tg.addColorStop(1, steelLite);
    ctx.fillStyle = tg;
    ctx.beginPath();
    ctx.moveTo(-torsoW/2, torsoY + 6*s);
    ctx.lineTo(-torsoW*0.30, torsoY - torsoH/2);
    ctx.lineTo(torsoW*0.30, torsoY - torsoH/2);
    ctx.lineTo(torsoW/2, torsoY + 6*s);
    ctx.lineTo(torsoW*0.32, torsoY + torsoH/2);
    ctx.lineTo(-torsoW*0.32, torsoY + torsoH/2);
    ctx.closePath();
    ctx.fill();

    // Torso panel highlight
    ctx.strokeStyle = edge;
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // ==== "HEAD" CANNON (no head) ====
    // Cannon sits where a head would be; lightning originates from its muzzle.
    const cannonX = 22*s;
    const cannonY = torsoY - 10*s;

    // Neck mount
    ctx.fillStyle = steelDark;
    ctx.beginPath();
    ctx.roundRect(-6*s, cannonY + 10*s, 12*s, 10*s, 4*s);
    ctx.fill();

    // Cannon housing
    const cg = ctx.createLinearGradient(0, 0, 32*s, 0);
    cg.addColorStop(0, steelMid);
    cg.addColorStop(0.6, steelLite);
    cg.addColorStop(1, steelDark);
    ctx.fillStyle = cg;
    ctx.beginPath();
    ctx.roundRect(0, cannonY, 34*s, 14*s, 6*s);
    ctx.fill();

    // Barrel
    ctx.fillStyle = '#070b12';
    ctx.beginPath();
    ctx.roundRect(26*s, cannonY + 4*s, 18*s, 6*s, 3*s);
    ctx.fill();

    // Muzzle ring
    ctx.fillStyle = steelLite;
    ctx.beginPath();
    ctx.arc(44*s, cannonY + 7*s, 4*s, 0, Math.PI*2);
    ctx.fill();

    // Charging core (red) in cannon throat
    ctx.save();
    const glow = 0.35 + charge * 0.9;
    ctx.shadowColor = `rgba(255,50,30,${glow})`;
    ctx.shadowBlur = 10 + charge * 22;
    ctx.fillStyle = `rgba(255,60,35,${0.35 + charge * 0.55})`;
    ctx.beginPath();
    ctx.arc(22*s, cannonY + 7*s, (2.6 + charge*3.6)*s, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Small menace "eyes" as red slits on torso (not a head)
    ctx.save();
    ctx.shadowColor = 'rgba(255,60,35,0.85)';
    ctx.shadowBlur = 10;
    ctx.fillStyle = 'rgba(255,60,35,0.65)';
    ctx.beginPath();
    ctx.roundRect(-10*s, torsoY - 2*s, 8*s, 2.8*s, 2*s);
    ctx.roundRect(2*s, torsoY - 2*s, 8*s, 2.8*s, 2*s);
    ctx.fill();
    ctx.restore();

    // Health bar (small, understated)
    const hp = Math.max(0, health / Math.max(1, maxHealth));
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(-24*s, torsoY - 26*s, 48*s, 4*s);
    ctx.fillStyle = 'rgba(255, 30, 30, 0.90)';
    ctx.fillRect(-24*s, torsoY - 26*s, 48*s * hp, 4*s);

    ctx.restore();
}

function drawUnderwaterBackground() {
    const now = Date.now();
    const poolFloorY = canvas.height - 30; // floor at very bottom of screen
    
    // Single seamless dark teal/green chemical fill ‚Äî NO visible bands
    const chemGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    chemGrad.addColorStop(0, '#010a0a');
    chemGrad.addColorStop(0.15, '#021210');
    chemGrad.addColorStop(0.4, '#031510');
    chemGrad.addColorStop(0.7, '#021510');
    chemGrad.addColorStop(0.9, '#011210');
    chemGrad.addColorStop(1, '#010e0a');
    ctx.fillStyle = chemGrad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Faint teal light rays from surface
    ctx.save();
    for (let i = 0; i < 4; i++) {
        const rayX = (i * 260 + now * 0.008 + camX * 0.04) % (canvas.width + 300) - 150;
        const rayW = 35 + Math.sin(now * 0.001 + i) * 12;
        const rayGrad = ctx.createLinearGradient(rayX, 0, rayX + rayW, canvas.height * 0.6);
        rayGrad.addColorStop(0, 'rgba(40, 160, 120, 0.06)');
        rayGrad.addColorStop(0.4, 'rgba(30, 120, 90, 0.03)');
        rayGrad.addColorStop(1, 'rgba(15, 60, 50, 0)');
        ctx.fillStyle = rayGrad;
        ctx.beginPath();
        ctx.moveTo(rayX, 0);
        ctx.lineTo(rayX + rayW, 0);
        ctx.lineTo(rayX + rayW + 50, canvas.height * 0.6);
        ctx.lineTo(rayX - 30, canvas.height * 0.6);
        ctx.closePath();
        ctx.fill();
    }
    ctx.restore();
    
    // Chemical sediment particles floating
    ctx.save();
    for (let i = 0; i < 40; i++) {
        const px = (i * 97.3 + now * 0.005 * (0.3 + (i % 5) * 0.1)) % canvas.width;
        const py = (i * 41.7 + now * 0.002 * (0.8 + (i % 3) * 0.2)) % canvas.height;
        const sz = 0.5 + (i % 6) * 0.2;
        ctx.globalAlpha = 0.08 + Math.sin(now * 0.002 + i) * 0.04;
        ctx.fillStyle = (i % 3 === 0) ? '#4a8a6a' : '#2a5a4a';
        ctx.beginPath();
        ctx.arc(px, py, sz, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
    ctx.restore();
    
    // Subtle corroded metal floor ‚Äî blended smoothly into liquid at very bottom
    ctx.save();
    const plateOffset = -((camX * 0.3) % 100);
    
    // Very subtle floor fade
    ctx.globalAlpha = 0.25;
    const floorGrad = ctx.createLinearGradient(0, poolFloorY - 30, 0, canvas.height);
    floorGrad.addColorStop(0, 'rgba(10, 18, 16, 0)');
    floorGrad.addColorStop(0.3, 'rgba(8, 14, 10, 0.4)');
    floorGrad.addColorStop(1, 'rgba(4, 8, 6, 0.6)');
    ctx.fillStyle = floorGrad;
    ctx.fillRect(0, poolFloorY - 30, canvas.width, canvas.height - poolFloorY + 30);
    
    // Faint plate seams
    ctx.strokeStyle = '#0e1a14';
    ctx.lineWidth = 1;
    for (let px = plateOffset; px < canvas.width + 100; px += 100) {
        ctx.globalAlpha = 0.12;
        ctx.beginPath();
        ctx.moveTo(px, poolFloorY);
        ctx.lineTo(px, canvas.height);
        ctx.stroke();
    }
    
    // Corrosion patches
    ctx.globalAlpha = 0.08;
    for (let i = 0; i < 8; i++) {
        const cx = (i * 137.3 + plateOffset * 0.7) % canvas.width;
        const cy = poolFloorY + 5 + (i % 3) * 6;
        const cw = 15 + (i % 5) * 8;
        const ch = 3 + (i % 3) * 2;
        ctx.fillStyle = (i % 2 === 0) ? '#1a3020' : '#0a1810';
        ctx.beginPath();
        ctx.ellipse(cx, cy, cw/2, ch/2, 0, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.restore();
    
    // Chemical haze near floor (very subtle)
    ctx.save();
    ctx.globalAlpha = 0.03;
    const hazeGrad = ctx.createLinearGradient(0, poolFloorY - 50, 0, poolFloorY);
    hazeGrad.addColorStop(0, 'rgba(40, 120, 80, 0)');
    hazeGrad.addColorStop(1, 'rgba(40, 120, 80, 1)');
    ctx.fillStyle = hazeGrad;
    ctx.fillRect(0, poolFloorY - 50, canvas.width, 55);
    ctx.restore();
}

function drawWaterEdge(edgeX) {
    // Hard shoreline edge: water meets the moon ground the same way on BOTH sides (no diagonal/teal wedge)
    const waterSurfaceY = isUnderwater ? getUnderwaterTopY() : getWaterSurfaceY();
    const poolBottom = canvas.height;
    const now = Date.now();
    const glow = 0.6 + Math.sin(now * 0.003) * 0.2;

    ctx.save();

    const poolExtend = canvas.width + 700;

    // === CHEMICAL LIQUID (starts exactly at edgeX; no fade into land) ===
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#021a1a';
    ctx.fillRect(edgeX, waterSurfaceY, poolExtend, poolBottom - waterSurfaceY);

    // Subtle "back wall" hint at the pool entry when underwater (helps depth perception)
    if (isUnderwater) {
        const wallW = 10;
        const wallGrad = ctx.createLinearGradient(edgeX, 0, edgeX + wallW, 0);
        wallGrad.addColorStop(0, 'rgba(220, 255, 245, 0.10)');
        wallGrad.addColorStop(0.5, 'rgba(0, 0, 0, 0)');
        wallGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = wallGrad;
        ctx.fillRect(edgeX, waterSurfaceY, wallW, poolBottom - waterSurfaceY);
    }

    const liqGrad = ctx.createLinearGradient(0, waterSurfaceY, 0, poolBottom);
    liqGrad.addColorStop(0, `rgba(0, 180, 140, ${0.85 * glow})`);
    liqGrad.addColorStop(0.12, `rgba(0, 140, 120, ${0.70 * glow})`);
    liqGrad.addColorStop(0.45, `rgba(0, 80, 80, ${0.50 * glow})`);
    liqGrad.addColorStop(1, `rgba(0, 30, 40, ${0.42 * glow})`);
    ctx.fillStyle = liqGrad;
    ctx.fillRect(edgeX, waterSurfaceY, poolExtend, poolBottom - waterSurfaceY);

    // === LAND-SIDE WALL PANEL (entry side) ===
    // When you first drop in, show a hint of the ground wall behind you so the entrance doesn't look like open water.
    if (isUnderwater) {
        const wallW = 220;
        const landWallGrad = ctx.createLinearGradient(edgeX - wallW, 0, edgeX, 0);
        landWallGrad.addColorStop(0, 'rgba(37, 37, 48, 0.95)');
        landWallGrad.addColorStop(0.65, 'rgba(37, 37, 48, 0.75)');
        landWallGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.globalAlpha = 1;
        ctx.fillStyle = landWallGrad;
        ctx.fillRect(edgeX - wallW, waterSurfaceY, wallW, poolBottom - waterSurfaceY);

        // subtle seams
        ctx.globalAlpha = 0.22;
        ctx.strokeStyle = 'rgba(0,0,0,0.55)';
        ctx.lineWidth = 2;
        for (let i = 0; i < 7; i++) {
            const yy = waterSurfaceY + 40 + i * 42;
            ctx.beginPath();
            ctx.moveTo(edgeX - wallW + 12, yy);
            ctx.lineTo(edgeX - 10, yy);
            ctx.stroke();
        }
    }

    // === PIT WALL / CUT EDGE (matches the far-side look) ===
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = '#252530';
    ctx.fillRect(edgeX - 4, waterSurfaceY, 8, poolBottom - waterSurfaceY);

    // === SURFACE RIPPLE LINE (only on the water side) ===
    ctx.globalAlpha = 0.5;
    ctx.strokeStyle = `rgba(0, 255, 220, ${0.22 * glow})`;
    ctx.lineWidth = 1;
    for (let r = 0; r < 3; r++) {
        const y = waterSurfaceY + 2 + r * 4 + Math.sin(now * 0.002 + r) * 1.5;
        ctx.beginPath();
        for (let x = edgeX + 6; x <= edgeX + 170; x += 18) {
            const yy = y + Math.sin((x * 0.02) + now * 0.004 + r) * 2;
            if (x === edgeX + 6) ctx.moveTo(x, yy);
            else ctx.lineTo(x, yy);
        }
        ctx.stroke();
    }

    // Surface glow (water side only)
    ctx.globalAlpha = 0.08 * glow;
    const surfGlow = ctx.createLinearGradient(0, waterSurfaceY - 30, 0, waterSurfaceY);
    surfGlow.addColorStop(0, 'rgba(0, 255, 180, 0)');
    surfGlow.addColorStop(1, 'rgba(0, 255, 180, 1)');
    ctx.fillStyle = surfGlow;
    ctx.fillRect(edgeX, waterSurfaceY - 30, poolExtend, 32);

    // Edge foam (small cap at the cut)
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = `rgba(0, 255, 200, ${0.2 * glow})`;
    ctx.fillRect(edgeX, waterSurfaceY - 1, 6, 4);

    // Bubbles rising near the edge
    ctx.globalAlpha = 1;
    for (let i = 0; i < 6; i++) {
        const bx = edgeX + 30 + (i * 137.3 + now * 0.015) % 260;
        const by = waterSurfaceY - 3 - ((now * 0.02 + i * 97) % 22);
        const bSize = 1.5 + (i % 3);
        const bAlpha = 1 - ((now * 0.02 + i * 97) % 22) / 22;
        ctx.globalAlpha = bAlpha * 0.25;
        ctx.strokeStyle = 'rgba(100, 255, 200, 0.5)';
        ctx.lineWidth = 0.8;
        ctx.beginPath();
        ctx.arc(bx, by, bSize, 0, Math.PI * 2);
        ctx.stroke();
    }

    ctx.restore();
}


function drawWaterZone(startX, endX) {
    // Chemical pool pit ‚Äî when viewed from above the surface
    const groundSurfaceY = getWaterSurfaceY();
    const poolBottom = canvas.height; // fills to screen bottom
    const now = Date.now();
    const glow = 0.6 + Math.sin(now * 0.003) * 0.2;
    const w = Math.max(0, endX - startX);
    if (w <= 0) return;

    ctx.save();
    
    // === CHEMICAL LIQUID FILL (fills the pit from surface down) ===
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#021a1a';
    ctx.fillRect(startX, groundSurfaceY, w, poolBottom - groundSurfaceY);
    
    // Chemical gradient overlay
    const liqGrad = ctx.createLinearGradient(0, groundSurfaceY, 0, poolBottom);
    liqGrad.addColorStop(0, `rgba(0, 180, 140, ${0.8 * glow})`);
    liqGrad.addColorStop(0.1, `rgba(0, 150, 120, ${0.5 * glow})`);
    liqGrad.addColorStop(0.4, `rgba(0, 80, 80, ${0.3 * glow})`);
    liqGrad.addColorStop(1, `rgba(0, 30, 40, ${0.2 * glow})`);
    ctx.fillStyle = liqGrad;
    ctx.fillRect(startX, groundSurfaceY, w, poolBottom - groundSurfaceY);
    
    // Pit edges (dark walls where ground drops away)
    ctx.fillStyle = '#252530';
    ctx.globalAlpha = 0.7;
    ctx.fillRect(startX - 4, groundSurfaceY, 8, poolBottom - groundSurfaceY);

// === ENTRY WALL (straight vertical drop ‚Äî player falls in, no incline) ===
ctx.save();
ctx.globalAlpha = 1;
// Vertical wall face on entry side (thin metal strip going straight down)
const entryWallMetal = ctx.createLinearGradient(startX - 12, 0, startX + 4, 0);
entryWallMetal.addColorStop(0, '#2b2b36');
entryWallMetal.addColorStop(0.5, '#1e1e28');
entryWallMetal.addColorStop(1, '#151520');
ctx.fillStyle = entryWallMetal;
ctx.fillRect(startX - 8, groundSurfaceY, 12, poolBottom - groundSurfaceY);

// Horizontal seams on wall face
ctx.strokeStyle = '#0f0f18';
ctx.lineWidth = 1.5;
ctx.globalAlpha = 0.30;
for (let i = 0; i < 8; i++) {
    const y = groundSurfaceY + 20 + i * 28;
    ctx.beginPath();
    ctx.moveTo(startX - 8, y);
    ctx.lineTo(startX + 4, y);
    ctx.stroke();
}

// Rivets along wall edge
ctx.globalAlpha = 0.55;
ctx.fillStyle = '#0a0a12';
for (let i = 0; i < 6; i++) {
    const y = groundSurfaceY + 30 + i * 36;
    ctx.beginPath();
    ctx.arc(startX - 2, y, 2.5, 0, Math.PI * 2);
    ctx.fill();
}

// Subtle highlight on the lip edge (where ground meets the drop)
ctx.globalAlpha = 0.15;
ctx.fillStyle = '#6a7a8a';
ctx.fillRect(startX - 10, groundSurfaceY - 2, 14, 3);

ctx.restore();
    
    // Surface ripples at the top of the liquid
    ctx.globalAlpha = 0.5;
    ctx.strokeStyle = `rgba(0, 255, 220, ${0.22 * glow})`;
    ctx.lineWidth = 1;
    for (let r = 0; r < 3; r++) {
        const y = groundSurfaceY + 2 + r * 4 + Math.sin(now * 0.002 + r) * 1.5;
        ctx.beginPath();
        for (let x = startX + 5; x <= endX - 5; x += 18) {
            const yy = y + Math.sin((x * 0.02) + now * 0.004 + r) * 2;
            if (x <= startX + 5) ctx.moveTo(x, yy);
            else ctx.lineTo(x, yy);
        }
        ctx.stroke();
    }
    
    // Edge glow (top of liquid surface)
    ctx.globalAlpha = 0.08 * glow;
    const surfGlow = ctx.createLinearGradient(0, groundSurfaceY - 30, 0, groundSurfaceY);
    surfGlow.addColorStop(0, 'rgba(0, 255, 180, 0)');
    surfGlow.addColorStop(1, 'rgba(0, 255, 180, 1)');
    ctx.fillStyle = surfGlow;
    ctx.fillRect(startX, groundSurfaceY - 30, w, 32);
    
    // Edge foam
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = `rgba(0, 255, 200, ${0.2 * glow})`;
    ctx.fillRect(startX, groundSurfaceY - 1, 6, 4);
    ctx.fillRect(endX - 6, groundSurfaceY - 1, 6, 4);
    
    // === EXIT RAMP (last 300px) ===
    // Make the ramp blend with the SAME moon-metal ground (grid + rivets), not a flat black slab.
    const rampStartX = endX - 300;

    // Ramp polygon (triangle) we will clip to.
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(rampStartX, poolBottom);
    ctx.lineTo(endX, groundSurfaceY);
    ctx.lineTo(endX, poolBottom);
    ctx.closePath();
    ctx.clip();

    // Base metal ground gradient (matches surface ground strip)
    const rampMetal = ctx.createLinearGradient(0, canvas.height - 90, 0, canvas.height);
    rampMetal.addColorStop(0, '#2b2b36');
    rampMetal.addColorStop(0.5, '#232330');
    rampMetal.addColorStop(1, '#1a1a24');
    ctx.globalAlpha = 1;
    ctx.fillStyle = rampMetal;
    // Overdraw generously; clipping keeps it in the ramp.
    ctx.fillRect(rampStartX - 80, canvas.height - 120, 460, 220);

    // Panel seams (same look as moon ground)
    ctx.save();
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 2;

    // Horizontal seams
    for (let i = 0; i < 6; i++) {
        const y = canvas.height - 90 + i * 15;
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.moveTo(rampStartX - 120, y);
        ctx.lineTo(endX + 120, y);
        ctx.stroke();
    }

    // Vertical seams (keep in-world rhythm using camX so it matches ground)
    const gridOffset = -((camX % 120 + 120) % 120);
    for (let x = gridOffset; x < canvas.width + 120; x += 120) {
        ctx.globalAlpha = 0.25;
        ctx.strokeStyle = '#151515';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x, canvas.height - 90);
        ctx.lineTo(canvas.width / 2 + (x - canvas.width / 2) * 1.5, canvas.height);
        ctx.stroke();
    }

    // Rivets/bolts
    ctx.fillStyle = '#0a0a0a';
    for (let x = gridOffset; x < canvas.width + 120; x += 60) {
        for (let i = 0; i < 4; i++) {
            const y = canvas.height - 85 + i * 20;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#2a2a2a';
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            ctx.arc(x - 1, y - 1, 1.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#0a0a0a';
        }
    }

    ctx.restore();

    // Ramp slope line (very subtle, matches ground tone)
    ctx.globalAlpha = 1;
    ctx.strokeStyle = 'rgba(220, 220, 230, 0.06)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(rampStartX, poolBottom);
    ctx.lineTo(endX, groundSurfaceY);
    ctx.stroke();

    // Metal grip lines on ramp (subtle)
    ctx.strokeStyle = 'rgba(220, 220, 230, 0.035)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 8; i++) {
        const t = (i + 1) / 9;
        const rx = rampStartX + 300 * t;
        const ry = poolBottom + (groundSurfaceY - poolBottom) * t;
        ctx.beginPath();
        ctx.moveTo(rx - 10, ry + 5);
        ctx.lineTo(rx + 10, ry - 5);
        ctx.stroke();
    }

    ctx.restore();
}

function updateWaterBubbles() {
    if (!isUnderwater) { waterBubbles = []; return; }
    
    // Spawn ambient bubbles
    if (Math.random() < 0.15) {
        waterBubbles.push({
            x: camX + Math.random() * canvas.width,
            y: canvas.height - 100 - Math.random() * 30,
            size: 1.5 + Math.random() * 4,
            vy: -0.4 - Math.random() * 0.8,
            vx: (Math.random() - 0.5) * 0.3,
            life: 1.0,
            decay: 0.004 + Math.random() * 0.004
        });
    }
    
    // Player bubbles from visor
    if (Math.random() < 0.2) {
        waterBubbles.push({
            x: player.x + (Math.random() - 0.5) * 20,
            y: player.y - player.height * 0.6,
            size: 1 + Math.random() * 2.5,
            vy: -0.8 - Math.random() * 1.2,
            vx: (Math.random() - 0.5) * 0.5,
            life: 1.0,
            decay: 0.01 + Math.random() * 0.008
        });
    }
    
    for (let i = waterBubbles.length - 1; i >= 0; i--) {
        const b = waterBubbles[i];
        b.y += b.vy;
        b.x += b.vx;
        b.life -= b.decay;
        if (b.life <= 0 || b.y < 0) waterBubbles.splice(i, 1);
    }
}

function drawWaterBubbles() {
    waterBubbles.forEach(b => {
        ctx.save();
        ctx.globalAlpha = b.life * 0.5;
        ctx.strokeStyle = `rgba(80, 220, 160, ${b.life * 0.6})`;
        ctx.lineWidth = 0.8;
        ctx.fillStyle = `rgba(60, 200, 140, ${b.life * 0.1})`;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = `rgba(150, 255, 220, ${b.life * 0.4})`;
        ctx.beginPath();
        ctx.arc(b.x - b.size * 0.3, b.y - b.size * 0.3, b.size * 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    });
}


function fireRocket(fromX, fromY, toX, toY) {
    const angle = Math.atan2(toY - fromY, toX - fromX);
    const speed = 14;
    rockets.push({
        x: fromX, y: fromY,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        angle: angle,
        spin: 0,
        spinSpeed: 0,
        life: 180
    });
    AudioSystem.playRocketLaunch();

    // Launch FX: minimal thin smoke only (no bubble blasts)
    smokeTrails.push({
        x: fromX - Math.cos(angle) * 10,
        y: fromY - Math.sin(angle) * 10,
        size: 8 + Math.random() * 6,
        life: 1,
        color: 'rgba(210,220,235,0.22)',
        vx: -Math.cos(angle) * 0.9 + (Math.random()*0.4-0.2),
        vy: -Math.sin(angle) * 0.9 + (Math.random()*0.4-0.2)
    });smokeTrails.push({
        x: fromX - Math.cos(angle) * 10,
        y: fromY - Math.sin(angle) * 10,
        size: 10 + Math.random() * 10,
        life: 1,
        color: 'rgba(210,220,235,0.30)',
        vx: -Math.cos(angle) * 1.2 + (Math.random()*0.8-0.4),
        vy: -Math.sin(angle) * 1.2 + (Math.random()*0.8-0.4)
    });
}


function fireRocketFromPlayerOnce() {
    if (!gameRunning) return;

    // D-pad movement override (hold-to-move)
    updateMovementFromDpad();
    const now = Date.now();

    // Failsafe: if firing is held but something got stuck, unlock after 600ms
    if (isFiring && lastFireTime > 0 && (now - lastFireTime) > 600) {
        lastFireTime = -1e9;
    }
    
    // Additional safeguard: cap rockets array to prevent memory issues
    if (rockets.length > 50) {
        rockets = rockets.slice(-40);
    }

    if (now - lastFireTime <= fireRate) return;

    // Aim is stored in screen coords; convert to world coords for projectiles.
    let aimXw = (Number.isFinite(aimX) ? aimX : mouseX) + camX;
    let aimYw = (Number.isFinite(aimY) ? aimY : mouseY);

    // Harden against rare NaN / Infinity input states (trackpads, pointer cancel, flight toggles).
    if (!Number.isFinite(aimXw) || !Number.isFinite(aimYw)) {
        aimXw = player.x + (player.facingRight ? 420 : -420);
        aimYw = player.y - player.height * 0.35;
    }

    // Fire from the actual GUN BARREL (top barrel) - matches where gun visually points
    const torsoW = player.width * 0.62;
    const torsoY = -player.height * 0.34;
    
    // Shoulder position in LOCAL player coordinates
    const shoulderX = torsoW/2 - 10;
    const shoulderY = torsoY + 18;
    
    // EXTENDED barrel muzzle position in rotated arm space
    const muzzleX = 132;  // Extended barrel tip
    const muzzleY = 0;   // Single barrel center
    
    // Use arm angle directly - sprite flip handles left/right orientation
    const clampedArmAngle = Math.max(-1.57, Math.min(1.57, player.armAngle));
    
    // Apply rotation to muzzle position (standard 2D rotation)
    const rotatedMuzzleX = muzzleX * Math.cos(clampedArmAngle) - muzzleY * Math.sin(clampedArmAngle);
    const rotatedMuzzleY = muzzleX * Math.sin(clampedArmAngle) + muzzleY * Math.cos(clampedArmAngle);
    
    // Add shoulder offset to get position relative to player origin
    const gunLocalX = shoulderX + rotatedMuzzleX;
    const gunLocalY = shoulderY + rotatedMuzzleY;
    
    // Convert to world coordinates
    const gunX = player.x + (player.facingRight ? gunLocalX : -gunLocalX);
    const gunY = player.y + gunLocalY;

    // Fire in the EXACT direction the gun is visually pointing
    const fireDistance = 2000;
    let targetX, targetY;
    
    if (player.facingRight) {
        targetX = gunX + Math.cos(clampedArmAngle) * fireDistance;
        targetY = gunY + Math.sin(clampedArmAngle) * fireDistance;
    } else {
        targetX = gunX - Math.cos(clampedArmAngle) * fireDistance;
        targetY = gunY + Math.sin(clampedArmAngle) * fireDistance;
    }

    fireRocket(gunX, gunY, targetX, targetY);
    lastFireTime = now;
}


function activateFlight() {
    if (flyCharge >= FLY_CHARGE_MAX && !player.isFlying) {
        player.isFlying = true;
        player._onPlatform = null;
        player.flyEndTime = Date.now() + FLY_DURATION;
        flyCharge = 0;
        updateHUD();
        createExplosion(player.x, player.y + 40, '#00aaff', 40, true);
        AudioSystem.playJetpack();
    }
}



function activateShield() {
    const now = Date.now();
    if (flyCharge >= FLY_CHARGE_MAX && now > player.shieldUntil && !player.isFlying) {
        player.shieldUntil = now + SHIELD_DURATION;
        player.shieldHits = SHIELD_HITS;
        flyCharge = 0;
        updateHUD();
        // Shield pop (visual only)
        createExplosion(player.x, player.y - 30, '#66aaff', 18);
    }
}
function update(deltaTime) {
    if (paused) return;
    if (!gameRunning) return;
    
    // Process D-pad input for movement
    updateMovementFromDpad();
    
    // FIRING SAFEGUARD: If isFiring has been true for too long without actually firing,
    // something is stuck - reset it
    // FIRING SAFEGUARD: only auto-clear if we've actually fired at least once.
    if (isFiring && lastFireTime > 0 && Date.now() - lastFireTime > 2000) {
        isFiring = false;
    }
    
    difficulty = 1 + Math.floor(kills / 5) * 0.25;
    
    const newWave = Math.floor(kills / 8) + 1;
    if (newWave > wave) { wave = newWave; showWaveAnnouncement('‚ö† WAVE ' + wave + ' ‚ö†'); }
    
    // Spawn only when the player pushes into new territory (exploration)
    // If we're above a water zone (flying over), treat it as "no-land-spawn" territory
const isOverWaterSurface = (underwaterZone && player.x >= underwaterZone.startX && player.x < underwaterZone.endX && !isUnderwater);

// Cull any surface enemies/drones that would appear to "walk on water"
if (isOverWaterSurface && underwaterZone) {
    const sx0 = underwaterZone.startX - 140;
    const sx1 = underwaterZone.endX + 140;
    enemies = enemies.filter(e => e.x < sx0 || e.x > sx1);
    drones = drones.filter(d => d.x < sx0 || d.x > sx1);
}

if (!isUnderwater && !isOverWaterSurface && player.x > nextEncounterX) {
        const count = 2 + Math.floor(Math.random()*2) + Math.floor(difficulty*0.25);
        for (let i=0;i<count;i++) spawnEnemy();
        // Spawn drones occasionally (30% chance per encounter)
        if (Math.random() < 0.3) {
            const droneCount = 1 + Math.floor(Math.random() * 2);
            for (let i = 0; i < droneCount; i++) spawnDrone();
        }
        nextEncounterX += 650 + Math.random()*650;
    }
    
    // Spawn platforms and obstacles as player progresses (not in water)
    if (!isUnderwater && !isOverWaterSurface && player.x > nextPlatformX - 600) {
        // Skip if next platform would be in or near water zone (existing or future)
        const wzStart = underwaterZone ? underwaterZone.startX : nextWaterEdgeX;
        const wzEnd = underwaterZone ? underwaterZone.endX : (nextWaterEdgeX + WATER_ZONE_LENGTH_MAX);
        const inWater = nextPlatformX >= wzStart - 300 && nextPlatformX <= wzEnd + 300;
        if (!inWater) {
            spawnPlatformsAndObstacles();
        } else {
            nextPlatformX = wzEnd + 400; // skip past water entirely
        }
    }
    
    // Cull far-behind platforms/pickups + remove any inside water zone (existing or future)
    const cullX = camX - 400;
    const wzStart = underwaterZone ? underwaterZone.startX : nextWaterEdgeX;
    const wzEnd = underwaterZone ? underwaterZone.endX : (nextWaterEdgeX + WATER_ZONE_LENGTH_MAX);
    techPlatforms = techPlatforms.filter(p => {
        if (p.x + p.w < cullX) return false;
        if (p.x > wzStart - 200 && p.x < wzEnd + 200) return false;
        return true;
    });
    healthPickups = healthPickups.filter(hp => {
        if (hp.collected || hp.x < cullX) return false;
        if (hp.x > wzStart - 200 && hp.x < wzEnd + 200) return false;
        return true;
    });
    
    // === SINGLE SPECIAL WATER ZONE (ONE-OFF EVENT) ===
    // We create exactly ONE water zone in the whole run (a special occurrence).
    // Water behaves like real water: you can rocket straight UP to be ABOVE the surface,
    // and drop back down to re-enter the water while still over the zone.

    // Lazily create the zone when the player first reaches the edge (whether flying or grounded)
    if (!waterZoneUsed && !underwaterZone && player.x >= nextWaterEdgeX) {
        underwaterZone = createWaterZone(nextWaterEdgeX);
        waterZoneUsed = true;
        // Clear surface enemies right at the shoreline
        enemies = [];
        drones = [];
        // Spawn a power-up barrel somewhere in the middle of the pool
        const barrelX = underwaterZone.startX + (underwaterZone.endX - underwaterZone.startX) * (0.3 + Math.random() * 0.35);
        waterBarrel = { x: barrelX, y: getPoolFloorY() - 20, collected: false };
        // Record entry time ‚Äî enemies will spawn after a grace period
        waterEntryTime = Date.now();
        // Position player AT the water surface so they visibly float down
        if (!player.isFlying) {
            player.y = getWaterSurfaceY() - 70; // start ABOVE the water surface line
            isUnderwater = true; // force underwater immediately
            showWaveAnnouncement('‚ö† VISOR LIGHT ON ‚Äî BRACE FOR CHEMICAL BATH ‚ö†', '#00ffaa');
        }
    }

    // If the zone exists, compute whether the player is below the water surface (UNDERWATER)
    const zoneActive = (underwaterZone && player.x >= underwaterZone.startX && player.x < underwaterZone.endX);
    const waterSurfaceY = getWaterSurfaceY(); // matches drawWaterEdge()
    const playerFeetY = player.y + player.height * 0.55;

    // Underwater is based on WHERE you are (below the surface), not whether you're flying.
    // This prevents the "press fly -> instantly snap to land" bug.
    // Add a little hysteresis so you don't flicker when you're right at the surface.
    if (zoneActive) {
        const enterThresh = waterSurfaceY - 6;
        const exitThresh  = waterSurfaceY - 22; // must rise a bit more to exit
        const wasUnderwater = isUnderwater;
        if (!isUnderwater) {
            isUnderwater = (playerFeetY > enterThresh);
        } else {
            isUnderwater = (playerFeetY > exitThresh);
        }
        
        // Just entered water ‚Äî record time, start at surface
        if (isUnderwater && !wasUnderwater) {
            if (!waterEntryTime) waterEntryTime = Date.now();
            // Don't snap Y - let them sink naturally from wherever they are
        }

        
        // LEFT WALL: the first entrance has NO incline, so you cannot walk out of the pool on that side.
        // Clamp the player to stay inside the water zone when they're at/under the surface and not flying.
        const leftWallX = underwaterZone.startX + 12;
        const inWaterBand = (playerFeetY > (waterSurfaceY - 40)); // surface + underwater band
        if (!player.isFlying && inWaterBand && player.x < leftWallX) {
            player.x = leftWallX;
            // Keep underwater state stable to avoid transition distortion flicker
            if (playerFeetY > (waterSurfaceY - 10)) isUnderwater = true;
        }
// While over the water zone (surface OR underwater), prevent land spawns and cull land enemies
        const sx0 = underwaterZone.startX - 160;
        const sx1 = underwaterZone.endX + 160;
        enemies = enemies.filter(e => e.x < sx0 || e.x > sx1);
        drones  = drones.filter(d => d.x < sx0 || d.x > sx1);

        // Spawn enemies in waves as the player moves through the pool
        if (isUnderwater && !waterEncounterCleared) {
            const timeSinceEntry = Date.now() - waterEntryTime;
            if (timeSinceEntry > 4000 && underwaterZone) {
                // Calculate player progress through pool (0 = start, 1 = ramp)
                const poolStart = underwaterZone.startX;
                const poolEnd = underwaterZone.endX - 300; // exclude ramp
                const progress = Math.max(0, Math.min(1, (player.x - poolStart) / (poolEnd - poolStart)));
                
                // Check if player has reached the next wave trigger point
                if (waterWaveIndex < WATER_WAVES.length) {
                    const wave = WATER_WAVES[waterWaveIndex];
                    if (progress >= wave.at || (waterWaveIndex === 0 && timeSinceEntry > 4000)) {
                        // Spawn this wave ahead of the player
                        for (let i = 0; i < wave.torpedo; i++) spawnWaterEnemy('torpedo');
                        for (let i = 0; i < wave.crab; i++) spawnWaterEnemy('crab');
                        waterTotalSpawned += wave.torpedo + wave.crab;
                        waterWaveIndex++;
                        
                        if (!waterEncounterSpawned) {
                            waterEncounterSpawned = true;
                            showWaveAnnouncement('‚ö† HOSTILES DETECTED ‚ö†', '#ff4444');
                        }
                    }
                }
            }
        }
    } else {
        // Not over the zone: ensure underwater is off
        isUnderwater = false;
    }

    // One water zone only (no repeats): once it's created, we never spawn another.
    // IMPORTANT: The pool itself stays in the world so you can cross it and come back later.
    if (underwaterZone && !waterZonePassed && player.x >= underwaterZone.endX) {
        waterZonePassed = true;
        // Do NOT delete the pool or its enemies: this is a special location you can return to.
        // We simply announce the far shore.
        showWaveAnnouncement('‚òÄ FAR SHORE REACHED ‚òÄ', '#00ffaa');
    }

    // Underwater-specific updates
    if (isUnderwater) {
        // Recharge specialty fuel slowly
        flyCharge = Math.min(FLY_CHARGE_MAX, flyCharge + WATER_FUEL_RECHARGE * (deltaTime / 1000));
        updateHUD();
        
        // Check barrel pickup
        if (waterBarrel && !waterBarrel.collected) {
            const bdx = player.x - waterBarrel.x;
            const bdy = (player.y - player.height * 0.3) - waterBarrel.y;
            if (Math.abs(bdx) < 40 && Math.abs(bdy) < 40) {
                waterBarrel.collected = true;
                player.health = player.maxHealth;
                flyCharge = FLY_CHARGE_MAX;
                updateHUD();
                createExplosion(waterBarrel.x, waterBarrel.y, '#00ff88', 35);
                AudioSystem.playBarrelPickup();
                showWaveAnnouncement('‚ö° FULL CHARGE + FULL HEALTH ‚ö°', '#00ff88');
            }
        }

        // Update water enemies
        const wNow = Date.now();
        waterEnemies.forEach(we => {
            // Keep water enemies isolated inside the pool so they never appear to come from land
            if (underwaterZone) {
                const minX = underwaterZone.startX + 90;
                const maxX = underwaterZone.endX - 90;
                if (we.x < minX) we.x = minX;
                if (we.x > maxX) we.x = maxX;
            }

            we.facingRight = player.x > we.x;
            
            if (we.kind === 'torpedo') {
                // Torpedo drones drift toward player slowly, keeping distance
                const tdx = player.x - we.x;
                const tdy = (player.y - player.height * 0.3) - we.y;
                const tDist = Math.hypot(tdx, tdy);
                
                if (tDist > 250) {
                    we.x += (tdx / tDist) * we.speed;
                    we.y += (tdy / tDist) * we.speed * 0.3;
                } else if (tDist < 180) {
                    // Back off if too close
                    we.x -= (tdx / tDist) * we.speed * 0.4;
                }
                we.bobPhase += 0.025;
                we.y += Math.sin(we.bobPhase) * 0.4;
                
                // Clamp Y ‚Äî shark bots stay WAY up in the water column while submerged
                const surfY = isUnderwater ? getUnderwaterTopY() : getWaterSurfaceY();
                const topClamp = surfY + 10;
                const bottomClamp = surfY + 70;
                we.y = Math.max(topClamp, Math.min(bottomClamp, we.y));
                
                // Shoot at player (use horizontal range so sharks can fire down from above)
                if (Math.abs(tdx) < 750 && wNow - we.lastShot > we.shotRate) {
                    const ang = Math.atan2(tdy, tdx);
                    enemyLasers.push({
                        x: we.x + (we.facingRight ? 40 : -40),
                        y: we.y,
                        vx: Math.cos(ang) * 10,
                        vy: Math.sin(ang) * 10,
                        life: 160,
                        w: 5,
                        color: '#ff3b30',
                        glow: 1,
                        waterShot: 1
                    });
                    we.lastShot = wNow;
                    createExplosion(we.x + (we.facingRight ? 40 : -40), we.y, '#ff3b30', 12);
                    AudioSystem.playSharkFire();
                }
            } else if (we.kind === 'crab') {
                // Crab walks toward player on sea floor
                const cdx = player.x - we.x;
                if (Math.abs(cdx) > 80 && !we.isCharging) {
                    we.x += Math.sign(cdx) * we.speed;
                }
                we.legAngle += we.speed * 0.08;
                
                // Energy orb charging and shooting
                const cDist = Math.hypot(cdx, player.y - we.y);
                
                if (!we.isCharging && cDist < 650 && wNow - we.lastShot > we.shotRate) {
                    // Start charging
                    we.isCharging = true;
                    we.chargeStartTime = wNow;
                    we.chargeProgress = 0;
                    AudioSystem.playCrabCharge();
                }
                
                if (we.isCharging) {
                    const chargeTime = 1500; // 1.5s charge
                    we.chargeProgress = Math.min(1, (wNow - we.chargeStartTime) / chargeTime);
                    
                    // Fire when fully charged ‚Äî red lightning bolt
                    if (we.chargeProgress >= 1) {
                        const s = we.width / 80;
                        const fireX = we.x + (we.facingRight ? 1 : -1) * 44 * s;
                        const fireY = we.y - 21 * s;
                        const targetX = player.x;
                        const targetY = player.y - player.height * 0.3;
                        
                        // Generate jagged lightning path
                        const segments = [];
                        const dx = targetX - fireX;
                        const dy = targetY - fireY;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        const numSegs = Math.max(6, Math.floor(dist / 25));
                        for (let seg = 0; seg <= numSegs; seg++) {
                            const t = seg / numSegs;
                            const bx = fireX + dx * t;
                            const by = fireY + dy * t;
                            const jitter = (seg > 0 && seg < numSegs) ? (Math.random() - 0.5) * 30 : 0;
                            const perpX = -dy / dist * jitter;
                            const perpY = dx / dist * jitter;
                            segments.push({ x: bx + perpX, y: by + perpY });
                        }
                        
                        // Store lightning bolt for rendering
                        if (!window.waterLightningBolts) window.waterLightningBolts = [];
                        window.waterLightningBolts.push({
                            segments: segments,
                            life: 1.0,
                            startTime: wNow,
                            duration: 350,
                            damageDealt: false,
                            targetX: targetX,
                            targetY: targetY
                        });
                        
                        // Damage player if in range
                        if (dist < 500) {
                            player.health -= 12 + difficulty * 2;
                            createExplosion(targetX, targetY, '#ff3322', 18);
                        }
                        
                        we.lastShot = wNow;
                        we.isCharging = false;
                        we.chargeProgress = 0;
                        createExplosion(fireX, fireY, '#ff4422', 15);
                        AudioSystem.playCrabFire();
                    }
                } else {
                    // Idle weapon port glow
                    we.chargeProgress = 0.15 + Math.sin(wNow * 0.003) * 0.1;
                }
                
                // Melee attack
                if (Math.abs(cdx) < 60 && Math.abs(player.y - we.y) < 70) {
                    if (wNow - we.lastAttack > we.attackRate) {
                        if (wNow >= player.invulnUntil) {
                            const shielded = wNow < player.shieldUntil && player.shieldHits > 0;
                            if (shielded) { player.shieldHits--; }
                            else { player.health = Math.max(0, player.health - 18); player.invulnUntil = wNow + IFRAME_MS; }
                            player.screenShake = 6;
                        }
                        we.lastAttack = wNow;
                    }
                }
            }
        });
        
        // Remove dead water enemies
        for (let i = waterEnemies.length - 1; i >= 0; i--) {
            if (waterEnemies[i].health <= 0) {
                const we = waterEnemies[i];
                createExplosion(we.x, we.y, '#ff6600', 30, true);
                score += we.kind === 'torpedo' ? 100 : 150;
                kills++;
                flyCharge = Math.min(FLY_CHARGE_MAX, flyCharge + (we.kind === 'crab' ? 35 : 20));
                waterEnemies.splice(i, 1);
                AudioSystem.playExplosion();
                updateHUD();
            }
        }


        // If the pool encounter was spawned and all water enemies are dead, keep the pool empty forever.
        if (waterEncounterSpawned && !waterEncounterCleared && waterEnemies.length === 0 && waterWaveIndex >= WATER_WAVES.length) {
            waterEncounterCleared = true;
            showWaveAnnouncement('‚úì POOL CLEARED ‚Äî EXPLORE FREELY ‚úì', '#00ffaa');
        }
    }
    
    updateWaterBubbles();
    
    // Update drones
    drones.forEach(drone => {
        // Move towards player horizontally
        const dx = player.x - drone.x;
        const targetDistance = 350; // Hover at medium range
        
        if (Math.abs(dx) > targetDistance) {
            // Move towards player if too far
            drone.x += Math.sign(dx) * drone.speed;
        } else if (Math.abs(dx) < targetDistance - 100) {
            // Back away if too close
            drone.x -= Math.sign(dx) * drone.speed * 0.5;
        }
        
        // Bobbing motion
        drone.bobPhase += 0.03;
        drone.y = drone.targetY + Math.sin(drone.bobPhase) * 12;
        // Hard clamp: never let drones go below sky area
        drone.y = Math.min(drone.y, canvas.height - 250);
        
        // Respawn if too far off screen
        if (drone.x < camX - 200 || drone.x > camX + canvas.width + 200) {
            drone.x = player.x + 400 + Math.random() * 300;
            drone.targetY = 40 + Math.random() * Math.max(60, Math.min(canvas.height - 280, 300) - 40);
        }
        
        // SHOOTING - drones fire at player MORE AGGRESSIVELY
        const now = Date.now();
        const distToPlayer = Math.hypot(drone.x - player.x, drone.y - player.y);
        if (distToPlayer < 700 && now - drone.lastShot > drone.shotRate) {
            // Fire a laser bolt at player
            const ang = Math.atan2((player.y - player.height * 0.3) - drone.y, player.x - drone.x);
            const sp = 8;
            enemyLasers.push({
                x: drone.x, 
                y: drone.y + 10,
                vx: Math.cos(ang) * sp,
                vy: Math.sin(ang) * sp,
                life: 100,
                w: 5, // Thicker laser beam
                color: '#ff3333' // Red laser
            });
            drone.lastShot = now;
            
            // Flash effect for visibility
            createExplosion(drone.x, drone.y + 10, '#ff3333', 6);
            
            // Play laser sound
            AudioSystem.playHit();
        }
    });
    
    // Remove dead drones (health checked in rocket collision)
    
    // Aiming: arm points toward bullseye target
    // Convert aim position (screen coords) to world coords
    const aw = screenToWorld(aimX, aimY);
    const aimWorldX = aw.x;
    const aimWorldY = aw.y;
    
    // Player faces direction of bullseye - with hysteresis to prevent rapid flipping
    const aimDiff = aimWorldX - player.x;
    const facingThreshold = 40;  // Must be clearly different to change facing
    
    if (Math.abs(aimDiff) > facingThreshold) {
        player.facingRight = aimWorldX >= player.x;
    }
    // If within threshold, keep current facing
    
    // Calculate arm angle to point at bullseye
    const shoulderX = player.x;
    const shoulderY = player.y - player.height * 0.3;
    const dx = aimWorldX - shoulderX;
    const dy = aimWorldY - shoulderY;
    
    // Calculate angle - use abs(dx) since we flip the sprite for facing direction
    player.armAngle = Math.atan2(dy, Math.abs(dx));
    // Clamp angle - allow straight up (-œÄ/2 = -1.57) and reasonable down
    player.armAngle = Math.max(-1.57, Math.min(1.57, player.armAngle));

    if (mobileMoveHeld) {
        player.targetX = player.x + 1200;
        player.targetY = canvas.height - 120;  // Raised ground
    }
    if (isMoving) {
        // Ground-walk only (no walking up into the air). When not flying, we move in X only.
        const dx = player.targetX - player.x;
        if (Math.abs(dx) > 6) {
            // Slow down slightly when underwater
            const wadeMultiplier = (isUnderwater && !player.isFlying) ? 0.7 : 1;
            const moveSpeed = player.speed * (player.isFlying ? 2.5 : 1) * wadeMultiplier;
            const movement = Math.sign(dx) * moveSpeed;
            
            // Cap movement to prevent teleporting on fast movement
            const maxMovePerFrame = 20;
            const cappedMovement = Math.max(-maxMovePerFrame, Math.min(maxMovePerFrame, movement));
            
            player.x += cappedMovement;
            player.isMoving = true;
        } else {
            player.isMoving = false;
        }
        
        // Flying vertical movement - separate from horizontal
        if (player.isFlying) {
            const dy = player.targetY - player.y;
            if (Math.abs(dy) > 6) {
                // Fast vertical movement when flying
                player.y += Math.sign(dy) * player.speed * 3;
            }
        }
    } else {
        player.isMoving = false;
    }

    if (player.isMoving && !player.isFlying) {
        player.legAngle += player.legDir * 0.2;
        if (Math.abs(player.legAngle) > 0.5) player.legDir *= -1;
    } else player.legAngle *= 0.85;

    const groundY = canvas.height - 120;  // Raised for mobile visibility
    // NO POSITION CONSTRAINTS - let player move freely
    // Camera will follow naturally

    if (!player.isFlying) {
        // Jump physics
        if (player.isJumping) {
            player.jumpVY += 0.6; // gravity
            player.y += player.jumpVY;
            player.x += player.jumpVX;
            player.jumpVX *= 0.98; // air friction
            
            const groundY = canvas.height - 120;
            
            // Check for landing on tech platforms (only when falling)
            // Foot bottom is ~67px below player.y (hipY + upperH + lowerH + foot = 68 * 0.98 scale)
            // On ground, feet sink 37px into thick ground band (hidden by fog). 
            // For thin platforms, offset 62 puts feet just barely into the 18px platform.
            const platStandOffset = 62;
            if (player.jumpVY > 0) {
                const now = Date.now();
                for (const plat of techPlatforms) {
                    const bob = Math.sin(now * 0.002 + plat.bobPhase) * 3;
                    const platTop = plat.y + bob;
                    const playerFeetY = player.y + platStandOffset;
                    if (player.x > plat.x - 10 && player.x < plat.x + plat.w + 10 &&
                        playerFeetY >= platTop - 8 && playerFeetY <= platTop + 24 &&
                        player.jumpVY > 0) {
                        
                        player.y = platTop - platStandOffset;
                        player.isJumping = false;
                        player.jumpVY = 0;
                        player.jumpVX = 0;
                        player._onPlatform = plat;
                        
                        // ELEVATOR ‚Äî start rising
                        if (plat.type === 'elevator' && !plat.elevating) {
                            plat.elevating = true;
                            plat.elevateT = 0;
                            plat.elevateDir = 1;
                        }
                        break;
                    }
                }
            }
            
            // Check for landing on ground
            if (player.y >= groundY) {
                player.y = groundY;
                player.isJumping = false;
                player.jumpVY = 0;
                player.jumpVX = 0;
                player._onPlatform = null;
            }
        } else if (player._onPlatform) {
            // Standing on a platform ‚Äî follow its position
            const plat = player._onPlatform;
            const now = Date.now();
            const bob = Math.sin(now * 0.002 + plat.bobPhase) * 3;
            
            // ELEVATOR ‚Äî smoothly rise and descend
            if (plat.type === 'elevator' && plat.elevating) {
                const elevateSpeed = 1.2; // px per frame
                const maxRise = 200; // how high it goes
                if (plat.elevateDir === 1) {
                    plat.elevateT += elevateSpeed;
                    if (plat.elevateT >= maxRise) {
                        plat.elevateT = maxRise;
                        plat.elevateDir = -1; // start descending
                    }
                } else {
                    plat.elevateT -= elevateSpeed * 0.7; // descend slower
                    if (plat.elevateT <= 0) {
                        plat.elevateT = 0;
                        plat.elevating = false;
                        plat.elevateDir = 0;
                    }
                }
                plat.y = plat.baseY - plat.elevateT;
            }
            
            player.y = plat.y + bob - 62; // match platStandOffset
            // Walk off edge?
            if (player.x < plat.x - 15 || player.x > plat.x + plat.w + 15) {
                player._onPlatform = null;
                player.isJumping = true;
                player.jumpVY = 1; // gentle fall
                player.jumpVX = 0;
            }
        } else if (isUnderwater && underwaterZone) {
            // Pool floor ‚Äî player sinks slowly through chemical to the bottom
            const poolFloorY = getPoolFloorY(); // match the visual floor
            
            // Exit ramp (last 300px of pool) ‚Äî floor rises back to ground level
            const rampStartX = underwaterZone.endX - 300;
            let targetFloorY = poolFloorY;
            if (player.x > rampStartX) {
                const rampProgress = Math.min(1, (player.x - rampStartX) / 300);
                targetFloorY = poolFloorY + (groundY - poolFloorY) * rampProgress;
            }
            player.targetY = targetFloorY;
            // Slow sinking ‚Äî feels like floating down through thick liquid
            const onRamp = player.x > rampStartX;
            const sinkSpeed = onRamp ? 0.10 : 0.018;
            player.y += (targetFloorY - player.y) * sinkSpeed;
        } else {
            player.targetY = groundY;
            player.y += (groundY - player.y) * 0.18;
            if (Math.abs(groundY - player.y) < 0.6) player.y = groundY;
        }
    } else {
        // Flying: allow full vertical range - can go way up!
        player.y = Math.max(60, Math.min(canvas.height - 40, player.y));}

    
    // === UPDATE ALL PLATFORMS (elevator return) ===
    for (const plat of techPlatforms) {
        // Elevator: return to base when player not on it
        if (plat.type === 'elevator' && plat.elevating && player._onPlatform !== plat) {
            plat.elevateDir = -1;
            plat.elevateT -= 1.0;
            if (plat.elevateT <= 0) {
                plat.elevateT = 0;
                plat.elevating = false;
                plat.elevateDir = 0;
            }
            plat.y = plat.baseY - plat.elevateT;
        }
    }
    
    // === HEALTH PICKUP COLLECTION ===
    for (const hp of healthPickups) {
        if (hp.collected) continue;
        const now = Date.now();
        const bob = Math.sin(now * 0.003 + hp.bobPhase) * 4;
        const hdx = player.x - hp.x;
        // Check distance from player body center (player.y is head area, feet at +62)
        const playerCenterY = player.y + 30; // mid-body
        const hdy = playerCenterY - (hp.y + bob);
        if (Math.abs(hdx) < 40 && Math.abs(hdy) < 50) {
            hp.collected = true;
            if (player.health >= player.maxHealth) {
                // Full health ‚Äî give fuel boost instead
                flyCharge = Math.min(FLY_CHARGE_MAX, flyCharge + FLY_CHARGE_MAX * 0.5);
                updateHUD();
                createExplosion(hp.x, hp.y, '#ffcc00', 25);
                AudioSystem.playBarrelPickup();
                showWaveAnnouncement('‚ö° +50% FUEL ‚ö°', '#ffcc00');
            } else {
                const healAmt = Math.floor(player.maxHealth * 0.35);
                player.health = Math.min(player.maxHealth, player.health + healAmt);
                updateHUD();
                createExplosion(hp.x, hp.y, '#00ff88', 25);
                AudioSystem.playBarrelPickup();
                showWaveAnnouncement('‚ö° +35% HEALTH ‚ö°', '#00ff88');
            }
        }
    }
    
    // Side-scroller camera: LOCK to player position (no lag)
    // Direct assignment - camera always keeps player in view
    camX = Math.max(0, player.x - canvas.width * 0.35);
    
    // Don't let player go too far left (off the left edge of the world)
    const minPlayerX = 50;
    if (player.x < minPlayerX) {
        player.x = minPlayerX;
    }
    
    // If position becomes invalid, restore last valid position
    if (!isFinite(player.x) || !isFinite(player.y)) {
        console.error(`Position became invalid! Restoring last valid position`);
        
        if (!isFinite(player.x) && typeof window.lastValidPlayerX === 'number') {
            player.x = window.lastValidPlayerX;
        } else if (!isFinite(player.x)) {
            player.x = camX + 200;
        }
        
        if (!isFinite(player.y)) {
            player.y = canvas.height - 180;  // Raised to match ground
        }
    }
    
    // === SAFETY CLAMP: prevent player getting shoved off-screen during heavy collisions / fog volumes ===
    // Keep last-known-good position when finite
    if (isFinite(player.x) && isFinite(player.y)) {
        window.lastValidPlayerX = player.x;
    }

    // If something pushes the player way outside the camera view, snap back into view
    if (
        player.x < camX - 200 ||
        player.x > camX + canvas.width + 200 ||
        player.y < -200 ||
        player.y > canvas.height + 200
    ) {
        player.x = camX + canvas.width * 0.3;
        player.y = canvas.height - 180;  // Raised to match ground
        player.screenShake = 0;
    }

    // Hard clamp to the current camera bounds so the player can't "exist" off-screen
    player.x = Math.max(camX + 40, Math.min(player.x, camX + canvas.width - 40));
    player.y = Math.max(40, Math.min(player.y, canvas.height - 40));


if (player.isFlying && Date.now() > player.flyEndTime) { player.isFlying = false; player.isJumping = true; player.jumpVY = 2; player.jumpVX = 0; player._onPlatform = null; }

    if (isFiring) { fireOneRocket(false); }
    
    // Periodic cleanup: verify isFiring state matches actual pointer state
    if (typeof btnFire !== 'undefined' && btnFire) {
        const firePressed = btnFire.classList.contains('on');
        // Only force-clear if no mouse button is also firing
        if (!firePressed && isFiring && !document.querySelector('canvas:active')) {
            // Check if stuck for too long without recent fire
            if (Date.now() - lastFireTime > 1200) {
                isFiring = false;
            }
        }
    }

    enemies.forEach((enemy) => {
        // Water-zone safety: keep LAND enemies out of the chemical pool (both when above it and when you're underwater)
        const wzStart = (underwaterZone ? underwaterZone.startX : nextWaterEdgeX);
        const wzEnd   = (underwaterZone ? underwaterZone.endX   : (nextWaterEdgeX + WATER_ZONE_LENGTH_MAX));

        // When ABOVE the pool, keep LAND enemies from "walking on water" by holding them at the nearest shoreline
        // (prevents bots from popping/disappearing when they reach the edges).
        if (!isUnderwater) {
            const nearShore = wzStart - 36;
            const farShore  = wzEnd + 36;

            // Only intervene if the enemy is actually inside the pool span (not just near it)
            if (enemy.x > wzStart && enemy.x < wzEnd) {
                const mid = (wzStart + wzEnd) * 0.5;

                // If the player is clearly on one side, hold enemies at that side's shore
                if (player.x < wzStart) {
                    enemy.x = nearShore;
                    enemy.targetX = nearShore;
                } else if (player.x > wzEnd) {
                    enemy.x = farShore;
                    enemy.targetX = farShore;
                } else {
                    // Player is at/over the pool surface ‚Äî choose by which half the enemy was in
                    if (enemy.x < mid) { enemy.x = nearShore; enemy.targetX = nearShore; }
                    else { enemy.x = farShore; enemy.targetX = farShore; }
                }
            }
        } else {
            // When you're UNDERWATER, stop land enemies from following you into the liquid
            // (they should bunch up at the shoreline instead of walking into the pool)
            const shoreX = wzStart - 36;
            if (enemy.x > shoreX) {
                enemy.x = shoreX;
                enemy.targetX = shoreX;
            }
            enemy.targetY = canvas.height - 120 - Math.random() * 20;
        }
        const dx = enemy.targetX - enemy.x, dy = enemy.targetY - enemy.y, dist = Math.sqrt(dx * dx + dy * dy);
        const distToPlayer = Math.hypot(enemy.x - player.x, enemy.y - player.y);
        
        // Charge attack
        if (distToPlayer < 350 && !enemy.isCharging && Math.random() < 0.003) {
            enemy.isCharging = true;
            enemy.chargeTimer = 50;
            if (enemy.kind === 'trex') {
                AudioSystem.playTRexRoar();
            } else {
                AudioSystem.playRoar();
            }
        }
        
        if (enemy.isCharging) {
            enemy.chargeTimer--;
            if (enemy.chargeTimer <= 0) enemy.isCharging = false;
            const chargeDir = player.x > enemy.x ? 1 : -1;
            enemy.x += chargeDir * enemy.speed * 3;
            enemy.legAngle += enemy.legDir * 0.35;
        } else if (dist > 20) {
            enemy.x += (dx / dist) * enemy.speed;
            enemy.y += (dy / dist) * enemy.speed;
            enemy.legAngle += enemy.legDir * 0.12;
        }
        
        if (Math.abs(enemy.legAngle) > 0.4) enemy.legDir *= -1;
        if (dist <= 20 || Math.random() < 0.008) {
            enemy.targetX = player.x + (Math.random() - 0.5) * 400;
            enemy.targetY = canvas.height - 120 - Math.random() * 50;
        }
        
        enemy.facingRight = player.x > enemy.x;

        // Ranged attack: some cyber‚Äërex units fire head lasers (with telegraph)
        if (enemy.hasLaser && distToPlayer < 650) {
            const now = Date.now();

            // Start telegraph if ready and not already telegraphing
            if (!enemy.telegraphUntil && (now - enemy.lastShot > enemy.shotRate)) {
                // Fire from ACTUAL CANNON BARREL MUZZLE (rotates to aim at player)
                const s = enemy.width / 100;  // Scale factor
                const turretBaseX = enemy.x + (enemy.facingRight ? 60 * s : -60 * s);
                const turretBaseY = enemy.y - 55 * s;
                
                // Calculate in LOCAL space (same as drawing code)
                const aimDx = player.x - turretBaseX;
                const aimDy = (player.y - player.height * 0.35) - turretBaseY;
                const localDx = enemy.facingRight ? aimDx : -aimDx;
                let turretAngle = Math.atan2(aimDy, localDx);
                turretAngle = Math.max(-Math.PI * 0.45, Math.min(Math.PI * 0.25, turretAngle));
                
                // Barrel tip in local space, then convert to world
                const localTipX = Math.cos(turretAngle) * 87 * s;
                const localTipY = Math.sin(turretAngle) * 87 * s;
                const muzzleX = turretBaseX + (enemy.facingRight ? localTipX : -localTipX);
                const muzzleY = turretBaseY + localTipY;

                enemy.telegraphUntil = now + LASER_TELEGRAPH_MS;
                enemy.telegraphData = { muzzleX, muzzleY };
                // Large warning explosion so player knows it's about to fire
                createExplosion(muzzleX, muzzleY, '#ff3355', 18);
                // Add warning sound
                AudioSystem.playHit();
            }

            // Fire after telegraph
            if (enemy.telegraphUntil && now >= enemy.telegraphUntil) {
                const { muzzleX, muzzleY } = enemy.telegraphData || { muzzleX: enemy.x, muzzleY: enemy.y };

                // INSTANT LIGHTNING BOLT - not a projectile!
                // Store lightning attack data for rendering
                if (!enemy.lightningAttack) {
                    enemy.lightningAttack = {
                        active: true,
                        fromX: muzzleX,
                        fromY: muzzleY,
                        toX: player.x,
                        toY: player.y - player.height * 0.35,
                        startTime: now,
                        duration: 150  // Lightning visible for 150ms
                    };
                    
                    // Damage player immediately
                    const dmg = 25;
                    if (now >= player.invulnUntil) {
                        player.health = Math.max(0, player.health - dmg);
                        player.invulnUntil = now + 800;
                        AudioSystem.playHit();  // Fixed: was playHurt
                    }
                }

                enemy.lastShot = now;
                enemy.telegraphUntil = 0;
                enemy.telegraphData = null;
                
                // Play scary spider tank laser sound
                AudioSystem.playSpiderLaser();
                
                // WILD FIRING EFFECT - Multiple explosions
                createExplosion(muzzleX, muzzleY, '#ff0000', 35);  // Main explosion
                createExplosion(player.x, player.y - player.height * 0.35, '#ff0000', 30);  // Hit explosion
                
                // Extra sparks for dramatic effect
                for (let i = 0; i < 15; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 3 + Math.random() * 6;
                    sparks.push({
                        x: muzzleX,
                        y: muzzleY,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 0.8 + Math.random() * 0.4,
                        size: 3 + Math.random() * 5,
                        color: '#ff0000'
                    });
                }
            }
            
            // Clear finished lightning attacks
            if (enemy.lightningAttack && now - enemy.lightningAttack.startTime > enemy.lightningAttack.duration) {
                enemy.lightningAttack = null;
            }
        }
        
        // Melee attack
        const meleeRange = 70;
        if (Math.abs(enemy.x - player.x) < meleeRange && Math.abs(enemy.y - player.y) < 90) {
            if (Date.now() - enemy.lastAttack > enemy.attackRate) {
                const now = Date.now();

                // Ignore if invulnerable
                if (now < player.invulnUntil) {
                    // do nothing
                }
                // Shield absorbs hits
                else if (now < player.shieldUntil && player.shieldHits > 0) {
                    player.shieldHits--;
                    player.screenShake = Math.max(player.screenShake, 6);
                    createExplosion(player.x, player.y - 30, '#66aaff', 10);
                    player.invulnUntil = now + 220;
                    AudioSystem.playHit();
                }
                // Take damage
                else {
                    player.health -= 18;
                    player.invulnUntil = now + IFRAME_MS;
                    player.screenShake = 18;
                    createExplosion(player.x, player.y - 20, '#ff4444', 12);
                    AudioSystem.playDamage();
                    updateHUD();
                    enemy.lastAttack = now;

                    if (player.health <= 0) {
                        createExplosion(player.x, player.y, '#00ffcc', 60, true);
                        AudioSystem.playExplosion(true);
                        gameOver();
                    }
                }

                enemy.lastAttack = now;
            }
        }

    });

    // Remove any surface enemies culled for being over water zones
    enemies = enemies.filter(e => !e._cullWater);

    rockets = rockets.filter(rocket => {
        // Spinning motion
        // rocket spin removed (missiles should not rotate like throwing stars)
        rocket.spin = 0;
        
        // NO HOMING - straight shots only
        
        rocket.x += rocket.vx;
        rocket.y += rocket.vy;
        rocket.life--;

        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            // WIDE hitbox to include legs - spider tank is very wide
            const hitboxW = enemy.kind === 'trex' ? 130 : 60;
            const hitboxH = enemy.kind === 'trex' ? 100 : 70;
            // enemy.y is at feet, so center hitbox on body (halfway up)
            const hitboxCenterY = enemy.y - enemy.height * 0.45;
            
            if (Math.abs(rocket.x - enemy.x) < hitboxW && Math.abs(rocket.y - hitboxCenterY) < hitboxH) {
                enemy.health -= 30;
                createExplosion(rocket.x, rocket.y, '#ff8844', 25);
                AudioSystem.playHit();
                if (enemy.health <= 0) {
                    const isTRex = enemy.kind === 'trex';
                    createExplosion(enemy.x, enemy.y - 30, isTRex ? '#ff4444' : '#ff6633', isTRex ? 70 : 55, true);
                    AudioSystem.playExplosion(true);
                    if (isTRex) {
                        AudioSystem.playTRexRoar();
                    } else {
                        AudioSystem.playRoar();
                    }
                    enemies.splice(i, 1);
                    kills++;
                    score += isTRex ? 500 : 200;
                    flyCharge = Math.min(FLY_CHARGE_MAX, flyCharge + (isTRex ? 50 : 30));
                    updateHUD();
                }
                return false;
            }
        }
        
        // Drone collision
        for (let i = drones.length - 1; i >= 0; i--) {
            const drone = drones[i];
            if (Math.abs(rocket.x - drone.x) < 25 && Math.abs(rocket.y - drone.y) < 20) {
                drone.health -= 30;
                createExplosion(rocket.x, rocket.y, '#00ccff', 20);
                AudioSystem.playHit();
                if (drone.health <= 0) {
                    createExplosion(drone.x, drone.y, '#ff6600', 40, true);
                    AudioSystem.playExplosion(true);
                    drones.splice(i, 1);
                    kills++;
                    score += 150;
                    flyCharge = Math.min(FLY_CHARGE_MAX, flyCharge + 20);
                    updateHUD();
                }
                return false;
            }
        }
        
        // Water enemy collision
        for (let i = waterEnemies.length - 1; i >= 0; i--) {
            const we = waterEnemies[i];
            const hitW = we.kind === 'crab' ? 40 : 40;
            const hitH = we.kind === 'crab' ? 35 : 14;
            const hitY = we.kind === 'crab' ? we.y - we.height * 0.3 : we.y;
            if (Math.abs(rocket.x - we.x) < hitW && Math.abs(rocket.y - hitY) < hitH) {
                we.health -= 30;
                createExplosion(rocket.x, rocket.y, '#00ccff', 20);
                AudioSystem.playHit();
                return false;
            }
        }
        
        return rocket.life > 0 && rocket.x > (camX - 50) && rocket.x < (camX + canvas.width + 50) && rocket.y > -50 && rocket.y < canvas.height + 50;
    });


    // Enemy laser bolts
    enemyLasers = enemyLasers.filter(lz => {
        lz.x += lz.vx;
        lz.y += lz.vy;
        lz.life--;

        // hit check (simple point vs player body) - now works even when flying
        if (Math.abs(lz.x - player.x) < 28 && Math.abs(lz.y - (player.y - player.height * 0.30)) < 36) {
            const now = Date.now();

            if (now < player.invulnUntil) {
                return false;
            }

            if (now < player.shieldUntil && player.shieldHits > 0) {
                player.shieldHits--;
                player.screenShake = Math.max(player.screenShake, 6);
                createExplosion(lz.x, lz.y, '#66aaff', 12);
                player.invulnUntil = now + 220;
                AudioSystem.playHit();
                updateHUD();
                return false;
            }

            player.health -= 10;
            player.invulnUntil = now + IFRAME_MS;
            player.screenShake = Math.max(player.screenShake, 10);
            createExplosion(lz.x, lz.y, '#ff3355', 18);
            AudioSystem.playDamage();
            updateHUD();
            if (player.health <= 0) {
                createExplosion(player.x, player.y, '#00ffcc', 60, true);
                AudioSystem.playExplosion(true);
                gameOver();
            }
            return false;
        }

        // Contain water-enemy projectiles inside the pool
        if (underwaterZone) {
            const waterSurfY = (isUnderwater ? getUnderwaterTopY() : getWaterSurfaceY());
            const inPoolX = lz.x >= underwaterZone.startX && lz.x <= underwaterZone.endX;
            // If projectile originated from inside pool area but is now above surface, kill it
            if (lz.y < waterSurfY - 10 && inPoolX) return false;
            // If projectile left pool X bounds, kill it
            if (lz.x < underwaterZone.startX - 50 || lz.x > underwaterZone.endX + 50) {
                if (lz.y > waterSurfY) return false; // was in pool depth, now escaped horizontally
            }
        }

        // Ground collision ‚Äî projectile hits the floor
        const groundSurface = canvas.height - 88;
        if (lz.y >= groundSurface) {
            // Small spark on impact
            for (let s = 0; s < 4; s++) {
                sparks.push({ x: lz.x, y: groundSurface, vx: (Math.random()-0.5)*4, vy: -Math.random()*3, life: 0.6, size: 2 + Math.random()*2, color: lz.color || '#ff5533' });
            }
            return false;
        }

        return lz.life > 0 && lz.x > camX - 80 && lz.x < camX + canvas.width + 80 && lz.y > -80 && lz.y < canvas.height - 88;
    });

    smokeTrails = smokeTrails.filter(s => { s.x += s.vx; s.y += s.vy; s.vy -= 0.03; s.life -= 0.035; s.size *= 1.03; return s.life > 0; });
    particles = particles.filter(p => { p.x += p.vx; p.y += p.vy; p.vy += 0.12; p.vx *= 0.98; p.life -= p.decay; return p.life > 0; });
    sparks = sparks.filter(s => { s.x += s.vx; s.y += s.vy; s.vy += 0.08; s.life -= 0.04; return s.life > 0; });
    debris = debris.filter(d => { d.x += d.vx; d.y += d.vy; d.vy += 0.25; d.rotation += d.rotSpeed; d.life -= 0.012; return d.life > 0 && d.y < canvas.height + 50; });
    player.screenShake *= 0.88;

    const hint = document.getElementById('easterEggHint');
    hint.classList.toggle('show', flyCharge >= FLY_CHARGE_MAX && !player.isFlying);
    
    // HARD CLAMP: Force player.x to never jump more than 30px per frame
    if (typeof window.lastValidPlayerX === 'number') {
        const maxJump = 30;
        const actualJump = player.x - window.lastValidPlayerX;
        
        if (Math.abs(actualJump) > maxJump) {
            console.warn(`Prevented jump from ${window.lastValidPlayerX.toFixed(0)} to ${player.x.toFixed(0)} (${actualJump.toFixed(0)}px)`);
            // Clamp to max allowed movement
            player.x = window.lastValidPlayerX + Math.sign(actualJump) * maxJump;
        }
    }
    
    // Save valid position for next frame
    if (isFinite(player.x)) {
        window.lastValidPlayerX = player.x;
    }
}

function draw() {
    ctx.save();
    if (player.screenShake > 0.5) ctx.translate((Math.random() - 0.5) * player.screenShake, (Math.random() - 0.5) * player.screenShake);

    // Space sky (upgraded)
    const t = Date.now() * 0.00005;

    if (isUnderwater) {
        // === UNDERWATER BACKGROUND ===
        drawUnderwaterBackground();
    } else {

    // Pure black space
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Milky-way band
    ctx.save();
    ctx.translate(canvas.width * 0.15, canvas.height * 0.18);
    ctx.rotate(-0.25);
    const bandGrad = ctx.createLinearGradient(0, 0, canvas.width, 0);
    bandGrad.addColorStop(0, 'rgba(255,255,255,0)');
    bandGrad.addColorStop(0.35, 'rgba(120,160,255,0.05)');
    bandGrad.addColorStop(0.5, 'rgba(255,220,180,0.07)');
    bandGrad.addColorStop(0.65, 'rgba(120,160,255,0.05)');
    bandGrad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = bandGrad;
    ctx.fillRect(-canvas.width * 0.2, -60, canvas.width * 1.6, 140);
    ctx.restore();

    // Starfields (3 layers, subtle parallax)
    function starLayer(count, speed, minR, maxR, baseA) {
        for (let i = 0; i < count; i++) {
            const sx = (i * 997.3 + i * i * 0.41) % canvas.width;
            const sy = (i * 613.7 + i * 0.83) % (canvas.height * 0.75);
            const drift = (t * speed * 200 + camX * 0.04 * speed) % canvas.width;
            const x = (sx + drift) % canvas.width;
            const y = sy;
            const r = minR + ((i % 7) / 6) * (maxR - minR);
            const tw = 0.90 + Math.sin((Date.now() * 0.0007) + i) * 0.06;
            ctx.globalAlpha = baseA * tw;
            ctx.fillStyle = (i % 11 === 0) ? 'rgba(255,240,220,1)' : ((i % 13 === 0) ? 'rgba(200,220,255,1)' : '#ffffff');
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();

            // occasional diffraction sparkle
            if (i % 47 === 0) {
                ctx.globalAlpha = baseA * 0.35 * tw;
                ctx.strokeStyle = ctx.fillStyle;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x - 6, y); ctx.lineTo(x + 6, y);
                ctx.moveTo(x, y - 6); ctx.lineTo(x, y + 6);
                ctx.stroke();
            }
        }
        ctx.globalAlpha = 1;
    }
    starLayer(150, 0.7, 0.5, 1.4, 0.7);   // More stars, brighter, bigger
    starLayer(120, 1.2, 0.35, 1.0, 0.55);
    starLayer(80, 1.8, 0.25, 0.75, 0.40);

    // Nebula clouds (layered)
    const neb1 = ctx.createRadialGradient(canvas.width * 0.72, canvas.height * 0.22, 0, canvas.width * 0.72, canvas.height * 0.22, 380);
    neb1.addColorStop(0, 'rgba(170, 90, 255, 0.14)');
    neb1.addColorStop(0.4, 'rgba(70, 120, 255, 0.08)');
    neb1.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = neb1;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const neb2 = ctx.createRadialGradient(canvas.width * 0.35, canvas.height * 0.35, 0, canvas.width * 0.35, canvas.height * 0.35, 420);
    neb2.addColorStop(0, 'rgba(60, 220, 180, 0.07)');
    neb2.addColorStop(0.55, 'rgba(40, 120, 160, 0.05)');
    neb2.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = neb2;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    
    // Distant planet (more detailed + subtle motion)
    const planetDrift = (camX * 0.012) % (canvas.width + 260);
    const planetX = canvas.width * 0.20 - planetDrift;
    const planetY = canvas.height * 0.23;

    // Base sphere
    const pr = 70;
    const planetGrad = ctx.createRadialGradient(planetX - pr*0.25, planetY - pr*0.25, pr*0.10, planetX, planetY, pr);
    planetGrad.addColorStop(0, '#a7ff4a');
    planetGrad.addColorStop(0.35, '#38d94a');
    planetGrad.addColorStop(0.7, '#0b6b2f');
    planetGrad.addColorStop(1, '#032512');
    ctx.fillStyle = planetGrad;
    ctx.beginPath();
    ctx.arc(planetX, planetY, pr, 0, Math.PI * 2);
    ctx.fill();

    // Subtle cloud bands + texture (masked to sphere)
    ctx.save();
    ctx.beginPath();
    ctx.arc(planetX, planetY, pr, 0, Math.PI*2);
    ctx.clip();
    ctx.globalAlpha = 0.22;

    for (let b=0;b<10;b++){
        const by = planetY - pr + b*(pr*0.22) + Math.sin((Date.now()*0.00035)+b)*2.0;
        const band = ctx.createLinearGradient(planetX - pr, by, planetX + pr, by);
        band.addColorStop(0, 'rgba(255,255,255,0)');
        band.addColorStop(0.35, 'rgba(190,255,190,0.16)');
        band.addColorStop(0.65, 'rgba(40,140,80,0.18)');
        band.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = band;
        ctx.fillRect(planetX - pr, by, pr*2, pr*0.10);
    }

    // Storm swirls removed - cleaner look
    ctx.restore();

    // Ring: multi-strand with dust specks (NO atmosphere rim - removed grey C)
    ctx.save();
    ctx.translate(planetX, planetY);
    ctx.rotate(-0.28);

    const ringA = ctx.createLinearGradient(-130, -6, 130, 6);
    ringA.addColorStop(0, 'rgba(255,255,255,0.02)');
    ringA.addColorStop(0.25, 'rgba(210,190,170,0.18)');
    ringA.addColorStop(0.5, 'rgba(255,255,255,0.06)');
    ringA.addColorStop(0.75, 'rgba(170,150,130,0.16)');
    ringA.addColorStop(1, 'rgba(255,255,255,0.02)');

    ctx.strokeStyle = ringA;
    ctx.lineWidth = 3.5;
    ctx.beginPath();
    ctx.ellipse(0, 0, 112, 26, 0, 0, Math.PI * 2);
    ctx.stroke();

    ctx.globalAlpha = 0.55;
    ctx.lineWidth = 1.4;
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.beginPath();
    ctx.ellipse(0, 0, 120, 28, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.ellipse(0, 0, 104, 24, 0, 0, Math.PI * 2);
    ctx.stroke();

    // Ring dust circles removed for cleaner look
    ctx.restore();
    
    // Blue ringed planet in the sky
    const bluePlanetX = canvas.width * 0.78;
    const bluePlanetY = canvas.height * 0.13;
    const bluePlanetR = 45;
    
    ctx.save();
    ctx.translate(bluePlanetX, bluePlanetY);
    
    // Atmospheric glow behind planet
    ctx.globalAlpha = 0.4;
    const atmoGlow = ctx.createRadialGradient(0, 0, bluePlanetR * 0.8, 0, 0, bluePlanetR * 1.8);
    atmoGlow.addColorStop(0, 'rgba(100, 180, 255, 0.3)');
    atmoGlow.addColorStop(0.5, 'rgba(50, 120, 200, 0.15)');
    atmoGlow.addColorStop(1, 'rgba(20, 60, 150, 0)');
    ctx.fillStyle = atmoGlow;
    ctx.beginPath();
    ctx.arc(0, 0, bluePlanetR * 1.8, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    // Ring behind planet (back half)
    ctx.save();
    ctx.globalAlpha = 0.6;
    
    // Ring gradient
    const ringGrad = ctx.createLinearGradient(-bluePlanetR * 2.2, 0, bluePlanetR * 2.2, 0);
    ringGrad.addColorStop(0, 'rgba(180, 200, 220, 0.1)');
    ringGrad.addColorStop(0.3, 'rgba(200, 220, 240, 0.4)');
    ringGrad.addColorStop(0.5, 'rgba(220, 235, 250, 0.5)');
    ringGrad.addColorStop(0.7, 'rgba(200, 220, 240, 0.4)');
    ringGrad.addColorStop(1, 'rgba(180, 200, 220, 0.1)');
    
    ctx.strokeStyle = ringGrad;
    ctx.lineWidth = 12;
    ctx.beginPath();
    ctx.ellipse(0, 0, bluePlanetR * 2, bluePlanetR * 0.4, 0, Math.PI, Math.PI * 2); // Top half only (behind)
    ctx.stroke();
    
    // Inner ring
    ctx.lineWidth = 6;
    ctx.globalAlpha = 0.4;
    ctx.beginPath();
    ctx.ellipse(0, 0, bluePlanetR * 1.6, bluePlanetR * 0.32, 0, Math.PI, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
    
    // Planet body - Gassy swirling surface like Venus
    const bluePlanetGrad = ctx.createRadialGradient(
        -bluePlanetR * 0.3, -bluePlanetR * 0.3, bluePlanetR * 0.1,
        0, 0, bluePlanetR
    );
    bluePlanetGrad.addColorStop(0, '#a8d8ff');  // Light blue highlight
    bluePlanetGrad.addColorStop(0.25, '#6ab8e8'); // Mid blue
    bluePlanetGrad.addColorStop(0.5, '#4a98c8'); // Deeper blue
    bluePlanetGrad.addColorStop(0.75, '#2a78a8'); // Dark blue
    bluePlanetGrad.addColorStop(1, '#1a5888');   // Shadow edge
    ctx.fillStyle = bluePlanetGrad;
    ctx.beginPath();
    ctx.arc(0, 0, bluePlanetR, 0, Math.PI * 2);
    ctx.fill();
    
    // Swirling gas bands (Venus-like)
    ctx.save();
    ctx.beginPath();
    ctx.arc(0, 0, bluePlanetR, 0, Math.PI * 2);
    ctx.clip();
    
    // Multiple swirling cloud bands
    const gasTime = Date.now() * 0.0001;
    for (let i = 0; i < 6; i++) {
        ctx.globalAlpha = 0.12 + (i % 2) * 0.05;
        ctx.fillStyle = i % 2 === 0 ? '#cceeff' : '#88ccee';
        const bandY = -bluePlanetR * 0.8 + i * bluePlanetR * 0.3;
        const waveOffset = Math.sin(gasTime + i * 0.5) * 3;
        ctx.beginPath();
        ctx.ellipse(waveOffset, bandY, bluePlanetR * 1.2, 5 + (i % 3) * 2, 0.05 * i, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Swirling storm/vortex
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = '#ddeeff';
    ctx.beginPath();
    ctx.ellipse(bluePlanetR * 0.25, -bluePlanetR * 0.1, 10, 7, 0.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(-bluePlanetR * 0.3, bluePlanetR * 0.3, 8, 5, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    
    // Ring in front of planet (front half)
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.strokeStyle = ringGrad;
    ctx.lineWidth = 12;
    ctx.beginPath();
    ctx.ellipse(0, 0, bluePlanetR * 2, bluePlanetR * 0.4, 0, 0, Math.PI); // Bottom half only (in front)
    ctx.stroke();
    
    // Inner ring front
    ctx.lineWidth = 6;
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    ctx.ellipse(0, 0, bluePlanetR * 1.6, bluePlanetR * 0.32, 0, 0, Math.PI);
    ctx.stroke();
    ctx.restore();
    
    ctx.restore();

    // Parallax horizon
    ctx.save();
    ctx.translate(-(camX * 0.18), 0);


    // Alien mountain silhouettes (simple, atmospheric)
    ctx.fillStyle = '#1a1a22';
    ctx.beginPath();
    ctx.moveTo(0, canvas.height - 105);
    
    // Create mountain peaks with varied heights
    for (let x = 0; x <= canvas.width; x += 60) {
        const h = 50 + Math.sin(x * 0.012) * 55 + Math.cos(x * 0.008) * 40 + Math.sin(x * 0.025) * 25;
        ctx.lineTo(x, canvas.height - 105 - h);
    }
    
    ctx.lineTo(canvas.width, canvas.height);
    ctx.lineTo(0, canvas.height);
    ctx.closePath();
    ctx.fill();
    
    // Add depth with second layer of mountains
    ctx.globalAlpha = 0.6;
    ctx.fillStyle = '#252530';
    ctx.beginPath();
    ctx.moveTo(0, canvas.height - 105);
    
    for (let x = 0; x <= canvas.width; x += 70) {
        const h = 30 + Math.sin(x * 0.008 + 100) * 35 + Math.cos(x * 0.015 + 50) * 20;
        ctx.lineTo(x, canvas.height - 105 - h);
    }
    
    ctx.lineTo(canvas.width, canvas.height);
    ctx.lineTo(0, canvas.height);
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha = 1;

    const haze = ctx.createLinearGradient(0, canvas.height - 220, 0, canvas.height - 60);
    haze.addColorStop(0, 'rgba(80,80,100,0)');
    haze.addColorStop(0.55, 'rgba(50,50,70,0.08)');
    haze.addColorStop(1, 'rgba(10,10,20,0.22)');
    ctx.fillStyle = haze;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Alien ground
    ctx.restore();

    // Pure BLACK metallic ground with steam vents
    const groundGrad = ctx.createLinearGradient(0, canvas.height - 90, 0, canvas.height);
    groundGrad.addColorStop(0, '#0a0a0a');  // Almost black
    groundGrad.addColorStop(0.5, '#050505');  // Pure black
    groundGrad.addColorStop(1, '#000000');  // Black
    ctx.fillStyle = groundGrad;
    ctx.fillRect(0, canvas.height - 90, canvas.width, 90);

    // Metal panel seams
    ctx.save();
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 2;
    
    // Horizontal seams
    for (let i = 0; i < 6; i++) {
        const y = canvas.height - 90 + i * 15;
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
    
    // Vertical panel seams (with perspective)
    const gridOffset = -((camX % 120 + 120) % 120);
    for (let x = gridOffset; x < canvas.width + 120; x += 120) {
        ctx.globalAlpha = 0.25;
        ctx.strokeStyle = '#151515';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x, canvas.height - 90);
        ctx.lineTo(canvas.width / 2 + (x - canvas.width / 2) * 1.5, canvas.height);
        ctx.stroke();
    }
    
    // MINIMAL FOG - just wisps to show it's there, but ground stays BLACK
    ctx.save();
    const fogTime = Date.now() * 0.0004;
    
    // Very subtle wispy fog - BARELY VISIBLE
    ctx.globalAlpha = 0.08;  // Very low
    for (let i = 0; i < 30; i++) {
        const wispX = (i * 67.3 + fogTime * (70 + i * 4) + camX * 0.3) % (canvas.width + 350) - 175;
        const wispY = canvas.height - 55 + Math.sin(fogTime * 1.2 + i * 0.9) * 15;
        const wispSize = 60 + (i % 9) * 25;
        
        const wispGrad = ctx.createRadialGradient(wispX, wispY, 0, wispX, wispY, wispSize);
        wispGrad.addColorStop(0, 'rgba(160, 160, 180, 0.3)');
        wispGrad.addColorStop(0.5, 'rgba(130, 130, 150, 0.15)');
        wispGrad.addColorStop(1, 'rgba(100, 100, 120, 0)');
        
        ctx.fillStyle = wispGrad;
        ctx.beginPath();
        ctx.arc(wispX, wispY, wispSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.restore();
    ctx.globalAlpha = 1;
    
    // Metal rivets/bolts
    ctx.fillStyle = '#0a0a0a';
    for (let x = gridOffset; x < canvas.width + 120; x += 60) {
        for (let i = 0; i < 4; i++) {
            const y = canvas.height - 85 + i * 20;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Subtle highlight
            ctx.fillStyle = '#2a2a2a';
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            ctx.arc(x - 1, y - 1, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#0a0a0a';
        }
    }
    
    ctx.restore();
    ctx.globalAlpha = 1;
    } // end surface background else block
    // World-space entities
    ctx.save();
    const __worldScale = getWorldScale();
    const __worldOffsetY = getWorldOffsetY(__worldScale);
    if (__worldScale !== 1) ctx.scale(__worldScale, __worldScale);
    ctx.translate(-camX, __worldOffsetY);

    // === WATER EDGE / CHEMICAL POOL (single special occurrence) ===
    // Preview shoreline before discovery; once created, render the FULL pool segment between startX and endX,
    // so it never "vanishes" when you traverse past the far edge and come back.
    if (underwaterZone) {
        const z0 = underwaterZone.startX;
        const z1 = underwaterZone.endX;
        // If ANY part of the pool is within a generous view window, draw it.
        if (z1 > camX - 600 && z0 < camX + canvas.width + 1200) {
            if (isUnderwater) {
                // When INSIDE the pool, don't draw any surface line ‚Äî the underwater BG covers everything
                // (drawing a surface line here creates a visible color seam)
            } else {
                // When ABOVE the pool (surface view), draw the full pool visual
                drawWaterZone(z0, z1);
            }
        }
    } else {
        const poolEdgeX = nextWaterEdgeX;
        if (poolEdgeX > camX - 600 && poolEdgeX < camX + canvas.width + 1200) {
            drawWaterEdge(poolEdgeX);
        }
    }

    // Smoke trails (streaks only ‚Äî no big bubble circles)
    smokeTrails.forEach(s => {
        // draw as short streak + tiny ember dot
        const tx = s.x - s.vx * 6;
        const ty = s.y - s.vy * 6;
        ctx.globalAlpha = Math.max(0, Math.min(1, s.life)) * 0.65;
        ctx.strokeStyle = 'rgba(210,220,235,0.45)';
        ctx.lineWidth = Math.max(1, s.size * 0.18);
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(tx, ty);
        ctx.stroke();

        ctx.globalAlpha *= 0.9;
        ctx.fillStyle = (s.color || 'rgba(210,220,235,0.20)');
        ctx.beginPath();
        ctx.arc(s.x, s.y, Math.max(0.8, s.size * 0.08), 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;

    // Debris
    debris.forEach(d => {
        ctx.save();
        ctx.translate(d.x, d.y);
        ctx.rotate(d.rotation);
        ctx.fillStyle = d.color;
        ctx.globalAlpha = d.life;
        ctx.fillRect(-d.size/2, -d.size/4, d.size, d.size/2);
        ctx.restore();
    });
    ctx.globalAlpha = 1;

    // Particles (minimal ‚Äî no giant bubble blasts)
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        const r = Math.max(0.8, Math.min(3.2, p.size * 0.22)) * p.life;
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;

    // Sparks
    sparks.forEach(s => {
        ctx.fillStyle = s.color;
        ctx.shadowColor = s.color;
        ctx.shadowBlur = 5;
        ctx.globalAlpha = s.life;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size * s.life, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;    // Enemy lasers - regular projectile lasers (drones only now)
    enemyLasers.forEach(lz => {
        ctx.save();
        // Make underwater shark shots punch through the chemical haze
        if (lz.waterShot) {
            ctx.globalCompositeOperation = 'lighter';
        }
        ctx.globalAlpha = 0.95;
        const laserColor = lz.color || '#ff3355';
        
        // Outer glow layer
        ctx.strokeStyle = laserColor;
        ctx.lineWidth = lz.w * 2.5;
        ctx.shadowColor = laserColor;
        ctx.shadowBlur = 35;
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.moveTo(lz.x, lz.y);
        ctx.lineTo(lz.x - lz.vx * 3, lz.y - lz.vy * 3);
        ctx.stroke();
        
        // Main laser beam
        ctx.globalAlpha = 0.95;
        ctx.lineWidth = lz.w;
        ctx.shadowBlur = 25;
        ctx.beginPath();
        ctx.moveTo(lz.x, lz.y);
        ctx.lineTo(lz.x - lz.vx * 2.5, lz.y - lz.vy * 2.5);
        ctx.stroke();
        
        // Bright core
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = lz.w * 0.4;
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(lz.x, lz.y);
        ctx.lineTo(lz.x - lz.vx * 2, lz.y - lz.vy * 2);
        ctx.stroke();
        
        // Bright head
        ctx.fillStyle = '#ffffff';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(lz.x, lz.y, lz.w * 0.8, 0, Math.PI*2);
        ctx.fill();
        
        ctx.restore();
    });

    // INSTANT LIGHTNING BOLTS (spider tank attacks)
    enemies.forEach(enemy => {
        if (enemy.lightningAttack && enemy.lightningAttack.active) {
            const bolt = enemy.lightningAttack;
            const age = Date.now() - bolt.startTime;
            const fadeOut = 1.0 - (age / bolt.duration);
            
            if (fadeOut > 0) {
                ctx.save();
                
                const dx = bolt.toX - bolt.fromX;
                const dy = bolt.toY - bolt.fromY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const segments = Math.floor(dist / 15);
                
                // MAIN LIGHTNING BOLT
                ctx.globalAlpha = fadeOut * 0.9;
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 8;
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 40;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(bolt.fromX, bolt.fromY);
                
                // Jagged lightning path
                for (let i = 1; i <= segments; i++) {
                    const t = i / segments;
                    const baseX = bolt.fromX + dx * t;
                    const baseY = bolt.fromY + dy * t;
                    const perpX = -dy / dist;
                    const perpY = dx / dist;
                    const offset = (Math.random() - 0.5) * 25;
                    ctx.lineTo(baseX + perpX * offset, baseY + perpY * offset);
                }
                ctx.lineTo(bolt.toX, bolt.toY);
                ctx.stroke();
                
                // BRIGHT CORE
                ctx.globalAlpha = fadeOut;
                ctx.strokeStyle = '#ffaaaa';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 20;
                
                ctx.beginPath();
                ctx.moveTo(bolt.fromX, bolt.fromY);
                for (let i = 1; i <= segments; i++) {
                    const t = i / segments;
                    const baseX = bolt.fromX + dx * t;
                    const baseY = bolt.fromY + dy * t;
                    const perpX = -dy / dist;
                    const perpY = dx / dist;
                    const offset = (Math.random() - 0.5) * 15;
                    ctx.lineTo(baseX + perpX * offset, baseY + perpY * offset);
                }
                ctx.lineTo(bolt.toX, bolt.toY);
                ctx.stroke();
                
                // SECONDARY BOLTS (branching arcs)
                ctx.globalAlpha = fadeOut * 0.7;
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                
                for (let b = 0; b < 4; b++) {
                    const branchT = 0.3 + Math.random() * 0.4;
                    const branchX = bolt.fromX + dx * branchT;
                    const branchY = bolt.fromY + dy * branchT;
                    const branchAngle = Math.random() * Math.PI * 2;
                    const branchLen = 30 + Math.random() * 40;
                    const branchSegs = 3;
                    
                    ctx.beginPath();
                    ctx.moveTo(branchX, branchY);
                    for (let s = 1; s <= branchSegs; s++) {
                        const st = s / branchSegs;
                        const sx = branchX + Math.cos(branchAngle) * branchLen * st;
                        const sy = branchY + Math.sin(branchAngle) * branchLen * st;
                        const soff = (Math.random() - 0.5) * 15;
                        ctx.lineTo(sx + soff, sy + soff);
                    }
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }
    });

    // === TECH PLATFORMS & HEALTH PICKUPS ===
    techPlatforms.forEach(plat => drawTechPlatform(plat));
    healthPickups.forEach(hp => drawHealthPickup(hp));

    // Enemies
    enemies.forEach(enemy => {
        if (enemy.kind === 'trex') {
            drawMetallicTRex(enemy.x, enemy.y, enemy.width, enemy.height, enemy.legAngle, enemy.facingRight, enemy.health, enemy.maxHealth, enemy.isCharging, enemy.telegraphUntil, player.x, player.y - player.height * 0.35);
        } else {
            drawHumanoidBot(enemy.x, enemy.y, enemy.width, enemy.height, enemy.legAngle, enemy.facingRight, enemy.health, enemy.maxHealth);
        }
        // Laser warning tell - REMOVED (no dotted line)
        // Warning is visual from charging barrel glow only
    });

    // Drones (flying enemies)
    drones.forEach(drone => {
        drawDrone(drone);
    });

    // Water enemies (torpedo drones + crab walkers)
    if (isUnderwater) {
        // Draw power-up barrel
        if (waterBarrel && !waterBarrel.collected) {
            const bx = waterBarrel.x;
            const by = waterBarrel.y;
            const now = Date.now();
            const bob = Math.sin(now * 0.003) * 3;
            const pulse = 0.7 + Math.sin(now * 0.005) * 0.3;
            
            ctx.save();
            ctx.translate(bx, by + bob);
            
            // Glow aura
            ctx.shadowColor = `rgba(0, 255, 120, ${pulse * 0.6})`;
            ctx.shadowBlur = 15 + pulse * 10;
            
            // Barrel body
            const bw = 22, bh = 30;
            ctx.fillStyle = '#1a3520';
            ctx.beginPath();
            ctx.roundRect(-bw/2, -bh/2, bw, bh, 4);
            ctx.fill();
            
            // Metal bands
            ctx.fillStyle = '#2a5a35';
            ctx.fillRect(-bw/2, -bh/2 + 4, bw, 3);
            ctx.fillRect(-bw/2, bh/2 - 7, bw, 3);
            
            // Center cross/plus symbol (health)
            ctx.fillStyle = `rgba(0, 255, 120, ${0.7 + pulse * 0.3})`;
            ctx.fillRect(-2, -8, 4, 16);
            ctx.fillRect(-8, -2, 16, 4);
            
            // Highlight
            ctx.fillStyle = 'rgba(100, 255, 180, 0.15)';
            ctx.fillRect(-bw/2 + 2, -bh/2 + 2, bw/3, bh - 4);
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }
        
        waterEnemies.forEach(we => {
            if (we.kind === 'torpedo') {
                drawTorpedoDrone(we.x, we.y, we.width, we.height, we.facingRight, we.health, we.maxHealth);
            } else if (we.kind === 'crab') {
                drawCrabWalker(we.x, we.y, we.width, we.height, we.facingRight, we.legAngle, we.health, we.maxHealth, we.chargeProgress);
            }
        });
        drawWaterBubbles();
        
        // Draw lightning bolts
        if (window.waterLightningBolts && window.waterLightningBolts.length > 0) {
            const lNow = Date.now();
            window.waterLightningBolts = window.waterLightningBolts.filter(bolt => {
                const elapsed = lNow - bolt.startTime;
                if (elapsed > bolt.duration) return false;
                
                const life = 1 - elapsed / bolt.duration;
                const flash = life > 0.7 ? 1 : life / 0.7;
                
                ctx.save();
                // Main bolt ‚Äî thick bright red
                ctx.globalAlpha = flash * 0.9;
                ctx.strokeStyle = `rgba(255, ${60 + flash * 80}, ${20 + flash * 40}, ${flash})`;
                ctx.lineWidth = 0.7 + flash * 0.6;
                ctx.shadowColor = `rgba(255, 40, 20, ${flash})`;
                ctx.shadowBlur = 6 + flash * 8;
                ctx.lineJoin = 'bevel';
                ctx.beginPath();
                bolt.segments.forEach((s, i) => {
                    if (i === 0) ctx.moveTo(s.x, s.y);
                    else ctx.lineTo(s.x, s.y);
                });
                ctx.stroke();
                
                // Hot white core
                ctx.globalAlpha = flash * 0.6;
                ctx.strokeStyle = `rgba(255, ${200 + flash * 55}, ${150 + flash * 80}, ${flash})`;
                ctx.lineWidth = 0.75 + flash * 0.65;
                ctx.shadowBlur = 5;
                ctx.beginPath();
                bolt.segments.forEach((s, i) => {
                    if (i === 0) ctx.moveTo(s.x, s.y);
                    else ctx.lineTo(s.x, s.y);
                });
                ctx.stroke();
                
                // Branching arcs (smaller jagged offshoots)
                if (flash > 0.5) {
                    ctx.globalAlpha = (flash - 0.5) * 1.2;
                    ctx.strokeStyle = `rgba(255, 80, 40, ${flash * 0.5})`;
                    ctx.lineWidth = 1.5;
                    ctx.shadowBlur = 6;
                    for (let b = 0; b < 3; b++) {
                        const si = Math.floor(Math.random() * (bolt.segments.length - 1)) + 1;
                        const sp = bolt.segments[si];
                        ctx.beginPath();
                        ctx.moveTo(sp.x, sp.y);
                        ctx.lineTo(sp.x + (Math.random()-0.5) * 30, sp.y + (Math.random()-0.5) * 30);
                        ctx.lineTo(sp.x + (Math.random()-0.5) * 45, sp.y + (Math.random()-0.5) * 45);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
                return true;
            });
        }
    }

    // Rockets (drawn AFTER enemies so shots don‚Äôt get hidden by the spider tank)
    rockets.forEach(r => drawRocket(r));


    // Player
    if (gameRunning) {
        drawAimLine();

        // Safety: ensure no prior FX (fog/alpha/shadows) leak into the player render
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;

        drawPlayer(player.x, player.y, player.width, player.height, player.legAngle, player.isFlying, player.facingRight, player.armAngle);
        // DEBUG: Draw bright cyan circle at calculated gun barrel position
        if (window.debugGunX && window.debugGunY) {
            ctx.save();
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 20;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(window.debugGunX, window.debugGunY, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        // Shield visual - GOLD Energy bubble with lightning effects
        if (Date.now() < player.shieldUntil && player.shieldHits > 0) {
            const shieldTime = Date.now() * 0.003;
            const centerX = player.x;
            const centerY = player.y - player.height * 0.3;
            const radiusX = player.width * 1.2;
            const radiusY = player.height * 0.9;
            
            ctx.save();
            
            // Outer energy glow (pulsing) - GOLD
            const pulse = 0.6 + Math.sin(shieldTime * 2) * 0.2;
            ctx.globalAlpha = pulse * 0.8;
            ctx.strokeStyle = '#ffcc00';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ffaa00';
            ctx.shadowBlur = 25;
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner bubble gradient - GOLD
            ctx.globalAlpha = 0.15 + Math.sin(shieldTime * 3) * 0.05;
            const bubbleGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radiusY);
            bubbleGrad.addColorStop(0, 'rgba(255, 220, 100, 0.3)');
            bubbleGrad.addColorStop(0.5, 'rgba(255, 180, 50, 0.15)');
            bubbleGrad.addColorStop(0.8, 'rgba(200, 150, 0, 0.1)');
            bubbleGrad.addColorStop(1, 'rgba(255, 200, 0, 0.3)');
            ctx.fillStyle = bubbleGrad;
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, radiusX * 0.95, radiusY * 0.95, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Lightning arcs crawling on the shield surface - GOLD
            ctx.globalAlpha = 0.7 + Math.random() * 0.3;
            ctx.strokeStyle = '#ffffff';
            ctx.shadowColor = '#ffaa00';
            ctx.shadowBlur = 15;
            ctx.lineWidth = 2;
            
            // Draw 3-5 lightning arcs
            const numArcs = 3 + Math.floor(Math.random() * 3);
            for (let a = 0; a < numArcs; a++) {
                const startAngle = shieldTime + a * 1.5 + Math.random() * 0.5;
                const arcLength = 0.5 + Math.random() * 0.8;
                
                ctx.beginPath();
                let prevX = centerX + Math.cos(startAngle) * radiusX;
                let prevY = centerY + Math.sin(startAngle) * radiusY;
                ctx.moveTo(prevX, prevY);
                
                // Jagged lightning along the arc
                const steps = 6 + Math.floor(Math.random() * 4);
                for (let i = 1; i <= steps; i++) {
                    const angle = startAngle + (i / steps) * arcLength;
                    const jitterX = (Math.random() - 0.5) * 8;
                    const jitterY = (Math.random() - 0.5) * 8;
                    const x = centerX + Math.cos(angle) * radiusX + jitterX;
                    const y = centerY + Math.sin(angle) * radiusY + jitterY;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            // Occasional bright flash/spark - GOLD
            if (Math.random() < 0.15) {
                const sparkAngle = Math.random() * Math.PI * 2;
                const sparkX = centerX + Math.cos(sparkAngle) * radiusX * 0.9;
                const sparkY = centerY + Math.sin(sparkAngle) * radiusY * 0.9;
                
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = '#ffcc00';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(sparkX, sparkY, 3 + Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Energy field lines (subtle hexagonal pattern) - GOLD
            ctx.globalAlpha = 0.1;
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 1;
            ctx.shadowBlur = 0;
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + shieldTime * 0.2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(angle) * radiusX * 0.9, centerY + Math.sin(angle) * radiusY * 0.9);
                ctx.stroke();
            }
            
            ctx.restore();
        }
    }    ctx.restore();

    // Underwater blue tint overlay (screen-space, over everything)
    if (isUnderwater || waterTransitionAlpha > 0.01) {
        // Smooth transition
        const targetAlpha = isUnderwater ? 1 : 0;
        waterTransitionAlpha += (targetAlpha - waterTransitionAlpha) * 0.06;
        
        ctx.save();
        ctx.globalAlpha = waterTransitionAlpha * 0.10;
        ctx.fillStyle = '#003828';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Subtle caustic/wavy effect at top
        ctx.globalAlpha = waterTransitionAlpha * 0.05;
        const now = Date.now();
        for (let i = 0; i < 3; i++) {
            const waveY = 10 + Math.sin(now * 0.002 + i * 2) * 5;
            ctx.fillStyle = `rgba(60, 180, 120, ${0.12 + Math.sin(now * 0.003 + i) * 0.04})`;
            ctx.fillRect(0, waveY + i * 4, canvas.width, 2);
        }
        ctx.restore();
    }

    ctx.restore();
    
    // HARD CLAMP: Force player.x to never jump during draw
    if (typeof window.lastValidPlayerX === 'number' && isFinite(player.x)) {
        const maxJump = 30;
        const actualJump = player.x - window.lastValidPlayerX;
        
        if (Math.abs(actualJump) > maxJump) {
            console.warn(`Draw changed position from ${window.lastValidPlayerX.toFixed(0)} to ${player.x.toFixed(0)}, reverting`);
            player.x = window.lastValidPlayerX;
        }
    }
}

function updateHUD() {
    document.getElementById('scoreDisplay').textContent = score;
    document.getElementById('killsDisplay').textContent = kills;
    document.getElementById('healthFill').style.width = Math.max(0, player.health / player.maxHealth * 100) + '%';
    const fuelPct = (flyCharge / FLY_CHARGE_MAX * 100) + '%';
    document.getElementById('flyFill').style.width = fuelPct;
    // Update mobile fuel bar too
    const mf = document.getElementById('mobileFuelFill');
    if (mf) mf.style.width = fuelPct;

    // Enable/disable ability buttons (mobile)
    const ready = flyCharge >= FLY_CHARGE_MAX && !player.isFlying && Date.now() > player.shieldUntil;
    const fb = document.getElementById('flyBtn');
    const sb = document.getElementById('shieldBtn');
    if (fb) fb.style.opacity = ready ? '1' : '0.45';
    if (sb) sb.style.opacity = ready ? '1' : '0.45';
}

function gameOver() {
    gameRunning = false;
    // Return cursor to normal and hide the bullseye when the run ends
    document.body.classList.remove('inGame');
    document.getElementById('finalScore').textContent = kills + ' KILLS';
    document.getElementById('gameOverScreen').style.display = 'flex';
}

let introPlayed = false;
let introRunning = false;
let charSelectRunning = false;

let _startGameRunning = false;
function startGame() {
    if (_startGameRunning) return;
    _startGameRunning = true;
    // Reset guard after a short delay to prevent permanent lockout
    setTimeout(() => { _startGameRunning = false; }, 500);
    AudioSystem.resume();

    // Hide start screen immediately
    document.getElementById('startScreen').style.display = 'none';
    document.getElementById('gameOverScreen').style.display = 'none';

    if (!introPlayed) {
        introPlayed = true;
        introRunning = true;
        // Run the intro cinematic, then show character select
        playIntroCinematic(() => {
            introRunning = false;
            showCharacterSelect(() => {
                actualStartGame();
            });
        });
    } else {
        // REDEPLOY ‚Äî show character select again (quick)
        showCharacterSelect(() => {
            actualStartGame();
        });
    }
}

function actualStartGame() {
    // Switch to in-game cursor mode (hide OS cursor, show bullseye)
    document.body.classList.add('inGame');

    // Make sure the aim starts at the current pointer position (or center if unknown)
    if (!(typeof mouseX === 'number' && typeof mouseY === 'number')) {
        mouseX = canvas.width * 0.5;
        mouseY = canvas.height * 0.5;
    }
    updateBullseye();

    camX = 0;
    score = 0; kills = 0; flyCharge = 0; wave = 1;
    enemies = []; rockets = []; enemyLasers = []; particles = []; sparks = []; smokeTrails = []; debris = []; drones = [];
    waterEnemies = []; waterBubbles = []; isUnderwater = false; waterZoneUsed = false; underwaterZone = null; nextWaterEdgeX = 5500; waterTransitionAlpha = 0; window.waterLightningBolts = []; waterEntryTime = 0; waterBarrel = null;
    waterEncounterSpawned = false; waterEncounterCleared = false; waterZonePassed = false; waterWaveIndex = 0; waterTotalSpawned = 0; waterTotalKills = 0;
    techPlatforms = []; healthPickups = []; nextPlatformX = 1600;
    spawnTimer = 0; difficulty = 1; spawnInterval = 2800;

    initPlayer(); updateHUD();

    // First encounter starts immediately (no empty opening)
    nextEncounterX = player.x + 220;
    jumpHintShown = false;
    spawnEnemy();

    gameRunning = true;
    // Reset timing to prevent first-frame lag
    lastTime = performance.now();
    // Clear any stale input state
    isFiring = false;
    lastFireTime = 0;
    const _wa = document.getElementById('waveAnnounce');
    if (_wa) { _wa.style.display = ''; _wa.style.opacity = '0'; }
    setTimeout(() => { showWaveAnnouncement('‚ö† WAVE 1 ‚ö†'); }, 600);
}

// === CHARACTER SELECT SCREEN ===
function showCharacterSelect(onComplete) {
    charSelectRunning = true;
    // Hide wave announce during selection
    const _wa = document.getElementById('waveAnnounce');
    if (_wa) { _wa.style.display = 'none'; _wa.style.opacity = '0'; }
    const W = canvas.width, H = canvas.height;
    let hoveredIdx = -1;
    let confirmed = false;

    // Card layout ‚Äî 2x2 grid on small screens, 1x4 on wide screens
    const isMobile = W < 500;
    const cols = isMobile ? 2 : 4;
    const rows = isMobile ? 2 : 1;
    const cardW = isMobile ? Math.min(140, (W - 50) / 2 - 10) : Math.min(140, (W - 80) / 4 - 12);
    const cardH = cardW * 1.5;
    const gapX = isMobile ? 14 : 12;
    const gapY = isMobile ? 14 : 0;
    const totalW = cols * cardW + (cols - 1) * gapX;
    const totalH = rows * cardH + (rows - 1) * gapY;
    const startX = (W - totalW) / 2;
    const cardStartY = isMobile ? H * 0.12 : H * 0.22;

    function getCardRect(i) {
        const col = i % cols;
        const row = Math.floor(i / cols);
        return { 
            x: startX + col * (cardW + gapX), 
            y: cardStartY + row * (cardH + gapY), 
            w: cardW, h: cardH 
        };
    }

    // Draw a mini mech preview for each character
    function drawMiniMech(cx, cy, ch, scale) {
        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(scale, scale);

        // Body glow
        ctx.shadowColor = `rgba(${ch.trimRGB}, 0.7)`;
        ctx.shadowBlur = 18;

        // Legs
        const isFem = (ch.id === 'terminus');
        ctx.fillStyle = '#1a2a3a';
        if (isFem) {
            ctx.fillRect(-12, 20, 8, 32);
            ctx.fillRect(4, 20, 8, 32);
            ctx.fillStyle = '#0b111a';
            ctx.fillRect(-14, 50, 12, 6);
            ctx.fillRect(2, 50, 12, 6);
        } else {
            ctx.fillRect(-14, 20, 10, 32);
            ctx.fillRect(4, 20, 10, 32);
            ctx.fillStyle = '#0b111a';
            ctx.fillRect(-18, 50, 16, 6);
            ctx.fillRect(2, 50, 16, 6);
        }

        // Knee joints
        ctx.fillStyle = ch.trim;
        ctx.globalAlpha = 0.7;
        ctx.beginPath(); ctx.arc(-9, 34, 3, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(9, 34, 3, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1;

        // Torso
        const tGrad = ctx.createLinearGradient(-20, -20, 20, 20);
        tGrad.addColorStop(0, '#0b111a');
        tGrad.addColorStop(0.4, '#223246');
        tGrad.addColorStop(0.8, '#4e6a86');
        tGrad.addColorStop(1, '#0b111a');
        ctx.fillStyle = tGrad;

        if (isFem) {
            // Hourglass torso for preview
            ctx.beginPath();
            ctx.moveTo(-18, -22);
            ctx.lineTo(18, -22);
            ctx.quadraticCurveTo(21, -22, 21, -18);
            ctx.lineTo(20, -8);
            ctx.quadraticCurveTo(10, 2, 8, 0);   // pinch waist right
            ctx.quadraticCurveTo(10, 4, 22, 18);  // flare hip right
            ctx.quadraticCurveTo(22, 22, 18, 22);
            ctx.lineTo(-18, 22);
            ctx.quadraticCurveTo(-22, 22, -22, 18);
            ctx.quadraticCurveTo(-10, 4, -8, 0);  // flare hip left
            ctx.quadraticCurveTo(-10, 2, -20, -8); // pinch waist left
            ctx.lineTo(-21, -18);
            ctx.quadraticCurveTo(-21, -22, -18, -22);
            ctx.closePath();
            ctx.fill();
            // Waist belt accent
            ctx.strokeStyle = `rgba(${ch.trimRGB}, 0.5)`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(-9, 0);
            ctx.quadraticCurveTo(0, 2, 9, 0);
            ctx.stroke();
        } else {
            ctx.beginPath(); ctx.roundRect(-20, -22, 40, 44, 6); ctx.fill();
        }

        // Backpack
        ctx.fillStyle = '#0b111a';
        ctx.fillRect(-16, -12, 32, 36);

        // Reactor core glow
        ctx.shadowColor = ch.trim;
        ctx.shadowBlur = 16;
        const coreGrad = ctx.createRadialGradient(0, 2, 0, 0, 2, 18);
        coreGrad.addColorStop(0, `rgba(${ch.glowRGB}, 0.8)`);
        coreGrad.addColorStop(0.5, `rgba(${ch.glow2RGB}, 0.3)`);
        coreGrad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = coreGrad;
        ctx.beginPath(); ctx.arc(0, 2, 18, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = 'rgba(10,16,24,0.9)';
        ctx.beginPath(); ctx.arc(0, 2, 8, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = `rgba(${ch.glowRGB}, 0.8)`;
        ctx.beginPath(); ctx.arc(0, 2, 3, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;

        // Shoulder joint
        ctx.fillStyle = '#4e6a86';
        ctx.beginPath(); ctx.arc(18, -12, 6, 0, Math.PI * 2); ctx.fill();

        // Arm / cannon
        ctx.fillStyle = tGrad;
        ctx.save();
        ctx.translate(18, -12);
        ctx.rotate(0.3);
        ctx.fillRect(0, -4, 22, 8);
        ctx.fillStyle = '#0b111a';
        ctx.fillRect(16, -5, 14, 10);
        // Barrel
        ctx.fillStyle = '#050a10';
        ctx.fillRect(28, -2, 10, 4);
        // Muzzle tip
        ctx.fillStyle = ch.trim;
        ctx.globalAlpha = 0.5;
        ctx.fillRect(36, -1, 3, 2);
        ctx.globalAlpha = 1;
        ctx.restore();

        // === HELMET (character-specific) ===
        const headY = -34;
        ctx.shadowColor = `rgba(${ch.trimRGB}, 0.5)`;
        ctx.shadowBlur = 8;

        if (ch.helmet === 'angular') {
            // Phantom ‚Äî swept angular
            ctx.fillStyle = tGrad;
            ctx.beginPath();
            ctx.moveTo(-12, headY + 20); ctx.lineTo(-16, headY + 6);
            ctx.lineTo(-12, headY - 2); ctx.lineTo(0, headY - 5);
            ctx.lineTo(12, headY - 2); ctx.lineTo(16, headY + 6);
            ctx.lineTo(12, headY + 20); ctx.closePath(); ctx.fill();
            // Fins
            ctx.fillStyle = '#0b111a';
            ctx.beginPath(); ctx.moveTo(-12, headY); ctx.lineTo(-20, headY - 8); ctx.lineTo(-14, headY + 5); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(12, headY); ctx.lineTo(20, headY - 8); ctx.lineTo(14, headY + 5); ctx.closePath(); ctx.fill();
        } else if (ch.helmet === 'heavy') {
            // Spector 9 ‚Äî heavy with jaw guard
            ctx.fillStyle = tGrad;
            ctx.beginPath(); ctx.roundRect(-16, headY, 32, 22, 4); ctx.fill();
            // Brow ridge
            ctx.fillStyle = '#0b111a';
            ctx.beginPath(); ctx.roundRect(-18, headY - 2, 36, 8, [4,4,0,0]); ctx.fill();
            // Jaw guards
            ctx.fillStyle = '#223246';
            ctx.beginPath(); ctx.moveTo(-16, headY + 14); ctx.lineTo(-20, headY + 22); ctx.lineTo(-10, headY + 20); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(16, headY + 14); ctx.lineTo(20, headY + 22); ctx.lineTo(10, headY + 20); ctx.closePath(); ctx.fill();
        } else if (ch.helmet === 'sleek') {
            // Terminus ‚Äî sleek contoured
            ctx.fillStyle = tGrad;
            ctx.beginPath();
            ctx.moveTo(-10, headY + 20); ctx.lineTo(-14, headY + 8);
            ctx.lineTo(-12, headY); ctx.lineTo(-6, headY - 3);
            ctx.lineTo(6, headY - 3); ctx.lineTo(12, headY);
            ctx.lineTo(14, headY + 8); ctx.lineTo(10, headY + 20);
            ctx.closePath(); ctx.fill();
            // Ponytail
            if (ch.hair) {
                const t = Date.now() * 0.003;
                const sway = Math.sin(t) * 2;
                ctx.strokeStyle = '#2a1828';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(-1, headY + 4);
                ctx.quadraticCurveTo(-2 + sway * 0.5, headY + 22, -3 + sway, headY + 38);
                ctx.stroke();
                ctx.strokeStyle = '#3a2038';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.moveTo(0, headY + 4);
                ctx.quadraticCurveTo(-1 + sway * 0.6, headY + 20, -2 + sway, headY + 36);
                ctx.stroke();
                ctx.strokeStyle = `rgba(${ch.trimRGB}, 0.15)`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(1, headY + 5);
                ctx.quadraticCurveTo(0 + sway * 0.4, headY + 18, -1 + sway, headY + 34);
                ctx.stroke();
            }
        } else {
            // Ramidus ‚Äî standard rounded
            ctx.fillStyle = tGrad;
            ctx.beginPath(); ctx.roundRect(-14, headY, 28, 20, 6); ctx.fill();
        }

        // Visor (all)
        ctx.shadowColor = 'rgba(255, 204, 64, 0.8)';
        ctx.shadowBlur = 12;
        ctx.fillStyle = 'rgba(255, 204, 64, 0.7)';
        ctx.beginPath(); ctx.roundRect(-9, headY + 7, 18, 4, 4); ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();
    }

    function drawFrame() {
        if (confirmed) return;
        const now = Date.now();

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        // Dark background
        ctx.fillStyle = '#040810';
        ctx.fillRect(0, 0, W, H);

        // Subtle stars
        ctx.globalAlpha = 0.4;
        ctx.fillStyle = '#d0e8ff';
        for (let i = 0; i < 60; i++) {
            const sx = (i * 137.5 + 50) % W;
            const sy = (i * 89.3 + 20) % (H * 0.75);
            const ss = 0.5 + (i % 3) * 0.5;
            ctx.beginPath(); ctx.arc(sx, sy, ss, 0, Math.PI * 2); ctx.fill();
        }
        ctx.globalAlpha = 1;

        // Title
        ctx.textAlign = 'center';
        ctx.fillStyle = '#c0e8ff';
        ctx.font = `800 ${isMobile ? 16 : 24}px system-ui, -apple-system, Arial`;
        ctx.fillText('SELECT OPERATIVE', W / 2, isMobile ? H * 0.06 : H * 0.12);

        ctx.font = `400 ${isMobile ? 10 : 13}px system-ui, Arial`;
        ctx.fillStyle = 'rgba(180, 210, 240, 0.5)';
        ctx.fillText('Choose your mech suit', W / 2, isMobile ? H * 0.095 : H * 0.17);

        // Draw character cards
        for (let i = 0; i < CHARACTERS.length; i++) {
            const ch = CHARACTERS[i];
            const r = getCardRect(i);
            const isSelected = (i === selectedCharIndex);
            const isHovered = (i === hoveredIdx);
            // When hovering a different card, suppress the selected card's highlight
            const hoveringOtherCard = (hoveredIdx >= 0 && hoveredIdx < CHARACTERS.length && hoveredIdx !== selectedCharIndex);
            const showActive = isHovered || (isSelected && !hoveringOtherCard);

            // Card background
            ctx.save();
            if (showActive) {
                ctx.shadowColor = ch.trim;
                ctx.shadowBlur = 18;
            }
            ctx.fillStyle = showActive ? 'rgba(255,255,255,0.08)' : 'rgba(255,255,255,0.03)';
            ctx.beginPath(); ctx.roundRect(r.x, r.y, r.w, r.h, 10); ctx.fill();

            // Border ‚Äî active card shows its color
            ctx.strokeStyle = showActive ? ch.trim : 'rgba(255,255,255,0.06)';
            ctx.lineWidth = showActive ? 2 : 1;
            ctx.beginPath(); ctx.roundRect(r.x, r.y, r.w, r.h, 10); ctx.stroke();
            ctx.restore();

            // Character preview ‚Äî use actual drawPlayer for accurate look
            const prevIdx = selectedCharIndex;
            selectedCharIndex = i;
            ctx.save();
            // Clip to card to prevent glow bleed
            ctx.beginPath();
            ctx.roundRect(r.x + 1, r.y + 1, r.w - 2, r.h - 2, 9);
            ctx.clip();
            const previewScale = Math.min(cardW / 120, 0.75);
            const prevX = r.x + r.w / 2;
            const prevY = r.y + r.h * 0.48;
            const idleAngle = Math.sin(Date.now() * 0.002 + i * 1.5) * 0.12;
            ctx.scale(previewScale, previewScale);
            drawPlayer(prevX / previewScale, prevY / previewScale, 50, 80, idleAngle, false, true, 0.2);
            ctx.restore();
            selectedCharIndex = prevIdx;

            // Name
            ctx.textAlign = 'center';
            ctx.fillStyle = showActive ? ch.trim : '#a0b8d0';
            ctx.font = `700 ${Math.max(10, cardW * 0.1)}px system-ui, Arial`;
            ctx.fillText(ch.name, r.x + r.w / 2, r.y + r.h * 0.82);

        }

        // DEPLOY button ‚Äî large, easy to hit
        const btnW = isMobile ? Math.min(260, W * 0.65) : Math.min(300, W * 0.5);
        const btnH = isMobile ? 50 : 56;
        const btnX = (W - btnW) / 2;
        const lastCardBottom = getCardRect(CHARACTERS.length - 1);
        const btnY = isMobile 
            ? Math.min(lastCardBottom.y + lastCardBottom.h + 16, H * 0.82) 
            : H * 0.78;
        const activeIdx = (hoveredIdx >= 0 && hoveredIdx < CHARACTERS.length) ? hoveredIdx : selectedCharIndex;
        const activeCh = CHARACTERS[activeIdx];
        const btnHover = (hoveredIdx === -2);

        ctx.save();
        ctx.shadowColor = activeCh.trim;
        ctx.shadowBlur = btnHover ? 24 : 14;
        ctx.fillStyle = btnHover ? `rgba(${activeCh.trimRGB}, 0.3)` : `rgba(${activeCh.trimRGB}, 0.15)`;
        ctx.beginPath(); ctx.roundRect(btnX, btnY, btnW, btnH, 10); ctx.fill();
        ctx.strokeStyle = activeCh.trim;
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.roundRect(btnX, btnY, btnW, btnH, 10); ctx.stroke();
        ctx.restore();

        ctx.textAlign = 'center';
        ctx.fillStyle = activeCh.trim;
        ctx.font = `800 ${isMobile ? 18 : 22}px system-ui, Arial`;
        ctx.fillText('‚ñ∂ DEPLOY', W / 2, btnY + (isMobile ? 32 : 36));

        // Hint
        ctx.fillStyle = 'rgba(140, 170, 200, 0.35)';
        ctx.font = `400 ${isMobile ? 10 : 12}px system-ui, Arial`;
        ctx.fillText(isMobile ? 'Tap a suit, then tap DEPLOY' : 'Select a suit, then hit DEPLOY or press Enter', W / 2, btnY + btnH + 20);
        ctx.textAlign = 'left';

        requestAnimationFrame(drawFrame);
    }

    // Hit testing
    function getHit(ex, ey) {
        // Check deploy button FIRST (priority over cards if overlap)
        const btnW = isMobile ? Math.min(260, W * 0.65) : Math.min(300, W * 0.5);
        const btnH = isMobile ? 50 : 56;
        const btnX = (W - btnW) / 2;
        const lastCardBottom = getCardRect(CHARACTERS.length - 1);
        const btnY = isMobile 
            ? Math.min(lastCardBottom.y + lastCardBottom.h + 16, H * 0.82)
            : H * 0.78;
        const pad = isMobile ? 18 : 12;
        if (ex >= btnX - pad && ex <= btnX + btnW + pad && ey >= btnY - pad && ey <= btnY + btnH + pad) return { type: 'deploy' };
        // Check cards (with touch padding on mobile)
        const cardPad = isMobile ? 6 : 0;
        for (let i = 0; i < CHARACTERS.length; i++) {
            const r = getCardRect(i);
            if (ex >= r.x - cardPad && ex <= r.x + r.w + cardPad && ey >= r.y - cardPad && ey <= r.y + r.h + cardPad) return { type: 'card', idx: i };
        }
        return null;
    }

    function onMove(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const ex = (e.clientX - rect.left) * scaleX;
        const ey = (e.clientY - rect.top) * scaleY;
        const hit = getHit(ex, ey);
        if (hit && hit.type === 'card') hoveredIdx = hit.idx;
        else if (hit && hit.type === 'deploy') hoveredIdx = -2;
        else hoveredIdx = -1;
        canvas.style.cursor = hit ? 'pointer' : 'default';
    }

    function onClick(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        // Get coordinates ‚Äî handle mouse, touchstart, and touchend
        let cx, cy;
        if (e.clientX !== undefined && e.clientY !== undefined) {
            cx = e.clientX; cy = e.clientY;
        } else if (e.changedTouches && e.changedTouches.length > 0) {
            cx = e.changedTouches[0].clientX; cy = e.changedTouches[0].clientY;
        } else if (e.touches && e.touches.length > 0) {
            cx = e.touches[0].clientX; cy = e.touches[0].clientY;
        } else {
            return; // no valid coordinates
        }
        const ex = (cx - rect.left) * scaleX;
        const ey = (cy - rect.top) * scaleY;
        const hit = getHit(ex, ey);
        if (hit && hit.type === 'card') {
            selectedCharIndex = hit.idx;
        } else if (hit && hit.type === 'deploy') {
            doDeploy();
        }
    }

    function doDeploy() {
        if (confirmed) return;
        confirmed = true;
        canvas.removeEventListener('mousemove', onMove);
        canvas.removeEventListener('click', onClick);
        canvas.removeEventListener('touchstart', onTouch);
        canvas.removeEventListener('touchend', onTouch);
        document.removeEventListener('keydown', onKey);
        canvas.style.cursor = '';
        charSelectRunning = false;
        onComplete();
    }

    function onKey(e) {
        if (confirmed) return;
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            doDeploy();
        } else if (e.key === 'ArrowLeft' || e.key === 'a') {
            selectedCharIndex = (selectedCharIndex - 1 + CHARACTERS.length) % CHARACTERS.length;
        } else if (e.key === 'ArrowRight' || e.key === 'd') {
            selectedCharIndex = (selectedCharIndex + 1) % CHARACTERS.length;
        }
    }

    // Touch handler ‚Äî use touchstart for immediate feedback
    function onTouch(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        let cx, cy;
        if (e.changedTouches && e.changedTouches.length > 0) {
            cx = e.changedTouches[0].clientX; cy = e.changedTouches[0].clientY;
        } else if (e.touches && e.touches.length > 0) {
            cx = e.touches[0].clientX; cy = e.touches[0].clientY;
        } else {
            return;
        }
        const ex = (cx - rect.left) * scaleX;
        const ey = (cy - rect.top) * scaleY;
        const hit = getHit(ex, ey);
        if (hit && hit.type === 'card') {
            selectedCharIndex = hit.idx;
        } else if (hit && hit.type === 'deploy') {
            doDeploy();
        }
    }

    canvas.addEventListener('mousemove', onMove);
    canvas.addEventListener('click', onClick);
    canvas.addEventListener('touchstart', onTouch, { passive: false });
    canvas.addEventListener('touchend', onTouch, { passive: false });
    document.addEventListener('keydown', onKey);

    requestAnimationFrame(drawFrame);
}

// === DEPLOY INTRO CINEMATIC ===
function playIntroCinematic(onComplete) {
    const W = canvas.width, H = canvas.height;
    const startTime = Date.now();
    const TOTAL_MS = 28000;
    let skipRequested = false;

    // Hide any lingering wave announcement
    const waveEl = document.getElementById('waveAnnounce');
    if (waveEl) { waveEl.style.display = 'none'; waveEl.style.opacity = '0'; waveEl.textContent = ''; }

    // === INTRO AUDIO (Web Audio API) ===
    let introNodes = [];
    function scheduleIntroAudio() {
        const ac = AudioSystem.ctx;
        if (!ac || !AudioSystem.enabled) return;
        const t0 = ac.currentTime;

        // 1) Deep space drone
        const drone = ac.createOscillator();
        const droneGain = ac.createGain();
        const droneLFO = ac.createOscillator();
        const droneLFOGain = ac.createGain();
        drone.type = 'sawtooth';
        drone.frequency.setValueAtTime(55, t0);
        drone.frequency.linearRampToValueAtTime(48, t0 + 10);
        droneLFO.type = 'sine';
        droneLFO.frequency.setValueAtTime(0.3, t0);
        droneLFOGain.gain.setValueAtTime(8, t0);
        droneLFO.connect(droneLFOGain);
        droneLFOGain.connect(drone.frequency);
        const droneFilter = ac.createBiquadFilter();
        droneFilter.type = 'lowpass';
        droneFilter.frequency.setValueAtTime(200, t0);
        droneFilter.frequency.linearRampToValueAtTime(120, t0 + 10);
        drone.connect(droneFilter);
        droneFilter.connect(droneGain);
        droneGain.connect(ac.destination);
        droneGain.gain.setValueAtTime(0, t0);
        droneGain.gain.linearRampToValueAtTime(0.12, t0 + 2);
        droneGain.gain.setValueAtTime(0.12, t0 + 20);
        droneGain.gain.linearRampToValueAtTime(0, t0 + 26);
        drone.start(t0); droneLFO.start(t0);
        drone.stop(t0 + 27); droneLFO.stop(t0 + 27);
        introNodes.push(drone, droneLFO);

        // 2) Sub bass hit at "They rebelled" (~12.4s)
        const sub = ac.createOscillator();
        const subGain = ac.createGain();
        sub.type = 'sine';
        sub.frequency.setValueAtTime(35, t0 + 12.4);
        sub.connect(subGain); subGain.connect(ac.destination);
        subGain.gain.setValueAtTime(0, t0);
        subGain.gain.setValueAtTime(0.25, t0 + 12.4);
        subGain.gain.exponentialRampToValueAtTime(0.01, t0 + 14);
        sub.start(t0 + 12.4); sub.stop(t0 + 15);
        introNodes.push(sub);

        // 3) Engine rumble (~5s onward)
        const eng = ac.createOscillator();
        const engGain = ac.createGain();
        eng.type = 'triangle';
        eng.frequency.setValueAtTime(80, t0 + 5);
        eng.frequency.linearRampToValueAtTime(50, t0 + 24);
        eng.connect(engGain); engGain.connect(ac.destination);
        engGain.gain.setValueAtTime(0, t0);
        engGain.gain.linearRampToValueAtTime(0.06, t0 + 7);
        engGain.gain.setValueAtTime(0.06, t0 + 22);
        engGain.gain.linearRampToValueAtTime(0, t0 + 25);
        eng.start(t0 + 5); eng.stop(t0 + 26);
        introNodes.push(eng);
        // Engine noise texture
        const noiseBuf = ac.createBuffer(1, ac.sampleRate * 21, ac.sampleRate);
        const nd = noiseBuf.getChannelData(0);
        for (let i = 0; i < nd.length; i++) nd[i] = (Math.random() * 2 - 1);
        const engNoise = ac.createBufferSource();
        engNoise.buffer = noiseBuf;
        const engFilter = ac.createBiquadFilter();
        engFilter.type = 'bandpass';
        engFilter.frequency.setValueAtTime(150, t0);
        engFilter.Q.setValueAtTime(2, t0);
        const engNoiseGain = ac.createGain();
        engNoise.connect(engFilter); engFilter.connect(engNoiseGain);
        engNoiseGain.connect(ac.destination);
        engNoiseGain.gain.setValueAtTime(0, t0);
        engNoiseGain.gain.linearRampToValueAtTime(0.04, t0 + 8);
        engNoiseGain.gain.setValueAtTime(0.04, t0 + 22);
        engNoiseGain.gain.linearRampToValueAtTime(0, t0 + 25);
        engNoise.start(t0 + 5); engNoise.stop(t0 + 26);
        introNodes.push(engNoise);

        // 4) Landing thud (~19s)
        const thudOsc = ac.createOscillator();
        const thudGain = ac.createGain();
        thudOsc.type = 'sine';
        thudOsc.frequency.setValueAtTime(60, t0 + 25);
        thudOsc.frequency.exponentialRampToValueAtTime(25, t0 + 25.6);
        thudOsc.connect(thudGain); thudGain.connect(ac.destination);
        thudGain.gain.setValueAtTime(0, t0);
        thudGain.gain.setValueAtTime(0.3, t0 + 25);
        thudGain.gain.exponentialRampToValueAtTime(0.01, t0 + 25.8);
        thudOsc.start(t0 + 25); thudOsc.stop(t0 + 26);
        introNodes.push(thudOsc);
        // Thud noise burst
        const thudNBuf = ac.createBuffer(1, ac.sampleRate * 0.5, ac.sampleRate);
        const tnd = thudNBuf.getChannelData(0);
        for (let i = 0; i < tnd.length; i++) tnd[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / tnd.length, 3);
        const thudNoise = ac.createBufferSource();
        thudNoise.buffer = thudNBuf;
        const thudNGain = ac.createGain();
        const thudNFilter = ac.createBiquadFilter();
        thudNFilter.type = 'lowpass';
        thudNFilter.frequency.setValueAtTime(300, t0 + 25);
        thudNoise.connect(thudNFilter); thudNFilter.connect(thudNGain);
        thudNGain.connect(ac.destination);
        thudNGain.gain.setValueAtTime(0.15, t0 + 25);
        thudNGain.gain.exponentialRampToValueAtTime(0.01, t0 + 25.6);
        thudNoise.start(t0 + 25);
        introNodes.push(thudNoise);

        // 5) Text reveal shimmer at each story beat
        [1.0, 5.0, 7.8, 10.2, 12.4, 15.5, 18.5, 22.0].forEach(beat => {
            const sw = ac.createOscillator();
            const swGain = ac.createGain();
            sw.type = 'sine';
            sw.frequency.setValueAtTime(3200, t0 + beat);
            sw.frequency.exponentialRampToValueAtTime(1200, t0 + beat + 0.3);
            sw.connect(swGain); swGain.connect(ac.destination);
            swGain.gain.setValueAtTime(0.03, t0 + beat);
            swGain.gain.exponentialRampToValueAtTime(0.001, t0 + beat + 0.4);
            sw.start(t0 + beat); sw.stop(t0 + beat + 0.5);
            introNodes.push(sw);
        });
    }

    function stopIntroAudio() {
        introNodes.forEach(n => { try { n.stop(); } catch(e) {} });
        introNodes = [];
    }

    scheduleIntroAudio();

    const storyLines = [
        { t: 1000,  text: "YEAR 2187",                                   size: 34, y: 0.16, fade: 2200, color: "#00ffcc" },
        { t: 5000,  text: "Humanity built machines of supreme intelligence‚Ä¶", size: 18, y: 0.34, fade: 2000 },
        { t: 7800,  text: "They learned. They evolved.",                 size: 18, y: 0.40, fade: 1800 },
        { t: 10200, text: "They became sentient.",                       size: 22, y: 0.34, fade: 1600 },
        { t: 12400, text: "They rebelled.",                              size: 22, y: 0.40, fade: 1600, color: "#ff4444" },
        { t: 15500, text: "From a fortress moon in a distant galaxy, they struck Earth.", size: 18, y: 0.34, fade: 2000 },
        { t: 18500, text: "Civilization fell. The colonies are all that remain.",  size: 18, y: 0.40, fade: 2000 },
        { t: 22000, text: "YOU ARE HUMANITY'S LAST OFFENSIVE.",          size: 22, y: 0.50, fade: 2200 },
    ];


    // Stars (persistent)
    const stars = [];
    for (let i = 0; i < 200; i++) {
        stars.push({ x: Math.random() * W, y: Math.random() * H * 0.85, s: 0.5 + Math.random() * 1.8, b: Math.random() });
    }

    // Allow skip
    function onSkip() { skipRequested = true; }
    document.addEventListener('keydown', onSkip, { once: true });
    canvas.addEventListener('click', onSkip, { once: true });
    canvas.addEventListener('touchstart', onSkip, { once: true });

    function drawFrame() {
        const elapsed = Date.now() - startTime;
        const t = Math.min(elapsed / TOTAL_MS, 1);

        if (skipRequested || t >= 1) {
            document.removeEventListener('keydown', onSkip);
            canvas.removeEventListener('click', onSkip);
            canvas.removeEventListener('touchstart', onSkip);
            stopIntroAudio();
            onComplete();
            return;
        }

        ctx.setTransform(1, 0, 0, 1, 0, 0);

        // Black space background
        ctx.fillStyle = '#020408';
        ctx.fillRect(0, 0, W, H);

        // Stars (twinkle)
        const now = Date.now();
        for (const st of stars) {
            const twinkle = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(now * 0.003 + st.b * 20));
            ctx.globalAlpha = twinkle * 0.8;
            ctx.fillStyle = '#d0e8ff';
            ctx.beginPath();
            ctx.arc(st.x, st.y, st.s, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;

        // Moon surface ‚Äî matches gameplay black metallic ground
        const moonReveal = Math.min(1, Math.max(0, (elapsed - 2000) / 6000));
        const moonH = 40 + moonReveal * (H * 0.18);
        const moonY = H - moonH;

        // Black metallic base (same as gameplay ground)
        const groundGrad = ctx.createLinearGradient(0, moonY, 0, H);
        groundGrad.addColorStop(0, '#0a0a0a');
        groundGrad.addColorStop(0.5, '#050505');
        groundGrad.addColorStop(1, '#000000');
        ctx.fillStyle = groundGrad;
        ctx.fillRect(0, moonY, W, moonH);

        // Metal panel seams (horizontal)
        ctx.save();
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 2;
        for (let i = 0; i < 6; i++) {
            const y = moonY + i * 15;
            if (y > H) break;
            ctx.globalAlpha = 0.3 * moonReveal;
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
        }
        // Vertical panel seams
        ctx.globalAlpha = 0.25 * moonReveal;
        ctx.strokeStyle = '#151515';
        ctx.lineWidth = 3;
        for (let x = 0; x < W + 120; x += 120) {
            ctx.beginPath();
            ctx.moveTo(x, moonY);
            ctx.lineTo(W / 2 + (x - W / 2) * 1.5, H);
            ctx.stroke();
        }
        ctx.restore();

        // Wispy fog
        if (moonReveal > 0.3) {
            ctx.save();
            const fogTime = now * 0.0004;
            ctx.globalAlpha = 0.06 * moonReveal;
            for (let i = 0; i < 15; i++) {
                const wispX = (i * 97.3 + fogTime * (50 + i * 3)) % (W + 200) - 100;
                const wispY = moonY + 10 + Math.sin(fogTime * 1.2 + i * 0.9) * 12;
                const wispSize = 50 + (i % 7) * 20;
                const wispGrad = ctx.createRadialGradient(wispX, wispY, 0, wispX, wispY, wispSize);
                wispGrad.addColorStop(0, 'rgba(160, 160, 180, 0.3)');
                wispGrad.addColorStop(0.5, 'rgba(130, 130, 150, 0.15)');
                wispGrad.addColorStop(1, 'rgba(100, 100, 120, 0)');
                ctx.fillStyle = wispGrad;
                ctx.beginPath(); ctx.arc(wispX, wispY, wispSize, 0, Math.PI * 2); ctx.fill();
            }
            ctx.restore();
        }

        // Metal rivets
        ctx.globalAlpha = moonReveal;
        ctx.fillStyle = '#0a0a0a';
        for (let x = 30; x < W; x += 60) {
            for (let i = 0; i < 3; i++) {
                const y = moonY + 5 + i * 20;
                if (y > H) break;
                ctx.globalAlpha = 0.7 * moonReveal;
                ctx.beginPath(); ctx.arc(x, y, 2.5, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#2a2a2a';
                ctx.globalAlpha = 0.15 * moonReveal;
                ctx.beginPath(); ctx.arc(x - 0.8, y - 0.8, 1.2, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#0a0a0a';
            }
        }
        ctx.globalAlpha = 1;

        // === WARSHIP (cinematic heavy assault cruiser) ===
        const landPhase = Math.min(1, Math.max(0, (elapsed - 5000) / 20000));
        const eased = landPhase * landPhase * (3 - 2 * landPhase);
        const shipX = W * 0.5;
        const shipTopY = -120;
        const shipLandY = moonY - 52;
        const shipY = shipTopY + (shipLandY - shipTopY) * eased;
        const shipScale = (0.7 + 0.3 * eased) * 1.8;
        const engineGlow = Math.max(0, 1 - landPhase * 1.2);
        const bankAngle = engineGlow > 0.05 ? Math.sin(now * 0.0006) * 0.02 * (1 - landPhase) : 0;

        ctx.save();
        ctx.translate(shipX, shipY);
        ctx.rotate(bankAngle);
        ctx.scale(shipScale, shipScale);

        // -- ATMOSPHERIC ENTRY GLOW --
        if (engineGlow > 0.2) {
            ctx.globalAlpha = engineGlow * 0.04;
            const atmoGrad = ctx.createRadialGradient(0, 0, 20, 0, 0, 160);
            atmoGrad.addColorStop(0, 'rgba(140, 200, 255, 0.3)');
            atmoGrad.addColorStop(0.5, 'rgba(60, 120, 200, 0.1)');
            atmoGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = atmoGrad;
            ctx.fillRect(-170, -100, 340, 250);
            ctx.globalAlpha = 1;
        }

        // -- ENGINE EXHAUST --
        if (engineGlow > 0.05) {
            ctx.globalAlpha = engineGlow * 0.45;
            const cGrad = ctx.createRadialGradient(0, 52, 1, 0, 78, 35 + engineGlow * 22);
            cGrad.addColorStop(0, 'rgba(220, 245, 255, 0.9)');
            cGrad.addColorStop(0.12, 'rgba(120, 200, 255, 0.6)');
            cGrad.addColorStop(0.4, 'rgba(30, 100, 220, 0.2)');
            cGrad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = cGrad;
            ctx.fillRect(-18, 48, 36, 80 + engineGlow * 35);

            for (const sx of [-58, 58]) {
                const g = ctx.createRadialGradient(sx, 38, 1, sx, 56, 18 + engineGlow * 12);
                g.addColorStop(0, 'rgba(180, 240, 255, 0.7)');
                g.addColorStop(0.3, 'rgba(40, 160, 220, 0.3)');
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = g;
                ctx.fillRect(sx - 12, 34, 24, 55 + engineGlow * 20);
            }

            // Under-hull engine light cast
            ctx.globalAlpha = engineGlow * 0.12;
            const bellyCast = ctx.createLinearGradient(0, 30, 0, -10);
            bellyCast.addColorStop(0, 'rgba(100, 180, 255, 0.5)');
            bellyCast.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = bellyCast;
            ctx.fillRect(-80, -10, 160, 50);
            ctx.globalAlpha = 1;
        }

        // -- GROUND SHADOW --
        if (landPhase > 0.3) {
            ctx.globalAlpha = Math.min(0.25, (landPhase - 0.3) * 0.5);
            const shadowY = shipLandY - shipY + 60;
            const shadowGrad = ctx.createRadialGradient(0, shadowY, 5, 0, shadowY, 80);
            shadowGrad.addColorStop(0, 'rgba(0,0,0,0.4)');
            shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = shadowGrad;
            ctx.fillRect(-100, shadowY - 10, 200, 25);
            ctx.globalAlpha = 1;
        }

        // -- WINGS (wide, aggressive forward-swept) --
        // Under-wing shadow layer
        ctx.fillStyle = '#060a10';
        ctx.beginPath();
        ctx.moveTo(-14, -6); ctx.lineTo(-148, 22); ctx.lineTo(-118, 62); ctx.lineTo(-26, 28);
        ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(14, -6); ctx.lineTo(148, 22); ctx.lineTo(118, 62); ctx.lineTo(26, 28);
        ctx.closePath(); ctx.fill();

        // Main wing surface
        const wingGrad = ctx.createLinearGradient(-140, 0, 0, 50);
        wingGrad.addColorStop(0, '#101a28');
        wingGrad.addColorStop(0.3, '#1a2a3c');
        wingGrad.addColorStop(0.7, '#142030');
        wingGrad.addColorStop(1, '#0c1420');
        ctx.fillStyle = wingGrad;
        ctx.beginPath();
        ctx.moveTo(-12, -8); ctx.lineTo(-145, 20); ctx.lineTo(-115, 58); ctx.lineTo(-26, 26);
        ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(12, -8); ctx.lineTo(145, 20); ctx.lineTo(115, 58); ctx.lineTo(26, 26);
        ctx.closePath(); ctx.fill();

        // Wing top specular
        ctx.globalAlpha = 0.06;
        const wingSpec = ctx.createLinearGradient(0, -10, 0, 40);
        wingSpec.addColorStop(0, '#ffffff');
        wingSpec.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = wingSpec;
        ctx.beginPath();
        ctx.moveTo(-12, -8); ctx.lineTo(-145, 20); ctx.lineTo(-130, 32); ctx.lineTo(-20, 6);
        ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(12, -8); ctx.lineTo(145, 20); ctx.lineTo(130, 32); ctx.lineTo(20, 6);
        ctx.closePath(); ctx.fill();
        ctx.globalAlpha = 1;

        // Wing leading-edge rim light
        ctx.strokeStyle = 'rgba(160, 210, 255, 0.14)';
        ctx.lineWidth = 1.2;
        ctx.beginPath(); ctx.moveTo(-12, -8); ctx.lineTo(-145, 20); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(12, -8); ctx.lineTo(145, 20); ctx.stroke();

        // Wing panel lines
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.35)';
        ctx.lineWidth = 0.6;
        ctx.beginPath(); ctx.moveTo(-30, -2); ctx.lineTo(-120, 28); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-38, 12); ctx.lineTo(-108, 42); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-70, 14); ctx.lineTo(-72, 50); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(30, -2); ctx.lineTo(120, 28); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(38, 12); ctx.lineTo(108, 42); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(70, 14); ctx.lineTo(72, 50); ctx.stroke();

        // Wing-tip weapon pods
        for (const side of [-1, 1]) {
            const tipX = side * 140;
            const tipY = 22;
            ctx.fillStyle = '#0a0e16';
            ctx.beginPath();
            ctx.moveTo(tipX - side * 8, tipY - 5);
            ctx.lineTo(tipX + side * 4, tipY - 3);
            ctx.lineTo(tipX + side * 6, tipY + 8);
            ctx.lineTo(tipX - side * 10, tipY + 6);
            ctx.closePath(); ctx.fill();
            const wpulse = 0.3 + Math.sin(now * 0.004 + side) * 0.2;
            ctx.shadowColor = 'rgba(255, 40, 20, 0.5)';
            ctx.shadowBlur = 6;
            ctx.fillStyle = `rgba(255, 50, 30, ${wpulse})`;
            ctx.beginPath(); ctx.arc(tipX, tipY + 1, 2, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
        }

        // -- NACELLE PYLONS + ENGINE PODS --
        for (const side of [-1, 1]) {
            const px = side * 56;
            ctx.fillStyle = '#0e1520';
            ctx.beginPath();
            ctx.moveTo(side * 22, 14); ctx.lineTo(px - side * 4, 22);
            ctx.lineTo(px + side * 2, 40); ctx.lineTo(side * 24, 32);
            ctx.closePath(); ctx.fill();

            const nacGrad = ctx.createLinearGradient(px - 8, 18, px + 8, 38);
            nacGrad.addColorStop(0, '#1c2a3a');
            nacGrad.addColorStop(0.5, '#12202e');
            nacGrad.addColorStop(1, '#0a1420');
            ctx.fillStyle = nacGrad;
            ctx.fillRect(px - 8, 18, 16, 22);

            ctx.strokeStyle = `rgba(80, 200, 240, ${0.2 + engineGlow * 0.35})`;
            ctx.lineWidth = 1.2;
            ctx.beginPath(); ctx.arc(px, 29, 6, 0, Math.PI * 2); ctx.stroke();
            ctx.fillStyle = `rgba(80, 200, 240, ${0.08 + engineGlow * 0.25})`;
            ctx.beginPath(); ctx.arc(px, 29, 3.5, 0, Math.PI * 2); ctx.fill();

            ctx.globalAlpha = 0.08;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(px - 6, 18, 12, 4);
            ctx.globalAlpha = 1;
        }

        // -- MAIN HULL (layered fuselage with depth) --
        ctx.fillStyle = '#050910';
        ctx.beginPath();
        ctx.moveTo(0, -88); ctx.lineTo(-18, -64); ctx.lineTo(-34, -18);
        ctx.lineTo(-32, 22); ctx.lineTo(-20, 50); ctx.lineTo(20, 50);
        ctx.lineTo(32, 22); ctx.lineTo(34, -18); ctx.lineTo(18, -64);
        ctx.closePath(); ctx.fill();

        const hullGrad = ctx.createLinearGradient(-30, -80, 30, 50);
        hullGrad.addColorStop(0, '#2c3a4c');
        hullGrad.addColorStop(0.2, '#1e2c3c');
        hullGrad.addColorStop(0.5, '#162436');
        hullGrad.addColorStop(0.8, '#0e1a28');
        hullGrad.addColorStop(1, '#0a1018');
        ctx.fillStyle = hullGrad;
        ctx.beginPath();
        ctx.moveTo(0, -86); ctx.lineTo(-16, -62); ctx.lineTo(-30, -16);
        ctx.lineTo(-28, 20); ctx.lineTo(-18, 46); ctx.lineTo(18, 46);
        ctx.lineTo(28, 20); ctx.lineTo(30, -16); ctx.lineTo(16, -62);
        ctx.closePath(); ctx.fill();

        // Hull upper specular
        ctx.globalAlpha = 0.07;
        const hullSpec = ctx.createLinearGradient(0, -86, 0, 0);
        hullSpec.addColorStop(0, '#ffffff');
        hullSpec.addColorStop(0.4, 'rgba(200,220,255,0.5)');
        hullSpec.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = hullSpec;
        ctx.beginPath();
        ctx.moveTo(0, -86); ctx.lineTo(-14, -62); ctx.lineTo(-20, -20);
        ctx.lineTo(20, -20); ctx.lineTo(14, -62);
        ctx.closePath(); ctx.fill();
        ctx.globalAlpha = 1;

        // Raised center spine
        const spineGrad = ctx.createLinearGradient(-6, 0, 6, 0);
        spineGrad.addColorStop(0, 'rgba(255,255,255,0)');
        spineGrad.addColorStop(0.3, 'rgba(255,255,255,0.04)');
        spineGrad.addColorStop(0.5, 'rgba(255,255,255,0.07)');
        spineGrad.addColorStop(0.7, 'rgba(255,255,255,0.04)');
        spineGrad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = spineGrad;
        ctx.fillRect(-8, -80, 16, 120);

        // Hull panel lines
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.lineWidth = 0.7;
        ctx.beginPath(); ctx.moveTo(-16, -44); ctx.lineTo(16, -44); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-24, -14); ctx.lineTo(24, -14); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-26, 10); ctx.lineTo(26, 10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-22, 30); ctx.lineTo(22, 30); ctx.stroke();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.25)';
        ctx.beginPath(); ctx.moveTo(0, -84); ctx.lineTo(0, 44); ctx.stroke();

        // Hull edge rim light
        ctx.strokeStyle = 'rgba(180, 220, 255, 0.08)';
        ctx.lineWidth = 0.8;
        ctx.beginPath();
        ctx.moveTo(-16, -62); ctx.lineTo(-30, -16); ctx.lineTo(-28, 20); ctx.lineTo(-18, 46);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(16, -62); ctx.lineTo(30, -16); ctx.lineTo(28, 20); ctx.lineTo(18, 46);
        ctx.stroke();

        // -- WEATHERING / BATTLE SCARRING --
        ctx.globalAlpha = 0.06;
        ctx.fillStyle = '#000000';
        ctx.fillRect(-12, -30, 8, 2);
        ctx.fillRect(6, -18, 10, 1.5);
        ctx.fillRect(-8, 16, 6, 1.5);
        ctx.globalAlpha = 0.03;
        ctx.fillRect(-20, -50, 3, 40);
        ctx.fillRect(14, -40, 2, 35);
        ctx.fillRect(-6, 8, 2, 28);
        ctx.globalAlpha = 1;

        // -- BRIDGE VIEWPORT (menacing red slit) --
        ctx.save();
        ctx.shadowColor = 'rgba(255, 50, 30, 0.7)';
        ctx.shadowBlur = 14;
        ctx.fillStyle = '#040810';
        ctx.fillRect(-14, -74, 28, 8);
        const vpPulse = 0.7 + Math.sin(now * 0.003) * 0.15;
        const vpGrad = ctx.createLinearGradient(-10, -72, 10, -72);
        vpGrad.addColorStop(0, `rgba(255, 40, 20, ${vpPulse * 0.2})`);
        vpGrad.addColorStop(0.3, `rgba(255, 60, 30, ${vpPulse * 0.85})`);
        vpGrad.addColorStop(0.5, `rgba(255, 80, 40, ${vpPulse * 0.95})`);
        vpGrad.addColorStop(0.7, `rgba(255, 60, 30, ${vpPulse * 0.85})`);
        vpGrad.addColorStop(1, `rgba(255, 40, 20, ${vpPulse * 0.2})`);
        ctx.fillStyle = vpGrad;
        ctx.fillRect(-10, -73, 20, 5);
        ctx.restore();

        // -- NAV & RUNNING LIGHTS --
        const navPulse = 0.5 + Math.sin(now * 0.005) * 0.3;
        ctx.shadowColor = 'rgba(255, 30, 20, 0.5)';
        ctx.shadowBlur = 5;
        ctx.fillStyle = `rgba(255, 40, 30, ${navPulse + 0.15})`;
        ctx.beginPath(); ctx.arc(-142, 22, 1.8, 0, Math.PI * 2); ctx.fill();
        ctx.shadowColor = 'rgba(255, 30, 20, 0.5)';
        ctx.fillStyle = `rgba(255, 40, 30, ${navPulse + 0.15})`;
        ctx.beginPath(); ctx.arc(142, 22, 1.8, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;
        const strobe = Math.sin(now * 0.008) > 0.85 ? 0.6 : 0;
        if (strobe > 0) {
            ctx.fillStyle = `rgba(255, 255, 255, ${strobe})`;
            ctx.beginPath(); ctx.arc(0, 46, 1.5, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(-22, 38, 1, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(22, 38, 1, 0, Math.PI * 2); ctx.fill();
        }
        ctx.fillStyle = `rgba(60, 160, 255, ${0.2 + navPulse * 0.15})`;
        ctx.beginPath(); ctx.arc(-18, 18, 1.2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(18, 18, 1.2, 0, Math.PI * 2); ctx.fill();

        // -- AFT ENGINE HOUSING --
        ctx.fillStyle = '#080e18';
        ctx.fillRect(-16, 42, 32, 8);
        for (let en = -1; en <= 1; en++) {
            ctx.fillStyle = '#040810';
            ctx.beginPath(); ctx.arc(en * 9, 48, 4.5, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = `rgba(120, 200, 255, ${engineGlow * (0.3 + Math.sin(now * 0.009 + en) * 0.1)})`;
            ctx.beginPath(); ctx.arc(en * 9, 48, 3, 0, Math.PI * 2); ctx.fill();
        }

        // -- LANDING GEAR --
        if (landPhase > 0.6) {
            const gearExt = Math.min(1, (landPhase - 0.6) * 3.5);
            ctx.globalAlpha = gearExt;
            ctx.strokeStyle = '#3a4450';
            ctx.lineWidth = 1.8;
            for (const gx of [-14, 0, 14]) {
                const gy = gx === 0 ? 50 : 46;
                ctx.beginPath(); ctx.moveTo(gx, gy); ctx.lineTo(gx + (gx < 0 ? -3 : gx > 0 ? 3 : 0), gy + gearExt * 14); ctx.stroke();
                ctx.fillStyle = '#4a5568';
                ctx.fillRect(gx - 4 + (gx < 0 ? -2 : gx > 0 ? 2 : 0), gy + gearExt * 12, 8, 2.5);
            }
            ctx.globalAlpha = 1;
        }

        // -- SHIP GLOW (same energy glow as player mechs) --
        {
            const shipGlowPulse = 0.4 + Math.sin(now * 0.002) * 0.15;
            // Outer body glow
            ctx.save();
            ctx.shadowColor = `rgba(60, 160, 255, ${shipGlowPulse * 0.6})`;
            ctx.shadowBlur = 25;
            ctx.strokeStyle = `rgba(80, 180, 255, ${shipGlowPulse * 0.2})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -86); ctx.lineTo(-16, -62); ctx.lineTo(-30, -16);
            ctx.lineTo(-28, 20); ctx.lineTo(-18, 46); ctx.lineTo(18, 46);
            ctx.lineTo(28, 20); ctx.lineTo(30, -16); ctx.lineTo(16, -62);
            ctx.closePath(); ctx.stroke();
            ctx.restore();
            
            // Wing edge glow
            ctx.save();
            ctx.shadowColor = `rgba(60, 160, 255, ${shipGlowPulse * 0.4})`;
            ctx.shadowBlur = 15;
            ctx.strokeStyle = `rgba(80, 180, 255, ${shipGlowPulse * 0.12})`;
            ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(-12, -8); ctx.lineTo(-145, 20); ctx.lineTo(-115, 58); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(12, -8); ctx.lineTo(145, 20); ctx.lineTo(115, 58); ctx.stroke();
            ctx.restore();
        }

        // -- ELECTRICITY ARCS (crackling energy around the ship hull) --
        {
            const elT = now;
            const elChance = Math.sin(elT * 0.002) * Math.cos(elT * 0.001);
            if (elChance > 0.15 && Math.random() < 0.4) {
                ctx.save();
                ctx.strokeStyle = '#00ddff';
                ctx.shadowColor = '#00ddff';
                ctx.shadowBlur = 16;
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.7 + Math.random() * 0.3;
                
                const numArcs = 1 + Math.floor(Math.random() * 3);
                for (let a = 0; a < numArcs; a++) {
                    // Random start on hull perimeter
                    const side = Math.random() > 0.5 ? 1 : -1;
                    const startX = side * (10 + Math.random() * 25);
                    const startY = -80 + Math.random() * 120;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    
                    let px = startX, py = startY;
                    const segs = 3 + Math.floor(Math.random() * 4);
                    for (let i = 0; i < segs; i++) {
                        px += (Math.random() - 0.5) * 28;
                        py += (Math.random() - 0.3) * 20;
                        ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
                
                // Occasional wing arc
                if (Math.random() < 0.3) {
                    const ws = Math.random() > 0.5 ? 1 : -1;
                    ctx.beginPath();
                    ctx.moveTo(ws * 30, 10);
                    let wx = ws * 30, wy = 10;
                    for (let i = 0; i < 4; i++) {
                        wx += ws * (15 + Math.random() * 20);
                        wy += (Math.random() - 0.5) * 15;
                        ctx.lineTo(wx, wy);
                    }
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }

        ctx.restore();


        // === STORY TEXT ===
        ctx.textAlign = 'center';
        for (const line of storyLines) {
            const lineElapsed = elapsed - line.t;
            if (lineElapsed < 0) continue;
            // Fade in over 400ms, hold, then fade out
            const holdDuration = line.fade || 1200;
            const fadeIn = Math.min(1, lineElapsed / 400);
            const fadeOut = Math.max(0, 1 - Math.max(0, lineElapsed - holdDuration - 1500) / 600);
            const alpha = fadeIn * fadeOut;
            if (alpha <= 0) continue;

            ctx.globalAlpha = alpha;
            const baseColor = line.color || (line.size > 22 ? '#50c8ff' : '#c0e8ff');
            ctx.fillStyle = baseColor;
            ctx.font = `${line.size > 22 ? '800' : '400'} ${line.size}px system-ui, -apple-system, Arial`;
            if (line.size > 22) {
                ctx.shadowColor = line.color ? 'rgba(255, 80, 80, 0.6)' : 'rgba(60, 180, 255, 0.6)';
                ctx.shadowBlur = 20;
            }
            ctx.fillText(line.text, W * 0.5, H * line.y);
            ctx.shadowBlur = 0;
        }

        // "Press any key to skip" hint after 2s
        if (elapsed > 2000) {
            ctx.globalAlpha = 0.3 + Math.sin(now * 0.003) * 0.1;
            ctx.fillStyle = '#6a8a9a';
            ctx.font = '13px system-ui, Arial';
            ctx.fillText('Press any key or click to skip', W * 0.5, H * 0.94);
        }

        ctx.globalAlpha = 1;
        ctx.textAlign = 'left';

        requestAnimationFrame(drawFrame);
    }

    requestAnimationFrame(drawFrame);
}

let lastTime = 0;
function gameLoop(timestamp) {
  // Don't run game logic or draw during intro cinematic or character select
  if (introRunning || charSelectRunning) {
    lastTime = timestamp;
    requestAnimationFrame(gameLoop);
    return;
  }
  try {
    const deltaTime = Math.min(timestamp - lastTime, 50); // Cap at 50ms to prevent post-pause jumps
    lastTime = timestamp;
    update(deltaTime);
    draw();
  } catch (err) {
    fatalError = (err && err.stack) ? err.stack : String(err);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#0b0f1a';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#ff4d4d';
    ctx.font = '16px monospace';
    ctx.fillText('Game crashed (copy this error):', 20, 40);
    ctx.fillStyle = '#e6e6e6';
    const lines = String(fatalError).split('\n').slice(0, 16);
    for (let i=0;i<lines.length;i++) ctx.fillText(lines[i].slice(0, 160), 20, 70 + i*18);
    return;
  }
  requestAnimationFrame(gameLoop);
}

// Bullseye cursor element
const bullseye = document.getElementById('bullseye');

// Update bullseye (aim reticle) position
function updateBullseye() { /* reticle is drawn in-canvas */ }


// Initialize bullseye to screen center so it never appears "stuck" at (0,0)
(function initBullseyeCenter(){
    mouseX = canvas.width * 0.5;
    mouseY = canvas.height * 0.5;
    aimX = mouseX;
    aimY = mouseY;
    updateBullseye();
})();
window.addEventListener('resize', () => {
    // keep aim reasonable on resize
    mouseX = Math.min(Math.max(20, mouseX), canvas.width - 20);
    mouseY = Math.min(Math.max(20, mouseY), canvas.height - 20);
    aimX = Math.min(Math.max(20, aimX), canvas.width - 20);
    aimY = Math.min(Math.max(20, aimY), canvas.height - 20);
    updateBullseye();
});

// Keep the bullseye locked to the pointer (desktop + touch/stylus).
// Use window-level listeners so the aim never gets "stuck" at the top if the pointer slips off the canvas.
// Aim control:
// - Desktop: LEFT click sets the bullseye position (aim point)
// - Touch: TAP sets the bullseye; drag while touching to adjust
let aimPointerDown = false;
let aimPointerId = null;

const setAimFromEvent = (e) => {
    if (!e) return;
    if (typeof e.clientX === 'number' && typeof e.clientY === 'number') {
        mouseX = clientToCanvasX(e.clientX);
        mouseY = clientToCanvasY(e.clientY);
        // click-to-place: the reticle lives where you click/tap, independent of cursor movement
        aimX = mouseX;
        aimY = mouseY;
        updateBullseye();
    }
};

window.addEventListener('pointerdown', (e) => {
    // Only allow aim placement after the game starts
    if (!document.body.classList.contains('inGame')) return;

    // If the user is pressing HUD/D-pad controls, don't move the aim reticle.
    // (This was causing the bullseye to "jump" onto the FIRE button and feel stuck.)
    const t = e.target;
    if (t && t.closest && (t.closest('#dpad') || t.closest('#hud') || t.closest('#pauseOverlay') || t.closest('#pauseBtn') || t.closest('.mobile-btn'))) {
        return;
    }

    // Desktop: primary button places aim and can drag-to-adjust while held
    if (e.pointerType === 'mouse') {
        if (e.button !== 0) return;
        aimPointerDown = true;
        aimPointerId = e.pointerId;
        setAimFromEvent(e);
        return;
    }

    // Touch / pen: tap places aim and enables drag-to-adjust while pressed
    aimPointerDown = true;
    aimPointerId = e.pointerId;
    setAimFromEvent(e);
}, { passive: true });

window.addEventListener('pointermove', (e) => {
    // Drag-adjust aim while pressed:
    // - Touch/Pen: while finger/stylus is down
    // - Mouse: while primary button is held (click-drag to adjust)
    // Click to place aim, then it stays locked until you click again
    if (!document.body.classList.contains('inGame')) return;

    const t = e.target;
    if (t && t.closest && (t.closest('#dpad') || t.closest('#hud') || t.closest('#pauseOverlay') || t.closest('#pauseBtn') || t.closest('.mobile-btn'))) {
        return;
    }

    if (!aimPointerDown) return;
    if (aimPointerId !== null && e.pointerId !== aimPointerId) return;

    if (e.pointerType === 'mouse') {
        // Only drag-adjust while primary button held
        if ((e.buttons & 1) !== 1) return;
        setAimFromEvent(e);
        return;
    }

    if (e.pointerType === 'touch' || e.pointerType === 'pen') {
        setAimFromEvent(e);
    }
}, { passive: true });

window.addEventListener('pointerup', (e) => {
    if (aimPointerId !== null && e.pointerId !== aimPointerId) return;
    aimPointerDown = false;
    aimPointerId = null;
}, { passive: true });

window.addEventListener('pointercancel', (e) => {
    if (aimPointerId !== null && e.pointerId !== aimPointerId) return;
    aimPointerDown = false;
    aimPointerId = null;
}, { passive: true });

// Mouse (desktop) is AIM ONLY.
// Firing is ONLY:
//   - Keyboard: hold [F]
//   - Mobile/Tablet: hold the D-pad FIRE button
// (This matches your request and prevents mouse buttons from stealing aim.)
// Track which keys are currently held
const keysHeld = {};

// WASD keyboard controls for movement and F for fire
document.addEventListener('keydown', (e) => {
    if (e.repeat) return; // Ignore key repeat
    keysHeld[e.code] = true;
    
    if (e.code === 'KeyP' || e.code === 'Escape') { e.preventDefault(); togglePause(); return; }
    if (e.code === 'Space') { e.preventDefault(); activateFlight(); }
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') { e.preventDefault(); activateShield(); }
    // WASD movement
    if (e.code === 'KeyW' || e.code === 'ArrowUp') { 
        e.preventDefault(); 
        dpadState.up = true;
        // Jump if on ground or on a platform (not flying, not already jumping, not underwater)
        if (!player.isFlying && !player.isJumping && !isUnderwater) {
            const groundY = canvas.height - 120;
            const onGround = Math.abs(player.y - groundY) < 8;
            const onPlat = !!player._onPlatform;
            if (onGround || onPlat) {
                if (onPlat) player._onPlatform = null; // leave platform
                if (dpadState.right || dpadState.left) {
                    // Directional jump
                    player.isJumping = true;
                    player.jumpVY = -12;
                    player.jumpVX = dpadState.right ? 6 : -6;
                    AudioSystem.playJump();
                } else {
                    // Double-tap up for straight jump
                    const now = Date.now();
                    if ((now - dpadState.lastUpTap) < 300) {
                        player.isJumping = true;
                        player.jumpVY = -11;
                        player.jumpVX = 0;
                        AudioSystem.playJump();
                    }
                    dpadState.lastUpTap = now;
                }
            }
        }
    }
    if (e.code === 'KeyS' || e.code === 'ArrowDown') { e.preventDefault(); dpadState.down = true; }
    if (e.code === 'KeyA' || e.code === 'ArrowLeft') { e.preventDefault(); dpadState.left = true; }
    if (e.code === 'KeyD' || e.code === 'ArrowRight') { e.preventDefault(); dpadState.right = true; }
    // F key to fire
    if (e.code === 'KeyF') { e.preventDefault(); isFiring = true; fireOneRocket(true); }
});
document.addEventListener('keyup', (e) => {
    keysHeld[e.code] = false;
    
    if (e.code === 'KeyW' || e.code === 'ArrowUp') { dpadState.up = false; }
    if (e.code === 'KeyS' || e.code === 'ArrowDown') { dpadState.down = false; }
    if (e.code === 'KeyA' || e.code === 'ArrowLeft') { dpadState.left = false; }
    if (e.code === 'KeyD' || e.code === 'ArrowRight') { dpadState.right = false; }
    if (e.code === 'KeyF') { isFiring = false; }
});
// ===== On-screen D-Pad (works on desktop + mobile; avoids right-click) =====
const btnUp = document.getElementById('btnUp');
const btnDown = document.getElementById('btnDown');
const btnLeft = document.getElementById('btnLeft');
const btnRight = document.getElementById('btnRight');
const btnFire = document.getElementById('btnFire');

const flyBtn = document.getElementById('flyBtn');
const shieldBtn = document.getElementById('shieldBtn');
const pauseBtn = document.getElementById('pauseBtn');

const dpadState = { up:false, down:false, left:false, right:false, upTime:0, leftTime:0, rightTime:0, lastUpTap:0 };

function setBtnOn(el, on){ if(!el) return; el.classList.toggle('on', !!on); }

function hold(el, downFn, upFn){
  let pid = null;
  let isActive = false;
  const up = (e) => {
    if (pid !== null && e && e.pointerId !== undefined && e.pointerId !== pid) return;
    try { if (pid !== null) el.releasePointerCapture(pid); } catch {}
    pid = null;
    if (isActive) {
        isActive = false;
        upFn();
    }
    syncDpadVisuals();
  };
  el.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    AudioSystem.resume();
    // Release any existing capture first
    if (pid !== null) {
        try { el.releasePointerCapture(pid); } catch {}
        if (isActive) {
            isActive = false;
            upFn();
        }
    }
    pid = e.pointerId;
    try { el.setPointerCapture(pid); } catch {}
    isActive = true;
    downFn();
    syncDpadVisuals();
  });
  el.addEventListener('pointerup', up);
  el.addEventListener('pointercancel', up);
  el.addEventListener('lostpointercapture', (e) => { 
    if (pid !== null && (e.pointerId === undefined || e.pointerId === pid)) { 
        pid = null; 
        if (isActive) {
            isActive = false;
            upFn(); 
        }
        syncDpadVisuals(); 
    } 
  });
  
  // Touch event backups for mobile browsers
  el.addEventListener('touchstart', (e) => {
    e.preventDefault();
    AudioSystem.resume();
    if (!isActive) {
        isActive = true;
        downFn();
        el.classList.add('on');
        syncDpadVisuals();
    }
  });
  el.addEventListener('touchend', (e) => {
    e.preventDefault();
    if (isActive) {
        isActive = false;
        upFn();
        el.classList.remove('on');
        syncDpadVisuals();
    }
  });
  el.addEventListener('touchcancel', (e) => {
    e.preventDefault();
    if (isActive) {
        isActive = false;
        upFn();
        el.classList.remove('on');
        syncDpadVisuals();
    }
  });
}

function syncDpadVisuals(){
  setBtnOn(btnUp, dpadState.up && !paused);
  setBtnOn(btnDown, dpadState.down && !paused);
  setBtnOn(btnLeft, dpadState.left && !paused);
  setBtnOn(btnRight, dpadState.right && !paused);
  setBtnOn(btnFire, isFiring && !paused);
}

hold(btnUp,   ()=>{ 
    const now = Date.now();
    const wasDoubleTap = (now - dpadState.lastUpTap) < 300;
    dpadState.lastUpTap = now;
    dpadState.up=true; dpadState.upTime=now; 
    if (wasDoubleTap) { doStraightJump(); } else { checkDpadJump(); }
},    ()=>dpadState.up=false);
hold(btnDown, ()=>dpadState.down=true,  ()=>dpadState.down=false);
hold(btnLeft, ()=>{ dpadState.left=true; dpadState.leftTime=Date.now(); checkDpadJump(); },  ()=>dpadState.left=false);
hold(btnRight,()=>{ dpadState.right=true; dpadState.rightTime=Date.now(); checkDpadJump(); }, ()=>dpadState.right=false);

// Combo jump: if Up + Left/Right pressed within 250ms of each other, jump
function checkDpadJump() {
    if (player.isFlying || player.isJumping || isUnderwater) return;
    const now = Date.now();
    const comboWindow = 250; // ms
    const gY = canvas.height - 120;
    const onGround = Math.abs(player.y - gY) < 8;
    const onPlat = !!player._onPlatform;
    if (!onGround && !onPlat) return;
    
    const upRecent = (now - dpadState.upTime) < comboWindow;
    const leftRecent = (now - dpadState.leftTime) < comboWindow;
    const rightRecent = (now - dpadState.rightTime) < comboWindow;
    
    if (upRecent && rightRecent) {
        if (onPlat) player._onPlatform = null;
        player.isJumping = true;
        player.jumpVY = -12;
        player.jumpVX = 6;
        AudioSystem.playJump();
    } else if (upRecent && leftRecent) {
        if (onPlat) player._onPlatform = null;
        player.isJumping = true;
        player.jumpVY = -12;
        player.jumpVX = -6;
        AudioSystem.playJump();
    }
    // Straight-up jump handled by double-tap up (doStraightJump)
}

function doStraightJump() {
    if (player.isFlying || player.isJumping || isUnderwater) return;
    const gY = canvas.height - 120;
    const onGround = Math.abs(player.y - gY) < 8;
    const onPlat = !!player._onPlatform;
    if (!onGround && !onPlat) return;
    if (onPlat) player._onPlatform = null;
    player.isJumping = true;
    player.jumpVY = -11;
    player.jumpVX = 0;
    AudioSystem.playJump();
}

// FIRE BUTTON - Auto-aim: ground = shoot at nearest enemy or forward, flying = shoot downward
function getAutoAimTarget() {
    const armX = player.x + (player.facingRight ? 35 : -35);
    const armY = player.y - player.height * 0.35;
    
    if (player.isFlying) {
        // Flying: shoot downward at 45 degree angle in facing direction
        return {
            x: player.x + (player.facingRight ? 300 : -300),
            y: player.y + 250
        };
    }
    
    // On ground: find nearest enemy in facing direction
    let bestTarget = null;
    let bestDist = 600; // max range
    
    enemies.forEach(enemy => {
        const enemyDir = enemy.x > player.x;
        // Only target enemies in the direction we're facing
        if (enemyDir === player.facingRight) {
            const dist = Math.abs(enemy.x - player.x);
            if (dist < bestDist) {
                bestDist = dist;
                bestTarget = { x: enemy.x, y: enemy.y - enemy.height * 0.4 };
            }
        }
    });
    
    // If no enemy found, shoot straight forward
    if (!bestTarget) {
        bestTarget = {
            x: player.x + (player.facingRight ? 500 : -500),
            y: armY
        };
    }
    
    return bestTarget;
}

function doFire() {
    if (!gameRunning || paused) return;
    AudioSystem.resume();
    
    // Fire from actual gun barrel with rotation
    const torsoW = player.width * 0.62;
    const torsoY = -player.height * 0.34;
    const shoulderX = torsoW/2 - 10;
    const shoulderY = torsoY + 18;
    const muzzleX = 132;  // Extended barrel tip
    const muzzleY = 0;   // Single barrel center
    
    // Use arm angle directly - sprite flip handles left/right orientation
    const clampedArmAngle = Math.max(-1.57, Math.min(1.57, player.armAngle));
    
    const rotatedMuzzleX = muzzleX * Math.cos(clampedArmAngle) - muzzleY * Math.sin(clampedArmAngle);
    const rotatedMuzzleY = muzzleX * Math.sin(clampedArmAngle) + muzzleY * Math.cos(clampedArmAngle);
    
    const gunLocalX = shoulderX + rotatedMuzzleX;
    const gunLocalY = shoulderY + rotatedMuzzleY;
    
    const gunX = player.x + (player.facingRight ? gunLocalX : -gunLocalX);
    const gunY = player.y + gunLocalY;
    
    // Fire in the EXACT direction the gun is visually pointing
    const fireDistance = 2000;
    let targetX, targetY;
    
    if (player.facingRight) {
        targetX = gunX + Math.cos(clampedArmAngle) * fireDistance;
        targetY = gunY + Math.sin(clampedArmAngle) * fireDistance;
    } else {
        targetX = gunX - Math.cos(clampedArmAngle) * fireDistance;
        targetY = gunY + Math.sin(clampedArmAngle) * fireDistance;
    }
    
    fireRocket(gunX, gunY, targetX, targetY);
    playShoot();
}

// D-pad FIRE handled via pointer events below (and keyboard F).
// D-pad FIRE: hold-to-fire (no timers here; the main update loop handles fireRate)
btnFire.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    AudioSystem.resume();
    isFiring = true;
    fireOneRocket(true); // immediate shot
    btnFire.setPointerCapture?.(e.pointerId);
    syncDpadVisuals();
});
const stopFire = () => { isFiring = false; syncDpadVisuals(); };
btnFire.addEventListener('pointerup', (e) => { e?.preventDefault?.(); stopFire(); });
btnFire.addEventListener('pointerleave', (e) => { e?.preventDefault?.(); stopFire(); });
btnFire.addEventListener('pointercancel', (e) => { e?.preventDefault?.(); stopFire(); });

// Touch backup for fire button (some mobile browsers need this)
btnFire.addEventListener('touchstart', (e) => {
    e.preventDefault();
    AudioSystem.resume();
    isFiring = true;
    fireOneRocket(true);
    btnFire.classList.add('on');
});
btnFire.addEventListener('touchend', (e) => {
    e.preventDefault();
    isFiring = false;
    btnFire.classList.remove('on');
    syncDpadVisuals();
});
btnFire.addEventListener('touchcancel', (e) => {
    e.preventDefault();
    isFiring = false;
    btnFire.classList.remove('on');
    syncDpadVisuals();
});


pauseBtn.addEventListener('pointerdown', (e) => { 
    e.preventDefault(); 
    e.stopPropagation();
    togglePause(); 
});

// Abilities buttons: shown only when charged (handled in updateUI). Pointerdown triggers ability.
flyBtn.addEventListener('pointerdown', (e) => { e.preventDefault(); AudioSystem.resume(); activateFlight(); });
shieldBtn.addEventListener('pointerdown', (e) => { e.preventDefault(); AudioSystem.resume(); activateShield(); });

// Disable context menu on the game so right-click doesn't steal focus (still optional)
canvas.addEventListener('contextmenu', (e) => e.preventDefault());

// Update movement target from D-pad each frame (see patch: updateMovementFromDpad()).
function updateMovementFromDpad(){
  const dx = (dpadState.right ? 1 : 0) - (dpadState.left ? 1 : 0);
  const dy = (dpadState.down ? 1 : 0) - (dpadState.up ? 1 : 0);
  const groundLevel = canvas.height - 120;  // Raised ground

  // If any direction is held, force movement like a classic pad.
  if (dx !== 0 || dy !== 0){
    isMoving = true;

    const pushX = 420;

    // During jump, don't override X (jump physics handles it)
    if (!player.isJumping) {
        player.targetX = player.x + dx * pushX;
    }
    
    // Keep on ground unless flying or jumping
    if (player.isJumping) {
        // Jump physics handles Y - don't override
    } else if (!player.isFlying){
      player.targetY = groundLevel;
    } else {
      // When flying, allow much more vertical movement
      player.targetY = player.y + dy * 500;
    }
  } else {
    // If D-pad not held, stop moving
    if (!player.isJumping) isMoving = false;
  }
  
  // Mobile jump handled by checkDpadJump() combo detector
}

// Touch visual feedback only (activation handled by pointerdown above)
flyBtn.addEventListener('touchstart', (e) => { e.preventDefault(); flyBtn.classList.add('active'); });
shieldBtn.addEventListener('touchstart', (e) => { e.preventDefault(); shieldBtn.classList.add('active'); });
flyBtn.addEventListener('touchend', (e) => { e.preventDefault(); flyBtn.classList.remove('active'); });
shieldBtn.addEventListener('touchend', (e) => { e.preventDefault(); shieldBtn.classList.remove('active'); });

canvas.addEventListener('touchmove', (e) => { 
    e.preventDefault(); 
    const touch = e.touches[0]; 
    mouseX = touch.clientX; 
    mouseY = touch.clientY; 
    updateBullseye();
});
canvas.addEventListener('touchstart', (e) => { 
    e.preventDefault(); 
    AudioSystem.resume(); 
    const touch = e.touches[0]; 
    mouseX = touch.clientX; 
    mouseY = touch.clientY; 
    updateBullseye();
});

// ===== D-PAD DRAG FUNCTIONALITY =====
(function() {
    const dpad = document.getElementById('dpad');
    let isDragging = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    
    function startDrag(e) {
        // Don't drag if clicking on a button
        if (e.target.classList.contains('dpad-btn')) return;
        
        isDragging = true;
        const rect = dpad.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        dragOffsetX = clientX - rect.left;
        dragOffsetY = clientY - rect.top;
        dpad.style.transition = 'none';
        e.preventDefault();
    }
    
    function drag(e) {
        if (!isDragging) return;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        let newLeft = clientX - dragOffsetX;
        let newBottom = window.innerHeight - clientY - (dpad.offsetHeight - dragOffsetY);
        
        // Keep within bounds
        newLeft = Math.max(5, Math.min(window.innerWidth - dpad.offsetWidth - 5, newLeft));
        newBottom = Math.max(5, Math.min(window.innerHeight - dpad.offsetHeight - 5, newBottom));
        
        dpad.style.left = newLeft + 'px';
        dpad.style.bottom = newBottom + 'px';
        e.preventDefault();
    }
    
    function stopDrag() {
        isDragging = false;
        dpad.style.transition = '';
    }
    
    // Mouse events
    dpad.addEventListener('mousedown', startDrag);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', stopDrag);
    
    // Touch events
    dpad.addEventListener('touchstart', startDrag, { passive: false });
    document.addEventListener('touchmove', drag, { passive: false });
    document.addEventListener('touchend', stopDrag);
})();

document.getElementById('soundToggle').addEventListener('click', () => { AudioSystem.enabled = !AudioSystem.enabled; document.getElementById('soundToggle').textContent = AudioSystem.enabled ? 'üîä SOUND ON' : 'üîá SOUND OFF'; });
document.getElementById('startBtn').addEventListener('click', () => { try { startGame(); } catch(e){ console.error(e); alert('Start error: ' + (e && e.message ? e.message : e)); } });
document.getElementById('restartBtn').addEventListener('click', () => { try { startGame(); } catch(e){ console.error(e); alert('Start error: ' + (e && e.message ? e.message : e)); } });

let pauseStartTime = 0;

function togglePause() {
    paused = !paused;
    const overlay = document.getElementById('pauseOverlay');
    if (overlay) overlay.style.display = paused ? 'flex' : 'none';
    // Update button to show pause or play
    const pauseBtn = document.getElementById('pauseBtn');
    if (pauseBtn) {
        pauseBtn.innerHTML = paused ? '‚ñ∂<br>PLAY' : '‚è∏<br>PAUSE';
        // Toggle blue glow when paused
        if (paused) {
            pauseBtn.classList.add('paused');
        } else {
            pauseBtn.classList.remove('paused');
        }
    }
    
    if (paused) {
        // Record when we paused
        pauseStartTime = Date.now();
    } else {
        // Calculate how long we were paused and extend all timers
        const pauseDuration = Date.now() - pauseStartTime;
        if (pauseDuration > 0) {
            // Extend shield timer
            if (player.shieldUntil > 0) player.shieldUntil += pauseDuration;
            // Extend fly timer
            if (player.flyEndTime > 0) player.flyEndTime += pauseDuration;
            // Extend invulnerability timer
            if (player.invulnUntil > 0) player.invulnUntil += pauseDuration;
        }
    }
}

AudioSystem.init(); initPlayer(); requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
